#===============================================================================
# Script Page: Pokémon Essentials
#===============================================================================
#==============================================================================#
#                              Pokémon Essentials                              #
#                                 Version 19.1                                 #
#                https://github.com/Maruno17/pokemon-essentials                #
#==============================================================================#

 # DO NOT EDIT THESE!
  module Essentials
    VERSION = "19.1"
    ERROR_TEXT = ""
  end

#===============================================================================
# Script Page: MonkeyPatchingTracker
#===============================================================================
class Class
    @@method_history = {}

    def self.method_history
        return @@method_history
    end

   def method_added(method_name)
       @@method_history[self.name] ||= {}
       if @@method_history[self.name].key?(method_name)
         puts "\r\nWARNING: #{method_name} monkey patched in #{self.name}\r\n\r\n"
       end
       @@method_history[self.name][method_name] = caller
   end

   def method_defined_in(method_name)
       return @@method_history[self.name][method_name]
   end
 end

#===============================================================================
# Script Page: ==================
#===============================================================================


#===============================================================================
# Script Page: [[ Technical ]]
#===============================================================================


#===============================================================================
# Script Page: MKXP_Compatibility
#===============================================================================
# Using mkxp-z v2.2.0 - https://gitlab.com/mkxp-z/mkxp-z/-/releases/v2.2.0
$VERBOSE = nil
Font.default_shadow = false if Font.respond_to?(:default_shadow)
Graphics.frame_rate = 40

def pbSetWindowText(string)
  System.set_window_title(string || System.game_title)
end

class Bitmap
  alias mkxp_draw_text draw_text unless method_defined?(:mkxp_draw_text)

  def draw_text(x, y, width, height, text, align = 0)
    height = text_size(text).height
    mkxp_draw_text(x, y, width, height, text, align)
  end
end

module Graphics
  def self.delta_s
    return self.delta.to_f / 1_000_000
  end
end

def pbSetResizeFactor(factor)
  if !$ResizeInitialized
    Graphics.resize_screen(Settings::SCREEN_WIDTH, Settings::SCREEN_HEIGHT)
    $ResizeInitialized = true
  end
  if factor < 0 || factor == 4
    Graphics.fullscreen = true if !Graphics.fullscreen
  else
    Graphics.fullscreen = false if Graphics.fullscreen
    Graphics.scale = (factor + 1) * 0.5
    Graphics.center
  end
end


#===============================================================================
# Script Page: RubyUtilities
#===============================================================================
#===============================================================================
# class Object
#===============================================================================
class Object
  alias full_inspect inspect

  def inspect
    return "#<#{self.class}>"
  end
end

#===============================================================================
# class Class
#===============================================================================
class Class
  def to_sym
    return self.to_s.to_sym
  end
end

#===============================================================================
# class String
#===============================================================================
class String
  def starts_with_vowel?
    return ['a', 'e', 'i', 'o', 'u'].include?(self[0, 1].downcase)
  end

  def first(n = 1)
    return self[0...n]
  end

  def last(n = 1)
    return self[-n..-1] || self
  end

  def blank?
    blank = true
    s = self.scan(/./)
    for l in s
      blank = false if l != ""
    end
    return blank
  end

  def cut(bitmap, width)
    string = self
    width -= bitmap.text_size("...").width
    string_width = 0
    text = []
    for char in string.scan(/./)
      wdh = bitmap.text_size(char).width
      next if (wdh + string_width) > width
      string_width += wdh
      text.push(char)
    end
    text.push("...") if text.length < string.length
    new_string = ""
    for char in text
      new_string += char
    end
    return new_string
  end
end

#===============================================================================
# class Numeric
#===============================================================================
class Numeric
  # Turns a number into a string formatted like 12,345,678.
  def to_s_formatted
    return self.to_s.reverse.gsub(/(\d{3})(?=\d)/, '\1,').reverse
  end

  def to_word
    ret = [_INTL("zero"), _INTL("one"), _INTL("two"), _INTL("three"),
           _INTL("four"), _INTL("five"), _INTL("six"), _INTL("seven"),
           _INTL("eight"), _INTL("nine"), _INTL("ten"), _INTL("eleven"),
           _INTL("twelve"), _INTL("thirteen"), _INTL("fourteen"), _INTL("fifteen"),
           _INTL("sixteen"), _INTL("seventeen"), _INTL("eighteen"), _INTL("nineteen"),
           _INTL("twenty")]
    return ret[self] if self.is_a?(Integer) && self >= 0 && self <= ret.length
    return self.to_s
  end
end

#===============================================================================
# class Array
#===============================================================================
class Array
  def ^(other)   # xor of two arrays
    return (self|other) - (self&other)
  end

  def swap(val1, val2)
    index1 = self.index(val1)
    index2 = self.index(val2)
    self[index1] = val2
    self[index2] = val1
  end
end

#===============================================================================
# module Enumerable
#===============================================================================
module Enumerable
  def transform
    ret = []
    self.each { |item| ret.push(yield(item)) }
    return ret
  end
end

#===============================================================================
# Kernel methods
#===============================================================================
def rand(*args)
  Kernel.rand(*args)
end

class << Kernel
  alias oldRand rand unless method_defined?(:oldRand)
  def rand(a = nil, b = nil)
    if a.is_a?(Range)
      lo = a.min
      hi = a.max
      return lo + oldRand(hi - lo + 1)
    elsif a.is_a?(Numeric)
      if b.is_a?(Numeric)
        return a + oldRand(b - a + 1)
      else
        return oldRand(a)
      end
    elsif a.nil?
      return (b) ? oldRand(b) : oldRand(2)
    end
  end
end

def nil_or_empty?(string)
  return string.nil? || !string.is_a?(String) || string.size == 0
end


#===============================================================================
# Script Page: Intl_Messages
#===============================================================================
def pbAddScriptTexts(items,script)
  script.scan(/(?:_I)\s*\(\s*\"((?:[^\\\"]*\\\"?)*[^\"]*)\"/) { |s|
    string=s[0]
    string.gsub!(/\\\"/,"\"")
    string.gsub!(/\\\\/,"\\")
    items.push(string)
  }
end

def pbAddRgssScriptTexts(items,script)
  script.scan(/(?:_INTL|_ISPRINTF)\s*\(\s*\"((?:[^\\\"]*\\\"?)*[^\"]*)\"/) { |s|
    string=s[0]
    string.gsub!(/\\r/,"\r")
    string.gsub!(/\\n/,"\n")
    string.gsub!(/\\1/,"\1")
    string.gsub!(/\\\"/,"\"")
    string.gsub!(/\\\\/,"\\")
    items.push(string)
  }
end

def pbSetTextMessages
  Graphics.update
  begin
    t = Time.now.to_i
    texts=[]
    for script in $RGSS_SCRIPTS
      if Time.now.to_i - t >= 5
        t = Time.now.to_i
        Graphics.update
      end
      scr=Zlib::Inflate.inflate(script[2])
      pbAddRgssScriptTexts(texts,scr)
    end
    if safeExists?("Data/PluginScripts.rxdata")
      plugin_scripts = load_data("Data/PluginScripts.rxdata")
      plugin_scripts.each do |plugin|
        plugin[2].each do |script|
          if Time.now.to_i - t >= 5
            t = Time.now.to_i
            Graphics.update
          end
          scr = Zlib::Inflate.inflate(script[1]).force_encoding(Encoding::UTF_8)
          pbAddRgssScriptTexts(texts, scr)
        end
      end
    end
    # Must add messages because this code is used by both game system and Editor
    MessageTypes.addMessagesAsHash(MessageTypes::ScriptTexts,texts)
    commonevents = load_data("Data/CommonEvents.rxdata")
    items=[]
    choices=[]
    for event in commonevents.compact
      if Time.now.to_i - t >= 5
        t = Time.now.to_i
        Graphics.update
      end
      begin
        neednewline=false
        lastitem=""
        for j in 0...event.list.size
          list = event.list[j]
          if neednewline && list.code!=401
            if lastitem!=""
              lastitem.gsub!(/([^\.\!\?])\s\s+/) { |m| $1+" " }
              items.push(lastitem)
              lastitem=""
            end
            neednewline=false
          end
          if list.code == 101
            lastitem+="#{list.parameters[0]}"
            neednewline=true
          elsif list.code == 102
            for k in 0...list.parameters[0].length
              choices.push(list.parameters[0][k])
            end
            neednewline=false
          elsif list.code == 401
            lastitem+=" " if lastitem!=""
            lastitem+="#{list.parameters[0]}"
            neednewline=true
          elsif list.code == 355 || list.code == 655
            pbAddScriptTexts(items,list.parameters[0])
          elsif list.code == 111 && list.parameters[0]==12
            pbAddScriptTexts(items,list.parameters[1])
          elsif list.code == 209
            route=list.parameters[1]
            for k in 0...route.list.size
              if route.list[k].code == 45
                pbAddScriptTexts(items,route.list[k].parameters[0])
              end
            end
          end
        end
        if neednewline
          if lastitem!=""
            items.push(lastitem)
            lastitem=""
          end
        end
      end
    end
    if Time.now.to_i - t >= 5
      t = Time.now.to_i
      Graphics.update
    end
    items|=[]
    choices|=[]
    items.concat(choices)
    MessageTypes.setMapMessagesAsHash(0,items)
    mapinfos = pbLoadMapInfos
    mapnames=[]
    for id in mapinfos.keys
      mapnames[id]=mapinfos[id].name
    end
    MessageTypes.setMessages(MessageTypes::MapNames,mapnames)
    for id in mapinfos.keys
      if Time.now.to_i - t >= 5
        t = Time.now.to_i
        Graphics.update
      end
      filename=sprintf("Data/Map%03d.rxdata",id)
      next if !pbRgssExists?(filename)
      map = load_data(filename)
      items=[]
      choices=[]
      for event in map.events.values
        if Time.now.to_i - t >= 5
          t = Time.now.to_i
          Graphics.update
        end
        begin
          for i in 0...event.pages.size
            neednewline=false
            lastitem=""
            for j in 0...event.pages[i].list.size
              list = event.pages[i].list[j]
              if neednewline && list.code!=401
                if lastitem!=""
                  lastitem.gsub!(/([^\.\!\?])\s\s+/) { |m| $1+" " }
                  items.push(lastitem)
                  lastitem=""
                end
                neednewline=false
              end
              if list.code == 101
                lastitem+="#{list.parameters[0]}"
                neednewline=true
              elsif list.code == 102
                for k in 0...list.parameters[0].length
                  choices.push(list.parameters[0][k])
                end
                neednewline=false
              elsif list.code == 401
                lastitem+=" " if lastitem!=""
                lastitem+="#{list.parameters[0]}"
                neednewline=true
              elsif list.code == 355 || list.code==655
                pbAddScriptTexts(items,list.parameters[0])
              elsif list.code == 111 && list.parameters[0]==12
                pbAddScriptTexts(items,list.parameters[1])
              elsif list.code==209
                route=list.parameters[1]
                for k in 0...route.list.size
                  if route.list[k].code==45
                    pbAddScriptTexts(items,route.list[k].parameters[0])
                  end
                end
              end
            end
            if neednewline
              if lastitem!=""
                items.push(lastitem)
                lastitem=""
              end
            end
          end
        end
      end
      if Time.now.to_i - t >= 5
        t = Time.now.to_i
        Graphics.update
      end
      items|=[]
      choices|=[]
      items.concat(choices)
      MessageTypes.setMapMessagesAsHash(id,items)
      if Time.now.to_i - t >= 5
        t = Time.now.to_i
        Graphics.update
      end
    end
  rescue Hangup
  end
  Graphics.update
end

def pbEachIntlSection(file)
  lineno=1
  re=/^\s*\[\s*([^\]]+)\s*\]\s*$/
  havesection=false
  sectionname=nil
  lastsection=[]
  file.each_line { |line|
    if lineno==1 && line[0].ord==0xEF && line[1].ord==0xBB && line[2].ord==0xBF
      line=line[3,line.length-3]
    end
    comment = line[/^\#/] && !line[/^\#{/]
    onlyWhitespace = line[/^\s*$/]
    if !comment && !onlyWhitespace
      if line[re]
        if havesection
          yield lastsection,sectionname,lineno-lastsection.length
        end
        lastsection.clear
        sectionname=$~[1]
        havesection=true
      else
        if sectionname==nil
          raise _INTL("Expected a section at the beginning of the file (line {1})",lineno)
        end
        lastsection.push(line.gsub(/\s+$/,""))
      end
    end
    lineno+=1
    if lineno%500==0
      Graphics.update
    end
  }
  if havesection
    yield lastsection,sectionname,lineno-lastsection.length
  end
end

def pbGetText(infile)
  begin
    file=File.open(infile,"rb")
  rescue
    raise _INTL("Can't find {1}",infile)
  end
  intldat=[]
  begin
    pbEachIntlSection(file) { |section,name,sectionLineStart|
      next if section.length==0
      if !name[/^([Mm][Aa][Pp])?(\d+)$/]
        raise _INTL("Invalid section name {1}",name)
      end
      ismap=$~[1] && $~[1]!=""
      id=$~[2].to_i
      itemlength=0
      if section[0][/^\d+$/]
        intlhash=[]
        itemlength=3
        if ismap
          raise _INTL("Section {1} can't be an ordered list (section was recognized as an ordered list because its first line is a number)",name)
        end
        if section.length%3!=0
          raise _INTL("Section {1}'s line count is not divisible by 3 (section was recognized as an ordered list because its first line is a number)",name)
        end
      else
        intlhash=OrderedHash.new
        itemlength=2
        if section.length%2!=0
          raise _INTL("Section {1} has an odd number of entries (section was recognized as a hash because its first line is not a number)",name)
        end
      end
      i=0;loop do break unless i<section.length
        if itemlength==3
          if !section[i][/^\d+$/]
            raise _INTL("Expected a number in section {1}, got {2} instead",name,section[i])
          end
          key=section[i].to_i
          i+=1
        else
          key=MessageTypes.denormalizeValue(section[i])
        end
        denormalizedValue = MessageTypes.denormalizeValue(section[i+1])
        if intlhash.is_a?(Hash) && intlhash.key?(key)
          echoln "Duplicate key in section #{name} at line #{sectionLineStart+i}"
        else
          intlhash[key]=denormalizedValue
        end
        i+=2
      end
      if ismap
        intldat[0]=[] if !intldat[0]
        intldat[0][id]=intlhash
      else
        intldat[id]=intlhash
      end
    }
  ensure
    file.close
  end
  return intldat
end

def pbCompileText
  for languageIndex in 1...Settings::LANGUAGES.length
    languageEntry = Settings::LANGUAGES[languageIndex]
    languageDataFileName = languageEntry[1]
    languageName = languageDataFileName[0..-5]
    
    outfile=File.open("Data\\" + languageDataFileName,"wb")
    begin
      intldat=pbGetText("PBS\\intl_" + languageName + ".txt")
      Marshal.dump(intldat,outfile)
      yield languageDataFileName
    rescue
      raise
    ensure
      outfile.close
    end
  end
end

class OrderedHash < Hash
  def initialize
    @keys=[]
    super
  end

  def keys
    return @keys.clone
  end

  def inspect
    str="{"
    for i in 0...@keys.length
      str+=", " if i>0
      str+=@keys[i].inspect+"=>"+self[@keys[i]].inspect
    end
    str+="}"
    return str
  end

  alias :to_s :inspect

  def []=(key,value)
    oldvalue=self[key]
    if !oldvalue && value
      @keys.push(key)
    elsif !value
      @keys|=[]
      @keys-=[key]
    end
    return super(key,value)
  end

  def self._load(string)
    ret=self.new
    keysvalues=Marshal.load(string)
    keys=keysvalues[0]
    values=keysvalues[1]
    for i in 0...keys.length
      ret[keys[i]]=values[i]
    end
    return ret
  end

  def _dump(_depth=100)
    values=[]
    for key in @keys
      values.push(self[key])
    end
    return Marshal.dump([@keys,values])
  end
end



class Messages
  def initialize(filename=nil,delayLoad=false)
    @messages=nil
    @filename=filename
    if @filename && !delayLoad
      loadMessageFile(@filename)
    end
  end

  def delayedLoad
    if @filename && !@messages
      loadMessageFile(@filename)
      @filename=nil
    end
  end

  def self.stringToKey(str)
    if str && str[/[\r\n\t\1]|^\s+|\s+$|\s{2,}/]
       key=str.clone
       key.gsub!(/^\s+/,"")
       key.gsub!(/\s+$/,"")
       key.gsub!(/\s{2,}/," ")
       return key
    end
    return str
  end

  def self.normalizeValue(value)
    if value[/[\r\n\t\x01]|^[\[\]]/]
      ret=value.clone
      ret.gsub!(/\r/,"<<r>>")
      ret.gsub!(/\n/,"<<n>>")
      ret.gsub!(/\t/,"<<t>>")
      ret.gsub!(/\[/,"<<[>>")
      ret.gsub!(/\]/,"<<]>>")
      ret.gsub!(/\x01/,"<<1>>")
      return ret
    end
    return value
  end

  def self.denormalizeValue(value)
    if value[/<<[rnt1\[\]]>>/]
      ret=value.clone
      ret.gsub!(/<<1>>/,"\1")
      ret.gsub!(/<<r>>/,"\r")
      ret.gsub!(/<<n>>/,"\n")
      ret.gsub!(/<<\[>>/,"[")
      ret.gsub!(/<<\]>>/,"]")
      ret.gsub!(/<<t>>/,"\t")
      return ret
    end
    return value
  end

  def self.writeObject(f,msgs,secname,origMessages=nil)
    return if !msgs
    if msgs.is_a?(Array)
      f.write("[#{secname}]\r\n")
      for j in 0...msgs.length
        next if nil_or_empty?(msgs[j])
        value=Messages.normalizeValue(msgs[j])
        origValue=""
        if origMessages
          origValue=Messages.normalizeValue(origMessages.get(secname,j))
        else
          origValue=Messages.normalizeValue(MessageTypes.get(secname,j))
        end
        f.write("#{j}\r\n")
        f.write(origValue+"\r\n")
        f.write(value+"\r\n")
      end
    elsif msgs.is_a?(OrderedHash)
      f.write("[#{secname}]\r\n")
      keys=msgs.keys
      for key in keys
        next if nil_or_empty?(msgs[key])
        value=Messages.normalizeValue(msgs[key])
        valkey=Messages.normalizeValue(key)
        # key is already serialized
        f.write(valkey+"\r\n")
        f.write(value+"\r\n")
      end
    end
  end
  
  def self.writeObjectUntranslated(f,msgs,sectionKey,secname,translatedMsgs)
    return if !msgs
    if msgs.is_a?(Array)     
      f.write("[#{secname}]\r\n")
      for j in 0...msgs.length
        next if nil_or_empty?(msgs[j])
        value=Messages.normalizeValue(msgs[j])
        translatedValue = translatedMsgs.get(sectionKey,j)
        next if !nil_or_empty?(translatedValue) && value != Messages.normalizeValue(translatedValue)
        f.write("#{j}\r\n")
        f.write(value+"\r\n")
        f.write(value+"\r\n")
      end
    elsif msgs.is_a?(OrderedHash)
      f.write("[#{secname}]\r\n")
      keys=msgs.keys
      for key in keys
        next if nil_or_empty?(msgs[key])
        value=Messages.normalizeValue(msgs[key])
        valkey=Messages.normalizeValue(key)
        if translatedMsgs.messages[sectionKey]
          id = Messages.stringToKey(key)
          translatedValue = translatedMsgs.messages[sectionKey][id]
          next if !nil_or_empty?(translatedValue) && value != Messages.normalizeValue(translatedValue)
        end
        # key is already serialized
        f.write(valkey+"\r\n")
        f.write(value+"\r\n")
      end
    end
  end
  
  def self.writeMapObjectUntranslated(f,msgs,mapNumber,secname,translatedMsgs)
    return if !msgs
    f.write("[#{secname}]\r\n")
    keys=msgs.keys
    for key in keys
      next if nil_or_empty?(msgs[key])
      value=Messages.normalizeValue(msgs[key])
      valkey=Messages.normalizeValue(key)
      if translatedMsgs.messages[0][mapNumber]
        id = Messages.stringToKey(key)
        translatedValue = translatedMsgs.messages[0][mapNumber][id]
        next if !nil_or_empty?(translatedValue) && value != Messages.normalizeValue(translatedValue)
      end
      # key is already serialized
      f.write(valkey+"\r\n")
      f.write(value+"\r\n")
    end
  end

  def messages
    return @messages || []
  end

  def extract(outfile)
#    return if !@messages
    origMessages=Messages.new("Data/messages.dat")
    File.open(outfile,"wb") { |f|
      f.write(0xef.chr)
      f.write(0xbb.chr)
      f.write(0xbf.chr)
      f.write("# To localize this text for a particular language, please\r\n")
      f.write("# translate every second line of this file.\r\n")
      # Common events and maps
      if origMessages.messages[0]
        for i in 0...origMessages.messages[0].length
          msgs=origMessages.messages[0][i]
          Messages.writeObject(f,msgs,"Map#{i}",origMessages)
        end
      end
      # Other sections
      for i in 1...origMessages.messages.length
        msgs=origMessages.messages[i]
        Messages.writeObject(f,msgs,i,origMessages)
      end
    }
  end
  
  def extractUntranslated(outfile)
    origMessages=Messages.new("Data/messages.dat")
    translatedMessages = Messages.new(languageDataFileName)
    File.open(outfile,"wb") { |f|
      f.write(0xef.chr)
      f.write(0xbb.chr)
      f.write(0xbf.chr)
      f.write("# To localize this text for a particular language, please\r\n")
      f.write("# translate every second line of this file.\r\n")
      # Common events and maps
      if origMessages.messages[0]
        for i in 0...origMessages.messages[0].length
          msgs=origMessages.messages[0][i]
          Messages.writeMapObjectUntranslated(f,msgs,i,"Map#{i}",translatedMessages)
        end
      end
      # Other sections
      for i in 1...origMessages.messages.length
        msgs=origMessages.messages[i]
        Messages.writeObjectUntranslated(f,msgs,i,i.to_s,translatedMessages)
      end
    }
  end

  def setMessages(type,array)
    @messages=[] if !@messages
    arr=[]
    for i in 0...array.length
      arr[i]=(array[i]) ? array[i] : ""
    end
    @messages[type]=arr
  end

  def addMessages(type,array)
    @messages=[] if !@messages
    arr=(@messages[type]) ? @messages[type] : []
    for i in 0...array.length
      arr[i]=(array[i]) ? array[i] : (arr[i]) ? arr[i] : ""
    end
    @messages[type]=arr
  end

  def self.createHash(_type,array)
    arr=OrderedHash.new
    for i in 0...array.length
      if array[i]
        key=Messages.stringToKey(array[i])
        arr[key]=array[i]
      end
    end
    return arr
  end

  def self.addToHash(_type,array,hash)
    hash=OrderedHash.new if !hash
    for i in 0...array.length
      if array[i]
        key=Messages.stringToKey(array[i])
        hash[key]=array[i]
      end
    end
    return hash
  end

  def setMapMessagesAsHash(type,array)
    @messages=[] if !@messages
    @messages[0]=[] if !@messages[0]
    @messages[0][type]=Messages.createHash(type,array)
  end

  def addMapMessagesAsHash(type,array)
    @messages=[] if !@messages
    @messages[0]=[] if !@messages[0]
    @messages[0][type]=Messages.addToHash(type,array,@messages[0][type])
  end

  def setMessagesAsHash(type,array)
    @messages=[] if !@messages
    @messages[type]=Messages.createHash(type,array)
  end

  def addMessagesAsHash(type,array)
    @messages=[] if !@messages
    @messages[type]=Messages.addToHash(type,array,@messages[type])
  end

  def saveMessages(filename=nil)
    filename="Data/messages.dat" if !filename
    File.open(filename,"wb") { |f| Marshal.dump(@messages,f) }
  end

  def loadMessageFile(filename)
    begin
      pbRgssOpen(filename,"rb") { |f| @messages=Marshal.load(f) }
      if !@messages.is_a?(Array)
        @messages=nil
        raise "Corrupted data"
      end
      return @messages
    rescue
      @messages=nil
      return nil
    end
  end

  def set(type,id,value)
    delayedLoad
    return if !@messages
    return if !@messages[type]
    @messages[type][id]=value
  end

  def getCount(type)
    delayedLoad
    return 0 if !@messages
    return 0 if !@messages[type]
    return @messages[type].length
  end

  def get(type,id)
    delayedLoad
    return "" if !@messages
    return "" if !@messages[type]
    return "" if !@messages[type][id]
    return @messages[type][id]
  end

  def getFromHash(type,key)
    delayedLoad
    return key if !@messages || !@messages[type] || !key
    id=Messages.stringToKey(key)
    return key if !@messages[type][id]
    return @messages[type][id]
  end

  def getFromMapHash(type,key)
    delayedLoad
    return key if !@messages
    return key if !@messages[0]
    return key if !@messages[0][type] && !@messages[0][0]
    id=Messages.stringToKey(key)
    if @messages[0][type] &&  @messages[0][type][id]
      return @messages[0][type][id]
    elsif @messages[0][0] && @messages[0][0][id]
      return @messages[0][0][id]
    end
    return key
  end
end



module MessageTypes
  # Value 0 is used for common event and map event text
  Species            = 1
  Kinds              = 2
  Entries            = 3
  FormNames          = 4
  Moves              = 5
  MoveDescriptions   = 6
  Items              = 7
  ItemPlurals        = 8
  ItemDescriptions   = 9
  Abilities          = 10
  AbilityDescs       = 11
  Types              = 12
  TrainerTypes       = 13
  TrainerNames       = 14
  BeginSpeech        = 15
  EndSpeechWin       = 16
  EndSpeechLose      = 17
  RegionNames        = 18
  PlaceNames         = 19
  PlaceDescriptions  = 20
  MapNames           = 21
  PhoneMessages      = 22
  TrainerLoseText    = 23
  ScriptTexts        = 24
  RibbonNames        = 25
  RibbonDescriptions = 26
  Tribes             = 27
  TribeDescriptions  = 28
  Traits             = 29
  Likes              = 30
  Dislikes           = 31
  BattleEffects      = 32
  Achievements       = 33
  AchievementDescs   = 34
  @@messages         = Messages.new
  @@messagesFallback = Messages.new("Data/messages.dat",true)
  
  def self.outputMessages(type)
    @@messages.messages[type].each do |key, value|
      echoln "#{key}: #{value}"
    end
  end

  def self.stringToKey(str)
    return Messages.stringToKey(str)
  end

  def self.normalizeValue(value)
    return Messages.normalizeValue(value)
  end

  def self.denormalizeValue(value)
    Messages.denormalizeValue(value)
  end

  def self.writeObject(f,msgs,secname)
    Messages.denormalizeValue(str)
  end

  def self.extract(outfile)
    @@messages.extract(outfile)
  end
  
  def self.extractUntranslated(outfile)
    @@messages.extractUntranslated(outfile)
  end

  def self.setMessages(type,array)
    @@messages.setMessages(type,array)
  end

  def self.addMessages(type,array)
    @@messages.addMessages(type,array)
  end

  def self.createHash(type,array)
    Messages.createHash(type,array)
  end

  def self.addMapMessagesAsHash(type,array)
    @@messages.addMapMessagesAsHash(type,array)
  end

  def self.setMapMessagesAsHash(type,array)
    @@messages.setMapMessagesAsHash(type,array)
  end

  def self.addMessagesAsHash(type,array)
    @@messages.addMessagesAsHash(type,array)
  end

  def self.setMessagesAsHash(type,array)
    @@messages.setMessagesAsHash(type,array)
  end

  def self.saveMessages(filename=nil)
    @@messages.saveMessages(filename)
  end

  def self.loadMessageFile(filename)
    @@messages.loadMessageFile(filename)
  end

  def self.get(type,id)
    ret=@@messages.get(type,id)
    if ret==""
      ret=@@messagesFallback.get(type,id)
    end
    return ret
  end

  def self.getCount(type)
    c1=@@messages.getCount(type)
    c2=@@messagesFallback.getCount(type)
    return c1>c2 ? c1 : c2
  end

  def self.getOriginal(type,id)
    return @@messagesFallback.get(type,id)
  end

  def self.getFromHash(type,key)
    @@messages.getFromHash(type,key)
  end

  def self.getFromMapHash(type,key)
    @@messages.getFromMapHash(type,key)
  end
end



def pbLoadMessages(file)
  return MessageTypes.loadMessageFile(file)
end

def pbGetMessageCount(type)
  return MessageTypes.getCount(type)
end

def pbGetMessage(type,id)
  return MessageTypes.get(type,id)
end

def pbGetMessageFromHash(type,id)
  return MessageTypes.getFromHash(type,id)
end

# Replaces first argument with a localized version and formats the other
# parameters by replacing {1}, {2}, etc. with those placeholders.
def _INTL(*arg)
  begin
    string=MessageTypes.getFromHash(MessageTypes::ScriptTexts,arg[0])
  rescue
    string=arg[0]
  end
  string=string.clone
  for i in 1...arg.length
    string.gsub!(/\{#{i}\}/,"#{arg[i]}")
  end
  return string
end

# Replaces first argument with a localized version and formats the other
# parameters by replacing {1}, {2}, etc. with those placeholders.
# This version acts more like sprintf, supports e.g. {1:d} or {2:s}
def _ISPRINTF(*arg)
  begin
    string=MessageTypes.getFromHash(MessageTypes::ScriptTexts,arg[0])
  rescue
    string=arg[0]
  end
  string=string.clone
  for i in 1...arg.length
    string.gsub!(/\{#{i}\:([^\}]+?)\}/) { |m|
      next sprintf("%"+$1,arg[i])
    }
  end
  return string
end

def _I(str)
  return _MAPINTL($game_map.map_id,str)
end

def _MAPINTL(mapid,*arg)
  string=MessageTypes.getFromMapHash(mapid,arg[0])
  string=string.clone
  for i in 1...arg.length
    string.gsub!(/\{#{i}\}/,"#{arg[i]}")
  end
  return string
end

def _MAPISPRINTF(mapid,*arg)
  string=MessageTypes.getFromMapHash(mapid,arg[0])
  string=string.clone
  for i in 1...arg.length
    string.gsub!(/\{#{i}\:([^\}]+?)\}/) { |m|
      next sprintf("%"+$1,arg[i])
    }
  end
  return string
end

def currentLanguageName
    return Settings::LANGUAGES[$PokemonSystem.language][1][0..-5]
end

def addLanguageSuffix(fileName)
    return fileName if $PokemonSystem.language == 0 # Add nothing for English
    potentialFileName = fileName + "_" + currentLanguageName
    fileNameToTest = potentialFileName
    fileNameToTest += ".png" unless fileNameToTest.end_with?(".png")
    if safeExists?(fileNameToTest)
      return potentialFileName
    else
      return fileName
    end
end

def languageDataFileName
  return 'Data/' + Settings::LANGUAGES[$PokemonSystem.language][1]
end

def loadLanguage
    pbLoadMessages(languageDataFileName)
end


#===============================================================================
# Script Page: Input
#===============================================================================
module Input
  USE      = C
  BACK     = B
  ACTION   = A
  JUMPUP   = X
  JUMPDOWN = Y
  SPECIAL  = Z
  AUX1     = L
  AUX2     = R

  unless defined?(update_KGC_ScreenCapture)
    class << Input
      alias update_KGC_ScreenCapture update
    end
  end

  def self.update
    update_KGC_ScreenCapture
    if trigger?(Input::F8)
      pbScreenCapture
    end
  end
end

module Mouse
  module_function

  # Returns the position of the mouse relative to the game window.
  def getMousePos(catch_anywhere = false)
    return nil unless System.mouse_in_window || catch_anywhere
    return Input.mouse_x, Input.mouse_y
  end
end


#===============================================================================
# Script Page: PluginManager
#===============================================================================
#==============================================================================#
#                                Plugin Manager                                #
#                                   by Marin                                   #
#               support for external plugin scripts by Luka S.J.               #
#                              tweaked by Maruno                               #
#------------------------------------------------------------------------------#
#   Provides a simple interface that allows plugins to require dependencies    #
#   at specific versions, and to specify incompatibilities between plugins.    #
#                                                                              #
#    Supports external scripts that are in .rb files in folders within the     #
#                               Plugins folder.                                #
#------------------------------------------------------------------------------#
#                                   Usage:                                     #
#                                                                              #
# A Pokémon Essentials plugin should register itself using the PluginManager.  #
# The simplest way to do so, for a plugin without dependencies, is as follows: #
#                                                                              #
#     PluginManager.register({                                                 #
#       :name    => "Basic Plugin",                                            #
#       :version => "1.0",                                                     #
#       :link    => "https://reliccastle.com/link-to-the-plugin/",             #
#       :credits => "Marin"                                                    #
#     })                                                                       #
#                                                                              #
# The link portion here is optional, but recommended. This will be shown in    #
# the error message if the PluginManager detects that this plugin needs to be  #
# updated.                                                                     #
#                                                                              #
# A plugin's version should be in the format X.Y.Z, but the number of digits   #
# you use does not matter. You can also use Xa, Xb, Xc, Ya, etc.               #
# What matters is that you use it consistently, so that it can be compared.    #
#                                                                              #
# IF there are multiple people to credit, their names should be in an array.   #
# If there is only one credit, it does not need an array:                      #
#                                                                              #
#     :credits => "Marin"                                                      #
#     :credits => ["Marin", "Maruno"],                                         #
#                                                                              #
#                                                                              #
#                                                                              #
# Dependency:                                                                  #
#                                                                              #
# A plugin can require another plugin to be installed in order to work. For    #
# example, the "Simple Extension" plugin depends on the above "Basic Plugin"   #
# like so:                                                                     #
#                                                                              #
#     PluginManager.register({                                                 #
#       :name    => "Simple Extension",                                        #
#       :version => "1.0",                                                     #
#       :link    => "https://reliccastle.com/link-to-the-plugin/",             #
#       :credits => ["Marin", "Maruno"],                                       #
#       :dependencies => ["Basic Plugin"]                                      #
#     })                                                                       #
#                                                                              #
# If there are multiple dependencies, they should be listed in an array. If    #
# there is only one dependency, it does not need an array:                     #
#                                                                              #
#     :dependencies => "Basic Plugin"                                          #
#                                                                              #
# To require a minimum version of a dependency plugin, you should turn the     #
# dependency's name into an array which contains the name and the version      #
# (both as strings). For example, to require "Basic Plugin" version 1.2 or     #
# higher, you would write:                                                     #
#                                                                              #
#     :dependencies => [                                                       #
#       ["Basic Plugin", "1.2"]                                                #
#     ]                                                                        #
#                                                                              #
# To require a specific version (no higher and no lower) of a dependency       #
# plugin, you should add the :exact flag as the first thing in the array for   #
# that dependency:                                                             #
#                                                                              #
#     :dependencies => [                                                       #
#       [:exact, "Basic Plugin", "1.2"]                                        #
#     ]                                                                        #
#                                                                              #
# If your plugin can work without another plugin, but it is incompatible with  #
# an old version of that other plugin, you should list it as an optional       #
# dependency. If that other plugin is present in a game, then this optional    #
# dependency will check whether it meets the minimum version required for your #
# plugin. Write it in the same way as any other dependency as described above, #
# but use the :optional flag instead.                                          #
#                                                                              #
#     :dependencies => [                                                       #
#       [:optional, "QoL Improvements", "1.1"]                                 #
#     ]                                                                        #
#                                                                              #
# The :optional_exact flag is a combination of :optional and :exact.           #
#                                                                              #
#                                                                              #
#                                                                              #
# Incompatibility:                                                             #
#                                                                              #
# If your plugin is known to be incompatible with another plugin, you should   #
# list that other plugin as such. Only one of the two plugins needs to list    #
# that it is incompatible with the other.                                      #
#                                                                              #
#     PluginManager.register({                                                 #
#       :name    => "QoL Improvements",                                        #
#       :version => "1.0",                                                     #
#       :link    => "https://reliccastle.com/link-to-the-plugin/",             #
#       :credits => "Marin",                                                   #
#       :incompatibilities => [                                                #
#         "Simple Extension"                                                   #
#       ]                                                                      #
#     })                                                                       #
#                                                                              #
#------------------------------------------------------------------------------#
#                               Plugin folder:                                 #
#                                                                              #
# The Plugin folder is treated like the PBS folder, but for script files for   #
# plugins. Each plugin has its own folder within the Plugin folder. Each       #
# plugin must have a meta.txt file in its folder, which contains information   #
# about that plugin. Folders without this meta.txt file are ignored.           #
#                                                                              #
# Scripts must be in .rb files. You should not put any other files into a      #
# plugin's folder except for script files and meta.txt.                        #
#                                                                              #
# When the game is compiled, scripts in these folders are read and converted   #
# into a usable format, and saved in the file Data/PluginScripts.rxdata.       #
# Script files are loaded in order of their name and subfolder, so it is wise  #
# to name script files "001_first script.rb", "002_second script.rb", etc. to  #
# ensure they are loaded in the correct order.                                 #
#                                                                              #
# When the game is compressed for distribution, the Plugin folder and all its  #
# contents should be deleted (like the PBS folder), because its contents will  #
# be unused (they will have been compiled into the PluginScripts.rxdata file). #
#                                                                              #
# The contents of meta.txt are as follows:                                     #
#                                                                              #
#     Name         = Simple Extension                                          #
#     Version      = 1.0                                                       #
#     Requires     = Basic Plugin                                              #
#     Requires     = Useful Utilities,1.1                                      #
#     Conflicts    = Complex Extension                                         #
#     Conflicts    = Extended Windows                                          #
#     Link         = https://reliccastle.com/link-to-the-plugin/               #
#     Credits      = Luka S.J.,Maruno,Marin                                    #
#                                                                              #
# These lines are related to what is described above. You can have multiple    #
# "Requires" and "Conflicts" lines, each listing a single other plugin that is #
# either a dependency or a conflict respectively.                              #
#                                                                              #
# Examples of the "Requires" line:                                             #
#                                                                              #
#     Requires     = Basic Plugin                                              #
#     Requires     = Basic Plugin,1.1                                          #
#     Requires     = Basic Plugin,1.1,exact                                    #
#     Requires     = Basic Plugin,1.1,optional                                 #
#     Exact        = Basic Plugin,1.1                                          #
#     Optional     = Basic Plugin,1.1                                          #
#                                                                              #
# The "Exact" and "Optional" lines are equivalent to the "Requires" lines      #
# that contain those keywords.                                                 #
#                                                                              #
# There is also a "Scripts" line, which lists one or more script files that    #
# should be loaded first. You can have multiple "Scripts" lines. However, you  #
# can achieve the same effect by simply naming your script files in            #
# alphanumeric order to make them load in a particular order, so the "Scripts" #
# line should not be necessary.                                                #
#                                                                              #
#------------------------------------------------------------------------------#
#                     Please give credit when using this.                      #
#==============================================================================#

module PluginManager
  # Holds all registered plugin data.
  @@Plugins = {}
  #-----------------------------------------------------------------------------
  # Registers a plugin and tests its dependencies and incompatibilities.
  #-----------------------------------------------------------------------------
  def self.register(options)
    name         = nil
    version      = nil
    link         = nil
    dependencies = nil
    incompats    = nil
    credits      = []
    order = [:name, :version, :link, :dependencies, :incompatibilities, :credits]
    # Ensure it first reads the plugin's name, which is used in error reporting,
    # by sorting the keys
    keys = options.keys.sort do |a, b|
      idx_a = order.index(a)
      idx_a = order.size if idx_a == -1
      idx_b = order.index(b)
      idx_b = order.size if idx_b == -1
      next idx_a <=> idx_b
    end
    for key in keys
      value = options[key]
      case key
      when :name   # Plugin name
        if nil_or_empty?(value)
          self.error("Plugin name must be a non-empty string.")
        end
        if !@@Plugins[value].nil?
          self.error("A plugin called '#{value}' already exists.")
        end
        name = value
      when :version   # Plugin version
        if nil_or_empty?(value)
          self.error("Plugin version must be a string.")
        end
        version = value
      when :link   # Plugin website
        if nil_or_empty?(value)
          self.error("Plugin link must be a non-empty string.")
        end
        link = value
      when :dependencies   # Plugin dependencies
        dependencies = value
        dependencies = [dependencies] if !dependencies.is_a?(Array) || !dependencies[0].is_a?(Array)
        for dep in value
          if dep.is_a?(String)   # "plugin name"
            if !self.installed?(dep)
              self.error("Plugin '#{name}' requires plugin '#{dep}' to be installed above it.")
            end
          elsif dep.is_a?(Array)
            case dep.size
            when 1   # ["plugin name"]
              if dep[0].is_a?(String)
                dep_name = dep[0]
                if !self.installed?(dep_name)
                  self.error("Plugin '#{name}' requires plugin '#{dep_name}' to be installed above it.")
                end
              else
                self.error("Expected the plugin name as a string, but got #{dep[0].inspect}.")
              end
            when 2   # ["plugin name", "version"]
              if dep[0].is_a?(Symbol)
                self.error("A plugin version comparator symbol was given but no version was given.")
              elsif dep[0].is_a?(String) && dep[1].is_a?(String)
                dep_name    = dep[0]
                dep_version = dep[1]
                next if self.installed?(dep_name, dep_version)
                if self.installed?(dep_name)   # Have plugin but lower version
                  msg = "Plugin '#{name}' requires plugin '#{dep_name}' version #{dep_version} or higher, " +
                        "but the installed version is #{self.version(dep_name)}."
                  if dep_link = self.link(dep_name)
                    msg += "\r\nCheck #{dep_link} for an update to plugin '#{dep_name}'."
                  end
                  self.error(msg)
                else   # Don't have plugin
                  self.error("Plugin '#{name}' requires plugin '#{dep_name}' version #{dep_version} " +
                      "or higher to be installed above it.")
                end
              end
            when 3   # [:optional/:exact/:optional_exact, "plugin name", "version"]
              if !dep[0].is_a?(Symbol)
                self.error("Expected first dependency argument to be a symbol, but got #{dep[0].inspect}.")
              end
              if !dep[1].is_a?(String)
                self.error("Expected second dependency argument to be a plugin name, but got #{dep[1].inspect}.")
              end
              if !dep[2].is_a?(String)
                self.error("Expected third dependency argument to be the plugin version, but got #{dep[2].inspect}.")
              end
              dep_arg     = dep[0]
              dep_name    = dep[1]
              dep_version = dep[2]
              optional    = false
              exact       = false
              case dep_arg
              when :optional
                optional = true
              when :exact
                exact = true
              when :optional_exact
                optional = true
                exact = true
              else
                self.error("Expected first dependency argument to be one of " +
                           ":optional, :exact or :optional_exact, but got #{dep_arg.inspect}.")
              end
              if optional
                if self.installed?(dep_name) &&   # Have plugin but lower version
                   !self.installed?(dep_name, dep_version, exact)
                  msg = "Plugin '#{name}' requires plugin '#{dep_name}', if installed, to be version #{dep_version}"
                  msg << " or higher" if !exact
                  msg << ", but the installed version was #{self.version(dep_name)}."
                  if dep_link = self.link(dep_name)
                    msg << "\r\nCheck #{dep_link} for an update to plugin '#{dep_name}'."
                  end
                  self.error(msg)
                end
              elsif !self.installed?(dep_name, dep_version, exact)
                if self.installed?(dep_name)   # Have plugin but lower version
                  msg = "Plugin '#{name}' requires plugin '#{dep_name}' to be version #{dep_version}"
                  msg << " or later" if !exact
                  msg << ", but the installed version was #{self.version(dep_name)}."
                  if dep_link = self.link(dep_name)
                    msg << "\r\nCheck #{dep_link} for an update to plugin '#{dep_name}'."
                  end
                  self.error(msg)
                else   # Don't have plugin
                  msg = "Plugin '#{name}' requires plugin '#{dep_name}' version #{dep_version} "
                  msg << "or later" if !exact
                  msg << "to be installed above it."
                  self.error(msg)
                end
              end
            end
          end
        end
      when :incompatibilities   # Plugin incompatibilities
        incompats = value
        incompats = [incompats] if !incompats.is_a?(Array)
        for incompat in incompats
          if self.installed?(incompat)
            self.error("Plugin '#{name}' is incompatible with '#{incompat}'. " +
                       "They cannot both be used at the same time.")
          end
        end
      when :credits # Plugin credits
        value = [value] if value.is_a?(String)
        if value.is_a?(Array)
          for entry in value
            if !entry.is_a?(String)
              self.error("Plugin '#{name}'s credits array contains a non-string value.")
            else
              credits << entry
            end
          end
        else
          self.error("Plugin '#{name}'s credits field must contain a string, or a string array.")
        end
      else
        self.error("Invalid plugin registry key '#{key}'.")
      end
    end
    for plugin in @@Plugins.values
      if plugin[:incompatibilities] && plugin[:incompatibilities].include?(name)
        self.error("Plugin '#{plugin[:name]}' is incompatible with '#{name}'. " +
                   "They cannot both be used at the same time.")
      end
    end
    # Add plugin to class variable
    @@Plugins[name] = {
      :name => name,
      :version => version,
      :link => link,
      :dependencies => dependencies,
      :incompatibilities => incompats,
      :credits => credits
    }
  end
  #-----------------------------------------------------------------------------
  # Throws a pure error message without stack trace or any other useless info.
  #-----------------------------------------------------------------------------
  def self.error(msg)
    Graphics.update
    t = Thread.new do
      echoln "Plugin Error:\r\n#{msg}"
      p "Plugin Error: #{msg}"
      Thread.exit
    end
    while t.status
      Graphics.update
    end
    Kernel.exit! true
  end
  #-----------------------------------------------------------------------------
  # Returns true if the specified plugin is installed.
  # If the version is specified, this version is taken into account.
  # If mustequal is true, the version must be a match with the specified version.
  #-----------------------------------------------------------------------------
  def self.installed?(plugin_name, plugin_version = nil, mustequal = false)
    plugin = @@Plugins[plugin_name]
    return false if plugin.nil?
    return true if plugin_version.nil?
    comparison = compare_versions(plugin[:version], plugin_version)
    return true if !mustequal && comparison >= 0
    return true if mustequal && comparison == 0
  end
  #-----------------------------------------------------------------------------
  # Returns the string names of all installed plugins.
  #-----------------------------------------------------------------------------
  def self.plugins
    return @@Plugins.keys
  end
  #-----------------------------------------------------------------------------
  # Returns the installed version of the specified plugin.
  #-----------------------------------------------------------------------------
  def self.version(plugin_name)
    return if !installed?(plugin_name)
    return @@Plugins[plugin_name][:version]
  end
  #-----------------------------------------------------------------------------
  # Returns the link of the specified plugin.
  #-----------------------------------------------------------------------------
  def self.link(plugin_name)
    return if !installed?(plugin_name)
    return @@Plugins[plugin_name][:link]
  end
  #-----------------------------------------------------------------------------
  # Returns the credits of the specified plugin.
  #-----------------------------------------------------------------------------
  def self.credits(plugin_name)
    return if !installed?(plugin_name)
    return @@Plugins[plugin_name][:credits]
  end
  #-----------------------------------------------------------------------------
  # Compares two versions given in string form. v1 should be the plugin version
  # you actually have, and v2 should be the minimum/desired plugin version.
  # Return values:
  #     1 if v1 is higher than v2
  #     0 if v1 is equal to v2
  #     -1 if v1 is lower than v2
  #-----------------------------------------------------------------------------
  def self.compare_versions(v1, v2)
    d1 = v1.split("")
    d1.insert(0, "0") if d1[0] == "."          # Turn ".123" into "0.123"
    while d1[-1] == "."; d1 = d1[0..-2]; end   # Turn "123." into "123"
    d2 = v2.split("")
    d2.insert(0, "0") if d2[0] == "."          # Turn ".123" into "0.123"
    while d2[-1] == "."; d2 = d2[0..-2]; end   # Turn "123." into "123"
   
    # Compare by period seperated sections if possible
    if d1.include?(".")
        d1Split = d1.join("").split(/\./,-1)
        d2Split = d2.join("").split(/\./,-1)
        for i in 0...[d1Split.length, d2Split.length].max # Compare each subsection in turn
            s1 = d1Split[i] || nil
            s2 = d2Split[i] || nil
            if !s1.nil?
                return 1 if s2.nil?
                comparison = compare_number_arrays(s1.split(""),s2.split(""))
                if comparison != 0
                    return comparison
                end
            else
                return -1 if !s2.nil?
            end
        end
    else
        return compare_number_arrays(d1,d2)
    end
    
    return 0
  end
  
  def self.compare_number_arrays(s1, s2)
    return 1 if s1.size > s2.size
    return -1 if s1.size < s2.size

    for i in 0...s1.size   # Compare each digit in turn
        c1 = s1[i]
        c2 = s2[i]
        if c1
          return 1 if !c2
          return 1 if c1.to_i(16) > c2.to_i(16)
          return -1 if c1.to_i(16) < c2.to_i(16)
        else
          return -1 if c2
        end
    end
    return 0
  end
  #-----------------------------------------------------------------------------
  #  formats the error message
  #-----------------------------------------------------------------------------
  def self.pluginErrorMsg(name, script)
    # begin message formatting
    message  = "[Pokémon Essentials version #{Essentials::VERSION}]\r\n"
    message += "#{Essentials::ERROR_TEXT}\r\n"   # For third party scripts to add to
    message += "Error in Plugin [#{name}]:\r\n"
    message += "#{$!.class} occurred.\r\n"
    # go through message content
    for line in $!.message.split("\r\n")
      next if nil_or_empty?(line)
      n = line[/\d+/]
      err = line.split(":")[-1].strip
      lms = line.split(":")[0].strip
      err.gsub!(n, "") if n
      err = err.capitalize if err.is_a?(String) && !err.empty?
      linum = n ? "Line #{n}: " : ""
      message += "#{linum}#{err}: #{lms}\r\n"
    end
    # show last 10 lines of backtrace
    message += "\r\nBacktrace:\r\n"
    $!.backtrace[0, 10].each { |i| message += "#{i}\r\n" }
    # output to log
    errorlog = "errorlog.txt"
    errorlog = RTP.getSaveFileName("errorlog.txt") if (Object.const_defined?(:RTP) rescue false)
    File.open(errorlog, "ab") do |f|
      f.write("\r\n=================\r\n\r\n[#{Time.now}]\r\n")
      f.write(message)
    end
    # format/censor the error log directory
    errorlogline = errorlog.gsub("/", "\\")
    errorlogline.sub!(Dir.pwd + "\\", "")
    errorlogline.sub!(pbGetUserName, "USERNAME")
    errorlogline = "\r\n" + errorlogline if errorlogline.length > 20
    # output message
    print("#{message}\r\nThis exception was logged in #{errorlogline}.\r\nHold Ctrl when closing this message to copy it to the clipboard.")
    # Give a ~500ms coyote time to start holding Control
    t = System.delta
    until (System.delta - t) >= 500000
      Input.update
      if Input.press?(Input::CTRL)
        Input.clipboard = message
        break
      end
    end
  end
  #-----------------------------------------------------------------------------
  # Used to read the metadata file
  #-----------------------------------------------------------------------------
  def self.readMeta(dir, file)
    filename = "#{dir}/#{file}"
    meta = {}
    # read file
    Compiler.pbCompilerEachPreppedLine(filename) { |line, line_no|
      # split line up into property name and values
      if !line[/^\s*(\w+)\s*=\s*(.*)$/]
        raise _INTL("Bad line syntax (expected syntax like XXX=YYY)\r\n{1}", FileLineData.linereport)
      end
      property = $~[1].upcase
      data = $~[2].split(',')
      data.each_with_index { |value, i| data[i] = value.strip }
      # begin formatting data hash
      case property
      when 'REQUIRES'
        meta[:dependencies] = [] if !meta[:dependencies]
        if data.length < 2   # No version given, just push name of plugin dependency
          meta[:dependencies].push(data[0])
          next
        elsif data.length == 2   # Push name and version of plugin dependency
          meta[:dependencies].push([data[0], data[1]])
        else   # Push dependency type, name and version of plugin dependency
          meta[:dependencies].push([data[2].downcase.to_sym, data[0], data[1]])
        end
      when 'EXACT'
        next if data.length < 2   # Exact dependencies must have a version given; ignore if not
        meta[:dependencies] = [] if !meta[:dependencies]
        meta[:dependencies].push([:exact, data[0], data[1]])
      when 'OPTIONAL'
        next if data.length < 2   # Optional dependencies must have a version given; ignore if not
        meta[:dependencies] = [] if !meta[:dependencies]
        meta[:dependencies].push([:optional, data[0], data[1]])
      when 'CONFLICTS'
        meta[:incompatibilities] = [] if !meta[:incompatibilities]
        data.each { |value| meta[:incompatibilities].push(value) if value && !value.empty? }
      when 'SCRIPTS'
        meta[:scripts] = [] if !meta[:scripts]
        data.each { |scr| meta[:scripts].push(scr) }
      when 'CREDITS'
        meta[:credits] = data
      when 'LINK', 'WEBSITE'
        meta[:link] = data[0]
      else
        meta[property.downcase.to_sym] = data[0]
      end
    }
    # generate a list of all script files to be loaded, in the order they are to
    # be loaded (files listed in the meta file are loaded first)
    meta[:scripts] = [] if !meta[:scripts]
    # get all script files from plugin Dir
    for fl in Dir.all(dir)
      next if !fl.include?(".rb")
      meta[:scripts].push(fl.gsub("#{dir}/", ""))
    end
    # ensure no duplicate script files are queued
    meta[:scripts].uniq!
    
    # generate a list of all PBS extension files to be loaded
    # in the order they are to be loaded
    meta[:pbs_extensions] = [] if !meta[:pbs_extensions]
    # get all script files from plugin Dir
    validExtensionFileNames = Compiler.getTextFiles
    for fl in Dir.all(dir)
      validFile = false
      validExtensionFileNames.each do |validExtensionFileName|
        next unless fl.include?(validExtensionFileName)
        validFile = true
        break
      end
      next unless validFile
      meta[:pbs_extensions].push(fl.gsub("#{dir}/", ""))
    end
    # ensure no duplicate script files are queued
    meta[:pbs_extensions].uniq!
    
    # Register the graphics extension folders if they exist
    meta[:graphics_extensions] = [] if !meta[:graphics_extensions]
    graphicsDirFilePath = "#{dir}/Graphics"
    meta[:graphics_extensions].push(graphicsDirFilePath.gsub("#{dir}/", "")) if Dir.exist?(graphicsDirFilePath)
    
    # return meta hash
    return meta
  end
  #-----------------------------------------------------------------------------
  # Get a list of all the plugin directories to inspect
  #-----------------------------------------------------------------------------
  def self.listAll
    return [] if !$DEBUG || safeExists?("Game.rgssad")
    # get a list of all directories in the `Plugins/` folder
    dirs = []
    Dir.get("Plugins").each { |d| dirs.push(d) if Dir.safe?(d) }
    # return all plugins
    return dirs
  end
  #-----------------------------------------------------------------------------
  # Catch any potential loop with dependencies and raise an error
  #-----------------------------------------------------------------------------
  def self.validateDependencies(name, meta, og = nil)
    # exit if no registered dependency
    return nil if !meta[name] || !meta[name][:dependencies]
    og = [name] if !og
    # go through all dependencies
    for dname in meta[name][:dependencies]
      # clean the name to a simple string
      dname = dname[0] if dname.is_a?(Array) && dname.length == 2
      dname = dname[1] if dname.is_a?(Array) && dname.length == 3
      # catch looping dependency issue
      self.error("Plugin '#{og[0]}' has looping dependencies which cannot be resolved automatically.") if !og.nil? && og.include?(dname)
      new_og = og.clone
      new_og.push(dname)
      self.validateDependencies(dname, meta, new_og)
    end
    return name
  end
  #-----------------------------------------------------------------------------
  # Sort load order based on dependencies (this ends up in reverse order)
  #-----------------------------------------------------------------------------
  def self.sortLoadOrder(order, plugins)
    # go through the load order
    for o in order
      next if !plugins[o] || !plugins[o][:dependencies]
      # go through all dependencies
      for dname in plugins[o][:dependencies]
        # clean the name to a simple string
        dname = dname[0] if dname.is_a?(Array) && dname.length == 2
        dname = dname[1] if dname.is_a?(Array) && dname.length == 3
        # catch missing dependency
        self.error("Plugin '#{o}' requires plugin '#{dname}' to work properly.") if !order.include?(dname)
        # skip if already sorted
        next if order.index(dname) > order.index(o)
        # catch looping dependency issue
        order.swap(o, dname)
        order = self.sortLoadOrder(order, plugins)
      end
    end
    return order
  end
  #-----------------------------------------------------------------------------
  # Get the order in which to load plugins
  #-----------------------------------------------------------------------------
  def self.getPluginOrder
    plugins = {}
    order = []
    # Find all plugin folders that have a meta.txt and add them to the list of
    # plugins.
    for dir in self.listAll
      # skip if there is no meta file
      next if !safeExists?(dir + "/meta.txt")
      ndx = order.length
      meta = self.readMeta(dir, "meta.txt")
      meta[:dir] = dir
      # raise error if no name defined for plugin
      self.error("No 'Name' metadata defined for plugin located at '#{dir}'.") if !meta[:name]
      # raise error if no script defined for plugin
      self.error("No 'Scripts' metadata defined for plugin located at '#{dir}'.") if !meta[:scripts]
      plugins[meta[:name]] = meta
      # raise error if a plugin with the same name already exists
      self.error("A plugin called '#{meta[:name]}' already exists in the load order.") if order.include?(meta[:name])
      order.insert(ndx, meta[:name])
    end
    # validate all dependencies
    order.each { |o| self.validateDependencies(o, plugins) }
    # sort the load order
    return self.sortLoadOrder(order, plugins).reverse, plugins
  end
  #-----------------------------------------------------------------------------
  # Check if plugins need compiling
  #-----------------------------------------------------------------------------
  def self.needCompiling?(order, plugins)
    # fixed actions
    return false if !$DEBUG || safeExists?("Game.rgssad")
    return true if !safeExists?("Data/PluginScripts.rxdata")
    return true if !safeExists?("Data/PBSExtensions.rxdata")
    return true if !safeExists?("Data/GraphicsExtensions.rxdata")
    Input.update
    return true if Input.press?(Input::CTRL)
    # analyze whether or not to push recompile
    mtimeScripts = File.mtime("Data/PluginScripts.rxdata")
    mtimeExtensions = File.mtime("Data/PBSExtensions.rxdata")
    mtime = [mtimeScripts,mtimeExtensions].min
    for o in order
      # go through all the registered plugin scripts
      scr = plugins[o][:scripts]
      ext = plugins[o][:pbs_extensions]
      dir = plugins[o][:dir]
      for sc in scr
        return true if File.mtime("#{dir}/#{sc}") > mtime
      end
      for ex in ext
        return true if File.mtime("#{dir}/#{ex}") > mtime
      end
      return true if File.mtime("#{dir}/meta.txt") > mtime
    end
    return false
  end
  #-----------------------------------------------------------------------------
  # Check if plugins need compiling
  #-----------------------------------------------------------------------------
  def self.compilePlugins(order, plugins)
    echo 'Compiling plugin scripts...'
    scripts = []
    pbsExtensions = []
    graphicsExtensions = []
    # go through the entire order one by one
    for o in order
      # save name, metadata and scripts array
      meta = plugins[o].clone
      meta.delete(:scripts)
      meta.delete(:pbs_extensions)
      meta.delete(:graphics_extensions)
      meta.delete(:dir)
      
      scriptData = [o, meta, []]
      # iterate through each file to deflate
      for file in plugins[o][:scripts]
        File.open("#{plugins[o][:dir]}/#{file}", 'rb') do |f|
          scriptData[2].push([file, Zlib::Deflate.deflate(f.read)])
        end
      end
      # push to the main scripts array
      scripts.push(scriptData)
      
      pbsExtensionsData = [o, meta, []]
      # iterate through each file to deflate
      for file in plugins[o][:pbs_extensions]
        filePath = "#{plugins[o][:dir]}/#{file}"
        File.open(filePath, 'rb') do |f|
          pbsExtensionsData[2].push([file, filePath])
        end
      end
      # push to the PBS extensions array
      pbsExtensions.push(pbsExtensionsData)
      
      # Create an array of all the graphic extensions file paths
      for file in plugins[o][:graphics_extensions]
        filePath = "#{plugins[o][:dir]}/#{file}"
        graphicsExtensions.push(filePath)
      end
    end
    # save to main `PluginScripts.rxdata` file
    File.open("Data/PluginScripts.rxdata", 'wb') { |f| Marshal.dump(scripts, f) }
    # save to main `PBSExtensions.rxdata` file
    File.open("Data/PBSExtensions.rxdata", 'wb') { |f| Marshal.dump(pbsExtensions, f) }
    # save to main 'GraphicsExtensions.rxdata' file
    File.open("Data/GraphicsExtensions.rxdata", 'wb') { |f| Marshal.dump(graphicsExtensions, f) }
    # collect garbage
    GC.start
    echoln ' done.'
    echoln ''
  end
  #-----------------------------------------------------------------------------
  # Check if plugins need compiling
  #-----------------------------------------------------------------------------
  def self.runPlugins
    # get the order of plugins to interpret
    order, plugins = self.getPluginOrder
    # compile if necessary
    self.compilePlugins(order, plugins) if self.needCompiling?(order, plugins)
    # load plugin scripts
    scripts = load_data("Data/PluginScripts.rxdata")
    echoed_plugins = []
    for plugin in scripts
      # get the required data
      name, meta, script = plugin
      # register plugin
      self.register(meta)
      # go through each script and interpret
      for scr in script
        # turn code into plaintext
        code = Zlib::Inflate.inflate(scr[1]).force_encoding(Encoding::UTF_8)
        # get rid of tabs
        code.gsub!("\t", "  ")
        # construct filename
        sname = scr[0].gsub("\\","/").split("/")[-1]
        fname = "[#{name}] #{sname}"
        # try to run the code
        begin
          eval(code, TOPLEVEL_BINDING, fname)
          echoln "Loaded plugin scripts: #{name}" if !echoed_plugins.include?(name)
          echoed_plugins.push(name)
        rescue Exception   # format error message to display
          self.pluginErrorMsg(name, sname)
          Kernel.exit! true
        end
      end
    end
    echoln '' if !echoed_plugins.empty?
    
    # load pbs extensions
    pbsExtensions = load_data("Data/PBSExtensions.rxdata")
    for plugin in pbsExtensions
      # get the required data
      name, meta, extensions = plugin
      # register plugin, unless it already is
      self.register(meta) unless @@Plugins.key?(name)
      # go through each extension and send it to the compiler
      for ext in extensions
        fileName = ext[0].gsub(".txt","")
        filePath = ext[1]
        Compiler.register_extension(fileName,filePath)
        echoln "Loaded plugin extension: #{name} -- #{ext[0]}"
      end
    end
    
    # Register Graphics folders to mount
    graphicsExtensions = load_data("Data/GraphicsExtensions.rxdata")
    anyGraphicsExtended = false
    for graphicsExtension in graphicsExtensions
      System.mount(graphicsExtension,"Graphics",false)
      anyGraphicsExtended = true
      echoln "Mounted additional Graphics folder: #{graphicsExtension}"
    end
    if anyGraphicsExtended
      echoln "Reloading system cache! This might take a while."
      System.reload_cache
    end
  end
  #-----------------------------------------------------------------------------
end

def pbGetUserName
    return System.user_name
end

#===============================================================================
# Script Page: RPG_Sprite
#===============================================================================
class SpriteAnimation
  @@_animations      = []
  @@_reference_count = {}

  def initialize(sprite)
    @sprite = sprite
  end

  %w[
     x y ox oy viewport flash src_rect opacity tone
  ].each_with_index do |s, _i|
  eval <<-__END__

  def #{s}(*arg)
    @sprite.#{s}(*arg)
  end

  __END__
  end

  def self.clear
    @@_animations.clear
  end

  def dispose
    dispose_animation
    dispose_loop_animation
  end

  def animation(animation, hit, height = 3)
    dispose_animation
    @_animation = animation
    return if @_animation == nil
    @_animation_hit      = hit
    @_animation_height   = height
    @_animation_duration = @_animation.frame_max
    fr = 20
    if @_animation.name[/\[\s*(\d+?)\s*\]\s*$/]
      fr = $~[1].to_i
    end
    @_animation_frame_skip = Graphics.frame_rate / fr
    animation_name = @_animation.animation_name
    animation_hue  = @_animation.animation_hue
    bitmap = pbGetAnimation(animation_name, animation_hue)
    if @@_reference_count.include?(bitmap)
      @@_reference_count[bitmap] += 1
    else
      @@_reference_count[bitmap] = 1
    end
    @_animation_sprites = []
    if @_animation.position != 3 || !@@_animations.include?(animation)
      16.times do
        sprite = ::Sprite.new(self.viewport)
        sprite.bitmap = bitmap
        sprite.visible = false
        @_animation_sprites.push(sprite)
      end
      unless @@_animations.include?(animation)
        @@_animations.push(animation)
      end
    end
    update_animation
  end

  def loop_animation(animation)
    return if animation == @_loop_animation
    dispose_loop_animation
    @_loop_animation = animation
    return if @_loop_animation == nil
    @_loop_animation_index = 0
    fr = 20
    if @_animation.name[/\[\s*(\d+?)\s*\]\s*$/]
      fr = $~[1].to_i
    end
    @_loop_animation_frame_skip = Graphics.frame_rate / fr
    animation_name = @_loop_animation.animation_name
    animation_hue  = @_loop_animation.animation_hue
    bitmap = pbGetAnimation(animation_name, animation_hue)
    if @@_reference_count.include?(bitmap)
      @@_reference_count[bitmap] += 1
    else
      @@_reference_count[bitmap] = 1
    end
    @_loop_animation_sprites = []
    16.times do
      sprite = ::Sprite.new(self.viewport)
      sprite.bitmap = bitmap
      sprite.visible = false
      @_loop_animation_sprites.push(sprite)
    end
    update_loop_animation
  end

  def dispose_animation
    return if @_animation_sprites == nil
    sprite = @_animation_sprites[0]
    if sprite != nil
      @@_reference_count[sprite.bitmap] -= 1
      if @@_reference_count[sprite.bitmap] == 0
        sprite.bitmap.dispose
      end
    end
    for sprite in @_animation_sprites
      sprite.dispose
    end
    @_animation_sprites = nil
    @_animation = nil
  end

  def dispose_loop_animation
    return if @_loop_animation_sprites == nil
    sprite = @_loop_animation_sprites[0]
    if sprite != nil
      @@_reference_count[sprite.bitmap] -= 1
      if @@_reference_count[sprite.bitmap] == 0
        sprite.bitmap.dispose
      end
    end
    for sprite in @_loop_animation_sprites
      sprite.dispose
    end
    @_loop_animation_sprites = nil
    @_loop_animation = nil
  end

  def active?
    return @_loop_animation_sprites != nil || @_animation_sprites != nil
  end

  def effect?
    @_animation_duration if !@_animation_duration
    return @_animation_duration > 0
  end

  def update
    if @_animation != nil
      quick_update = true
      if Graphics.frame_count % @_animation_frame_skip == 0
        @_animation_duration -= 1
        quick_update = false
      end
      update_animation(quick_update)
    end
    if @_loop_animation != nil
      quick_update = (Graphics.frame_count % @_loop_animation_frame_skip != 0)
      update_loop_animation(quick_update)
      if !quick_update
        @_loop_animation_index += 1
        @_loop_animation_index %= @_loop_animation.frame_max
      end
    end
  end

  def update_animation(quick_update = false)
    if @_animation_duration <= 0
      dispose_animation
      return
    end
    frame_index = @_animation.frame_max - @_animation_duration
    cell_data   = @_animation.frames[frame_index].cell_data
    position    = @_animation.position
    animation_set_sprites(@_animation_sprites, cell_data, position, quick_update)
    return if quick_update
    for timing in @_animation.timings
      next if timing.frame != frame_index
      animation_process_timing(timing, @_animation_hit)
    end
  end

  def update_loop_animation(quick_update = false)
    frame_index = @_loop_animation_index
    cell_data   = @_loop_animation.frames[frame_index].cell_data
    position    = @_loop_animation.position
    animation_set_sprites(@_loop_animation_sprites, cell_data, position, quick_update)
    return if quick_update
    for timing in @_loop_animation.timings
      next if timing.frame != frame_index
      animation_process_timing(timing, true)
    end
  end

  def animation_set_sprites(sprites, cell_data, position, quick_update = false)
    sprite_x = 320
    sprite_y = 240
    if position == 3
      if self.viewport != nil
        sprite_x = self.viewport.rect.width / 2
        sprite_y = self.viewport.rect.height - 160
      end
    else
      sprite_x = self.x - self.ox + self.src_rect.width / 2
      sprite_y = self.y - self.oy
      sprite_y += self.src_rect.height / 2 if position == 1
      sprite_y += self.src_rect.height if position == 2
    end
    for i in 0..15
      sprite = sprites[i]
      pattern = cell_data[i, 0]
      if sprite == nil || pattern == nil || pattern == -1
        sprite.visible = false if sprite != nil
        next
      end
      sprite.x          = sprite_x + cell_data[i, 1]
      sprite.y          = sprite_y + cell_data[i, 2]
      next if quick_update
      sprite.visible    = true
      sprite.src_rect.set(pattern % 5 * 192, pattern / 5 * 192, 192, 192)
      case @_animation_height
      when 0 then sprite.z  = 1
      when 1 then sprite.z  = sprite.y+32+15
      when 2 then sprite.z  = sprite.y+32+32+17
      else        sprite.z  = 2000
      end
      sprite.ox         = 96
      sprite.oy         = 96
      sprite.zoom_x     = cell_data[i, 3] / 100.0
      sprite.zoom_y     = cell_data[i, 3] / 100.0
      sprite.angle      = cell_data[i, 4]
      sprite.mirror     = (cell_data[i, 5] == 1)
      sprite.tone       = self.tone
      sprite.opacity    = cell_data[i, 6] * self.opacity / 255.0
      sprite.blend_type = cell_data[i, 7]
    end
  end

  def animation_process_timing(timing, hit)
    if timing.condition == 0 ||
       (timing.condition == 1 && hit == true) ||
       (timing.condition == 2 && hit == false)
      if timing.se.name != ""
        se = timing.se
        pbSEPlay(se)
      end
      case timing.flash_scope
      when 1
        self.flash(timing.flash_color, timing.flash_duration * 2)
      when 2
        if self.viewport != nil
          self.viewport.flash(timing.flash_color, timing.flash_duration * 2)
        end
      when 3
        self.flash(nil, timing.flash_duration * 2)
      end
    end
  end

  def x=(x)
    sx = x - self.x
    return if sx == 0
    if @_animation_sprites != nil
      for i in 0..15
        @_animation_sprites[i].x += sx
      end
    end
    if @_loop_animation_sprites != nil
      for i in 0..15
        @_loop_animation_sprites[i].x += sx
      end
    end
  end

  def y=(y)
    sy = y - self.y
    return if sy == 0
    if @_animation_sprites != nil
      for i in 0..15
        @_animation_sprites[i].y += sy
      end
    end
    if @_loop_animation_sprites != nil
      for i in 0..15
        @_loop_animation_sprites[i].y += sy
      end
    end
  end
end



module RPG
  class Sprite < ::Sprite
    def initialize(viewport = nil)
      super(viewport)
      @_whiten_duration    = 0
      @_appear_duration    = 0
      @_escape_duration    = 0
      @_collapse_duration  = 0
      @_damage_duration    = 0
      @_animation_duration = 0
      @_blink              = false
      @animations     = []
      @loopAnimations = []
    end

    def dispose
      dispose_damage
      dispose_animation
      dispose_loop_animation
      super
    end

    def whiten
      self.blend_type     = 0
      self.color.set(255, 255, 255, 128)
      self.opacity        = 255
      @_whiten_duration   = 16
      @_appear_duration   = 0
      @_escape_duration   = 0
      @_collapse_duration = 0
    end

    def appear
      self.blend_type     = 0
      self.color.set(0, 0, 0, 0)
      self.opacity        = 0
      @_appear_duration   = 16
      @_whiten_duration   = 0
      @_escape_duration   = 0
      @_collapse_duration = 0
    end

    def escape
      self.blend_type     = 0
      self.color.set(0, 0, 0, 0)
      self.opacity        = 255
      @_escape_duration   = 32
      @_whiten_duration   = 0
      @_appear_duration   = 0
      @_collapse_duration = 0
    end

    def collapse
      self.blend_type     = 1
      self.color.set(255, 64, 64, 255)
      self.opacity        = 255
      @_collapse_duration = 48
      @_whiten_duration   = 0
      @_appear_duration   = 0
      @_escape_duration   = 0
    end

    def damage(value, critical)
      dispose_damage
      damage_string = (value.is_a?(Numeric)) ? value.abs.to_s : value.to_s
      bitmap = Bitmap.new(160, 48)
      bitmap.font.name = "Arial Black"
      bitmap.font.size = 32
      bitmap.font.color.set(0, 0, 0)
      bitmap.draw_text(-1, 12-1, 160, 36, damage_string, 1)
      bitmap.draw_text(+1, 12-1, 160, 36, damage_string, 1)
      bitmap.draw_text(-1, 12+1, 160, 36, damage_string, 1)
      bitmap.draw_text(+1, 12+1, 160, 36, damage_string, 1)
      if value.is_a?(Numeric) && value < 0
        bitmap.font.color.set(176, 255, 144)
      else
        bitmap.font.color.set(255, 255, 255)
      end
      bitmap.draw_text(0, 12, 160, 36, damage_string, 1)
      if critical
        bitmap.font.size = 20
        bitmap.font.color.set(0, 0, 0)
        bitmap.draw_text(-1, -1, 160, 20, "CRITICAL", 1)
        bitmap.draw_text(+1, -1, 160, 20, "CRITICAL", 1)
        bitmap.draw_text(-1, +1, 160, 20, "CRITICAL", 1)
        bitmap.draw_text(+1, +1, 160, 20, "CRITICAL", 1)
        bitmap.font.color.set(255, 255, 255)
        bitmap.draw_text(0, 0, 160, 20, "CRITICAL", 1)
      end
      @_damage_sprite = ::Sprite.new(self.viewport)
      @_damage_sprite.bitmap = bitmap
      @_damage_sprite.ox     = 80
      @_damage_sprite.oy     = 20
      @_damage_sprite.x      = self.x
      @_damage_sprite.y      = self.y - self.oy / 2
      @_damage_sprite.z      = 3000
      @_damage_duration      = 40
    end

    def pushAnimation(array, anim)
      for i in 0...array.length
        next if array[i] && array[i].active?
        array[i] = anim
        return
      end
      array.push(anim)
    end

    def animation(animation, hit, height = 3)
      anim = SpriteAnimation.new(self)
      anim.animation(animation,hit,height)
      pushAnimation(@animations,anim)
    end

    def loop_animation(animation)
      anim = SpriteAnimation.new(self)
      anim.loop_animation(animation)
      pushAnimation(@loopAnimations,anim)
    end

    def dispose_damage
      return if @_damage_sprite == nil
      @_damage_sprite.bitmap.dispose
      @_damage_sprite.dispose
      @_damage_sprite   = nil
      @_damage_duration = 0
    end

    def dispose_animation
      for a in @animations
        a.dispose_animation if a
      end
      @animations.clear
    end

    def dispose_loop_animation
      for a in @loopAnimations
        a.dispose_loop_animation if a
      end
      @loopAnimations.clear
    end

    def blink_on
      return if @_blink
      @_blink = true
      @_blink_count = 0
    end

    def blink_off
      return unless @_blink
      @_blink = false
      self.color.set(0, 0, 0, 0)
    end

    def blink?
      return @_blink
    end

    def effect?
      return true if @_whiten_duration > 0
      return true if @_appear_duration > 0
      return true if @_escape_duration > 0
      return true if @_collapse_duration > 0
      return true if @_damage_duration > 0
      for a in @animations
        return true if a.effect?
      end
      return false
    end

    def update
      super
      if @_whiten_duration > 0
        @_whiten_duration -= 1
        self.color.alpha = 128 - (16 - @_whiten_duration) * 10
      end
      if @_appear_duration > 0
        @_appear_duration -= 1
        self.opacity = (16 - @_appear_duration) * 16
      end
      if @_escape_duration > 0
        @_escape_duration -= 1
        self.opacity = 256 - (32 - @_escape_duration) * 10
      end
      if @_collapse_duration > 0
        @_collapse_duration -= 1
        self.opacity = 256 - (48 - @_collapse_duration) * 6
      end
      if @_damage_duration > 0
        @_damage_duration -= 1
        case @_damage_duration
        when 38..39
          @_damage_sprite.y -= 4
        when 36..37
          @_damage_sprite.y -= 2
        when 34..35
          @_damage_sprite.y += 2
        when 28..33
          @_damage_sprite.y += 4
        end
        @_damage_sprite.opacity = 256 - (12 - @_damage_duration) * 32
        if @_damage_duration == 0
          dispose_damage
        end
      end
      for a in @animations
        a.update
      end
      for a in @loopAnimations
        a.update
      end
      if @_blink
        @_blink_count = (@_blink_count + 1) % 32
        if @_blink_count < 16
          alpha = (16 - @_blink_count) * 6
        else
          alpha = (@_blink_count - 16) * 6
        end
        self.color.set(255, 255, 255, alpha)
      end
      SpriteAnimation.clear
    end

    def update_animation
      for a in @animations
        a.update_animation if a && a.active?
      end
    end

    def update_loop_animation
      for a in @loopAnimations
        a.update_loop_animation if a && a.active?
      end
    end

    def x=(x)
      for a in @animations
        a.x = x if a
      end
      for a in @loopAnimations
        a.x = x if a
      end
      super
    end

    def y=(y)
      for a in @animations
        a.y = y if a
      end
      for a in @loopAnimations
        a.y = y if a
      end
      super
    end
  end
end


#===============================================================================
# Script Page: 
#===============================================================================


#===============================================================================
# Script Page: [[ Debugging ]]
#===============================================================================


#===============================================================================
# Script Page: PBDebug
#===============================================================================
module PBDebug
  @@log = []

  def self.logonerr
      begin
        yield
        return true
      rescue
        PBDebug.log("")
        PBDebug.log("**Exception: #{$!.message}")
        PBDebug.log("#{$!.backtrace.inspect}")
        PBDebug.log("")
  #      if $INTERNAL
          pbSEPlay("PC close")
          pbPrintException($!)
  #      end
        PBDebug.flush
        return false
      end
    end

  def self.flush
    if $DEBUG && $INTERNAL && @@log.length>0
      File.open("Data/debuglog.txt", "a+b") { |f| f.write("#{@@log}") }
    end
    @@log.clear
  end

  def self.log(msg)
    if $DEBUG
      echoln("#{msg}\n")
      if $INTERNAL
      @@log.push("#{msg}\r\n")
      PBDebug.flush
      end
    end
  end

  def self.dump(msg)
    if $DEBUG && $INTERNAL
      File.open("Data/dumplog.txt", "a+b") { |f| f.write("#{msg}\r\n") }
    end
  end
end


#===============================================================================
# Script Page: DebugConsole
#===============================================================================
# To use the console, use the executable explicitly built
# with the console enabled on Windows. On Linux and macOS,
# just launch the executable directly from a terminal.
module Console
  def self.setup_console
    return unless $DEBUG
    echoln "--------------------------------"
    echoln "#{System.game_title} Output Window"
    echoln "--------------------------------"
    echoln "If you are seeing this window, you are running"
    echoln "#{System.game_title} in Debug Mode. This means"
    echoln "that you're either playing a Debug Version, or"
    echoln "you are playing from within RPG Maker XP."
    echoln ""
    echoln "Closing this window will close the game. If"
    echoln "you want to get rid of this window, run the"
    echoln "program from the Shell, or download a Release"
    echoln "version."
    echoln ""
    echoln "--------------------------------"
    echoln "Debug Output:"
    echoln "--------------------------------"
    echoln ""
  end

  def self.readInput
    return gets.strip
  end

  def self.readInput2
    return self.readInput
  end

  def self.get_input
    echo self.readInput2
  end
end

module Kernel
  def echo(string)
    return unless $DEBUG
    printf(string.is_a?(String) ? string : string.inspect)
  end

  def echoln(string)
    echo(string)
    echo("\r\n")
  end
end

Console.setup_console


#===============================================================================
# Script Page: Errors
#===============================================================================
#===============================================================================
# Exceptions and critical code
#===============================================================================
class Reset < Exception
end

class Hangup < Exception
end

def pbGetExceptionMessage(e,_script="")
  emessage = e.message.dup
  emessage.force_encoding(Encoding::UTF_8)
  if e.is_a?(Hangup)
    emessage = "The script is taking too long. The game will restart."
  elsif e.is_a?(Errno::ENOENT)
    filename = emessage.sub("No such file or directory - ", "")
    emessage = "File #{filename} not found."
  end
  emessage.gsub!(/Section(\d+)/) { $RGSS_SCRIPTS[$1.to_i][1] } rescue nil
  return emessage
end

def pbPrintException(e)
  emessage = ""
  if $EVENTHANGUPMSG && $EVENTHANGUPMSG!=""
    emessage = $EVENTHANGUPMSG   # Message with map/event ID generated elsewhere
    $EVENTHANGUPMSG = nil
  else
    emessage = pbGetExceptionMessage(e)
  end
  # begin message formatting
  message = "[Pokémon Essentials version #{Essentials::VERSION || ""}]\r\n"
  begin
    gameVersion = Settings::GAME_VERSION
  rescue
    gameVersion = "UNKNOWN"
  end
  message += "[Game version #{gameVersion}]\r\n"
  message += "#{Essentials::ERROR_TEXT}\r\n"   # For third party scripts to add to
  message += "Exception: #{e.class}\r\n"
  message += "Message: #{emessage}\r\n"
  # show last 10/25 lines of backtrace
  message += "\r\nBacktrace:\r\n"
  btrace = ""
  if e.backtrace
    maxlength = ($INTERNAL) ? 25 : 10
    e.backtrace[0, maxlength].each { |i| btrace += "#{i}\r\n" }
  end
  btrace.gsub!(/Section(\d+)/) { $RGSS_SCRIPTS[$1.to_i][1] } rescue nil
  message += btrace
  # output to log
  errorlog = "errorlog.txt"
  errorlog = RTP.getSaveFileName("errorlog.txt") if (Object.const_defined?(:RTP) rescue false)
  File.open(errorlog, "ab") do |f|
    f.write("\r\n=================\r\n\r\n[#{Time.now}]\r\n")
    f.write(message)
  end
  # format/censor the error log directory
  errorlogline = errorlog.gsub("/", "\\")
  errorlogline.sub!(Dir.pwd + "\\", "")
  errorlogline.sub!(pbGetUserName, "USERNAME")
  errorlogline = "\r\n" + errorlogline if errorlogline.length > 20
  # output message
  print("#{message}\r\nThis exception was logged in #{errorlogline}.\r\nHold Ctrl when closing this message to copy it to the clipboard.")
  # Give a ~500ms coyote time to start holding Control
  t = System.delta
  until (System.delta - t) >= 500000
    Input.update
    if Input.press?(Input::CTRL)
      Input.clipboard = message
      break
    end
  end
end

def pbCriticalCode
  ret = 0
  begin
    yield
    ret = 1
  rescue Exception
    e = $!
    if e.is_a?(Reset) || e.is_a?(SystemExit)
      raise
    else
      pbPrintException(e)
      if e.is_a?(Hangup)
        ret = 2
        raise Reset.new
      end
    end
  end
  return ret
end


#===============================================================================
# Script Page: Validation
#===============================================================================
# The Kernel module is extended to include the validate method.
module Kernel
  private
  
  # Used to check whether method arguments are of a given class or respond to a method.
  # @param value_pairs [Hash{Object => Class, Array<Class>, Symbol}] value pairs to validate
  # @example Validate a class or method
  #   validate foo => Integer, baz => :to_s # raises an error if foo is not an Integer or if baz doesn't implement #to_s
  # @example Validate a class from an array
  #   validate foo => [Sprite, Bitmap, Viewport] # raises an error if foo isn't a Sprite, Bitmap or Viewport
  # @raise [ArgumentError] if validation fails
  def validate(value_pairs)
    unless value_pairs.is_a?(Hash)
      raise ArgumentError, "Non-hash argument #{value_pairs.inspect} passed into validate."
    end
    errors = value_pairs.map do |value, condition|
      if condition.is_a?(Array)
        unless condition.any? { |klass| value.is_a?(klass) }
          next "Expected #{value.inspect} to be one of #{condition.inspect}, but got #{value.class.name}."
        end
      elsif condition.is_a?(Symbol)
        next "Expected #{value.inspect} to respond to #{condition}." unless value.respond_to?(condition)
      elsif !value.is_a?(condition)
        next "Expected #{value.inspect} to be a #{condition.name}, but got #{value.class.name}."
      end
    end
    errors.compact!
    return if errors.empty?
    raise ArgumentError, "Invalid argument passed to method.\r\n" + errors.join("\r\n")
  end
end


#===============================================================================
# Script Page: Deprecation
#===============================================================================
# The Deprecation module is used to warn game & plugin creators of deprecated
# methods.
module Deprecation
  module_function

  # Sends a warning of a deprecated method into the debug console.
  # @param method_name [String] name of the deprecated method
  # @param removal_version [String] version the method is removed in
  # @param alternative [String] preferred alternative method
  def warn_method(method_name, removal_version = nil, alternative = nil)
    text = _INTL('WARN: usage of deprecated method "{1}" or its alias.', method_name)
    unless removal_version.nil?
      text += _INTL("\nThe method is slated to be"\
                    " removed in Essentials {1}.", removal_version)
    end
    unless alternative.nil?
      text += _INTL("\nUse \"{1}\" instead.", alternative)
    end
    echoln text
  end
end

# The Module class is extended to allow easy deprecation of instance and class methods.
class Module
  private

  # Creates a deprecated alias for a method.
  # Using it sends a warning to the debug console.
  # @param name [Symbol] name of the new alias
  # @param aliased_method [Symbol] name of the aliased method
  # @param removal_in [String] version the alias is removed in
  # @param class_method [Boolean] whether the method is a class method
  def deprecated_method_alias(name, aliased_method, removal_in: nil, class_method: false)
    validate name => Symbol, aliased_method => Symbol, removal_in => [NilClass, String],
             class_method => [TrueClass, FalseClass]

    target = class_method ? self.class : self
    class_name = self.name

    unless target.method_defined?(aliased_method)
      raise ArgumentError, "#{class_name} does not have method #{aliased_method} defined"
    end

    delimiter = class_method ? '.' : '#'

    target.define_method(name) do |*args, **kvargs|
      alias_name = format('%s%s%s', class_name, delimiter, name)
      aliased_method_name = format('%s%s%s', class_name, delimiter, aliased_method)
      Deprecation.warn_method(alias_name, removal_in, aliased_method_name)
      method(aliased_method).call(*args, **kvargs)
    end
  end
end


#===============================================================================
# Script Page: 
#===============================================================================


#===============================================================================
# Script Page: [[ Files ]]
#===============================================================================


#===============================================================================
# Script Page: FileTests
#===============================================================================
#===============================================================================
#  Reads files of certain format from a directory
#===============================================================================
class Dir
  #-----------------------------------------------------------------------------
  #  Reads all files in a directory
  #-----------------------------------------------------------------------------
  def self.get(dir, filters = "*", full = true)
    files = []
    filters = [filters] if !filters.is_a?(Array)
    self.chdir(dir) do
      for filter in filters
        self.glob(filter){ |f| files.push(full ? (dir + "/" + f) : f) }
      end
    end
    return files.sort
  end
  #-----------------------------------------------------------------------------
  #  Generates entire file/folder tree from a certain directory
  #-----------------------------------------------------------------------------
  def self.all(dir, filters = "*", full = true)
    # sets variables for starting
    files = []
    subfolders = []
    for file in self.get(dir, filters, full)
      # engages in recursion to read the entire file tree
      if self.safe?(file)   # Is a directory
        subfolders += self.all(file, filters, full)
      else   # Is a file
        files += [file]
      end
    end
    # returns all found files
    return files + subfolders
  end
  #-----------------------------------------------------------------------------
  #  Checks for existing directory, gets around accents
  #-----------------------------------------------------------------------------
  def self.safe?(dir)
    return false if !FileTest.directory?(dir)
    ret = false
    self.chdir(dir) { ret = true } rescue nil
    return ret
  end
  #-----------------------------------------------------------------------------
end



#===============================================================================
#  extensions for file class
#===============================================================================
class File
  #-----------------------------------------------------------------------------
  #  Checks for existing file, gets around accents
  #-----------------------------------------------------------------------------
  def self.safe?(file)
    ret = false
    self.open(file, 'rb') { ret = true } rescue nil
    return ret
  end
  #-----------------------------------------------------------------------------
end



#===============================================================================
# Checking for files and directories
#===============================================================================
# Works around a problem with FileTest.directory if directory contains accent marks
def safeIsDirectory?(f)
  ret = false
  Dir.chdir(f) { ret = true } rescue nil
  return ret
end

# Works around a problem with FileTest.exist if path contains accent marks
def safeExists?(f)
  return FileTest.exist?(f) if f[/\A[\x20-\x7E]*\z/]
  ret = false
  begin
    File.open(f,"rb") { ret = true }
  rescue Errno::ENOENT, Errno::EINVAL, Errno::EACCES
    ret = false
  end
  return ret
end

# Similar to "Dir.glob", but designed to work around a problem with accessing
# files if a path contains accent marks.
# "dir" is the directory path, "wildcard" is the filename pattern to match.
def safeGlob(dir,wildcard)
  ret = []
  afterChdir = false
  begin
    Dir.chdir(dir) {
      afterChdir = true
      Dir.glob(wildcard) { |f| ret.push(dir+"/"+f) }
    }
  rescue Errno::ENOENT
    raise if afterChdir
  end
  if block_given?
    ret.each { |f| yield(f) }
  end
  return (block_given?) ? nil : ret
end

def pbResolveAudioSE(file)
  return nil if !file
  if RTP.exists?("Audio/SE/"+file,["",".wav",".mp3",".ogg"])
    return RTP.getPath("Audio/SE/"+file,["",".wav",".mp3",".ogg"])
  end
  return nil
end

# Finds the real path for an image file.  This includes paths in encrypted
# archives.  Returns nil if the path can't be found.
def pbResolveBitmap(x)
  return nil if !x
  noext = x.gsub(/\.(bmp|png|gif|jpg|jpeg)$/,"")
  filename = nil
#  RTP.eachPathFor(x) { |path|
#    filename = pbTryString(path) if !filename
#    filename = pbTryString(path+".gif") if !filename
#  }
  RTP.eachPathFor(noext) { |path|
    filename = pbTryString(path+".png") if !filename
    filename = pbTryString(path+".gif") if !filename
#    filename = pbTryString(path+".jpg") if !filename
#    filename = pbTryString(path+".jpeg") if !filename
#    filename = pbTryString(path+".bmp") if !filename
  }
  return filename
end

# Finds the real path for an image file.  This includes paths in encrypted
# archives.  Returns _x_ if the path can't be found.
def pbBitmapName(x)
  ret = pbResolveBitmap(x)
  return (ret) ? ret : x
end

def strsplit(str, re)
  ret = []
  tstr = str
  while re =~ tstr
    ret[ret.length] = $~.pre_match
    tstr = $~.post_match
  end
  ret[ret.length] = tstr if ret.length
  return ret
end

def canonicalize(c)
  csplit = strsplit(c, /[\/\\]/)
  pos = -1
  ret = []
  retstr = ""
  for x in csplit
    if x == ".."
      if pos >= 0
        ret.delete_at(pos)
        pos -= 1
      end
    elsif x != "."
      ret.push(x)
      pos += 1
    end
  end
  for i in 0...ret.length
    retstr += "/" if i > 0
    retstr += ret[i]
  end
  return retstr
end



module RTP
  @rtpPaths = nil

  def self.exists?(filename,extensions=[])
    return false if nil_or_empty?(filename)
    eachPathFor(filename) { |path|
      return true if safeExists?(path)
      for ext in extensions
        return true if safeExists?(path+ext)
      end
    }
    return false
  end

  def self.getImagePath(filename)
    return self.getPath(filename,["",".png",".gif"])   # ".jpg", ".jpeg", ".bmp"
  end

  def self.getAudioPath(filename)
    return self.getPath(filename,["",".mp3",".wav",".wma",".mid",".ogg",".midi"])
  end

  def self.getPath(filename,extensions=[])
    return filename if nil_or_empty?(filename)
    eachPathFor(filename) { |path|
      return path if safeExists?(path)
      for ext in extensions
        file = path+ext
        return file if safeExists?(file)
      end
    }
    return filename
  end

 # Gets the absolute RGSS paths for the given file name
  def self.eachPathFor(filename)
    return if !filename
    if filename[/^[A-Za-z]\:[\/\\]/] || filename[/^[\/\\]/]
      # filename is already absolute
      yield filename
    else
      # relative path
      RTP.eachPath { |path|
        if path=="./"
          yield filename
        else
          yield path+filename
        end
      }
    end
  end

  # Gets all RGSS search paths.
  # This function basically does nothing now, because
  # the passage of time and introduction of MKXP make
  # it useless, but leaving it for compatibility
  # reasons
  def self.eachPath
    # XXX: Use "." instead of Dir.pwd because of problems retrieving files if
    # the current directory contains an accent mark
    yield ".".gsub(/[\/\\]/,"/").gsub(/[\/\\]$/,"")+"/"
  end

  private

  def self.getSaveFileName(fileName)
    File.join(getSaveFolder, fileName)
  end

  def self.getSaveFolder
    # MKXP makes sure that this folder has been created
    # once it starts. The location differs depending on
    # the operating system:
    # Windows: %APPDATA%
    # Linux: $HOME/.local/share
    # macOS (unsandboxed): $HOME/Library/Application Support
    System.data_directory
  end
end



module FileTest
  Image_ext = ['.png', '.gif']   # '.jpg', '.jpeg', '.bmp',
  Audio_ext = ['.mp3', '.mid', '.midi', '.ogg', '.wav', '.wma']

  def self.audio_exist?(filename)
    return RTP.exists?(filename,Audio_ext)
  end

  def self.image_exist?(filename)
    return RTP.exists?(filename,Image_ext)
  end
end



# Used to determine whether a data file exists (rather than a graphics or
# audio file). Doesn't check RTP, but does check encrypted archives.

# Note: pbGetFileChar checks anything added in MKXP's RTP setting,
# and matching mount points added through System.mount
def pbRgssExists?(filename)
  if safeExists?("./Game.rgssad")
    return pbGetFileChar(filename)!=nil
  else
    filename = canonicalize(filename)
    return safeExists?(filename)
  end
end

# Opens an IO, even if the file is in an encrypted archive.
# Doesn't check RTP for the file.

# Note: load_data checks anything added in MKXP's RTP setting,
# and matching mount points added through System.mount
def pbRgssOpen(file,mode=nil)
  #File.open("debug.txt","ab") { |fw| fw.write([file,mode,Time.now.to_f].inspect+"\r\n") }
  if !safeExists?("./Game.rgssad")
    if block_given?
      File.open(file,mode) { |f| yield f }
      return nil
    else
      return File.open(file,mode)
    end
  end
  file = canonicalize(file)
  Marshal.neverload = true
  str = load_data(file, true)
  if block_given?
    StringInput.open(str) { |f| yield f }
    return nil
  else
    return StringInput.open(str)
  end
end

# Gets at least the first byte of a file. Doesn't check RTP, but does check
# encrypted archives.
def pbGetFileChar(file)
  canon_file = canonicalize(file)
  if !safeExists?("./Game.rgssad")
    return nil if !safeExists?(canon_file)
    return nil if file.last == '/'   # Is a directory
    begin
      File.open(canon_file, "rb") { |f| return f.read(1) }   # read one byte
    rescue Errno::ENOENT, Errno::EINVAL, Errno::EACCES, Errno::EISDIR
      return nil
    end
  end
  str = nil
  begin
    str = load_data(canon_file, true)
  rescue Errno::ENOENT, Errno::EINVAL, Errno::EACCES, Errno::EISDIR, RGSSError, MKXPError
    str = nil
  end
  return str
end

def pbTryString(x)
  ret = pbGetFileChar(x)
  return (ret!=nil && ret!="") ? x : nil
end

# Gets the contents of a file. Doesn't check RTP, but does check
# encrypted archives.

# Note: load_data will check anything added in MKXP's RTP setting,
# and matching mount points added through System.mount
def pbGetFileString(file)
  file = canonicalize(file)
  if !safeExists?("./Game.rgssad")
    return nil if !safeExists?(file)
    begin
      File.open(file,"rb") { |f| return f.read }   # read all data
    rescue Errno::ENOENT, Errno::EINVAL, Errno::EACCES
      return nil
    end
  end
  str = nil
  begin
    str = load_data(file, true)
  rescue Errno::ENOENT, Errno::EINVAL, Errno::EACCES, RGSSError, MKXPError
    str = nil
  end
  return str
end



#===============================================================================
#
#===============================================================================
class StringInput
  include Enumerable

  class << self
    def new( str )
      if block_given?
        begin
          f = super
          yield f
        ensure
          f.close if f
        end
      else
        super
      end
    end
    alias open new
  end

  def initialize( str )
    @string = str
    @pos = 0
    @closed = false
    @lineno = 0
  end

  attr_reader :lineno,:string

  def inspect
    return "#<#{self.class}:#{@closed ? 'closed' : 'open'},src=#{@string[0,30].inspect}>"
  end

  def close
    raise IOError, 'closed stream' if @closed
    @pos = nil
    @closed = true
  end

  def closed?; @closed; end

  def pos
    raise IOError, 'closed stream' if @closed
    [@pos, @string.size].min
  end

  alias tell pos

  def rewind; seek(0); end

  def pos=(value); seek(value); end

  def seek(offset, whence=IO::SEEK_SET)
    raise IOError, 'closed stream' if @closed
    case whence
    when IO::SEEK_SET then @pos = offset
    when IO::SEEK_CUR then @pos += offset
    when IO::SEEK_END then @pos = @string.size - offset
    else
      raise ArgumentError, "unknown seek flag: #{whence}"
    end
    @pos = 0 if @pos < 0
    @pos = [@pos, @string.size + 1].min
    offset
  end

  def eof?
    raise IOError, 'closed stream' if @closed
    @pos > @string.size
  end

  def each( &block )
    raise IOError, 'closed stream' if @closed
    begin
      @string.each(&block)
    ensure
      @pos = 0
    end
  end

  def gets
    raise IOError, 'closed stream' if @closed
    if idx = @string.index(?\n, @pos)
      idx += 1  # "\n".size
      line = @string[ @pos ... idx ]
      @pos = idx
      @pos += 1 if @pos == @string.size
    else
      line = @string[ @pos .. -1 ]
      @pos = @string.size + 1
    end
    @lineno += 1
    line
  end

  def getc
    raise IOError, 'closed stream' if @closed
    ch = @string[@pos]
    @pos += 1
    @pos += 1 if @pos == @string.size
    ch
  end

  def read( len = nil )
    raise IOError, 'closed stream' if @closed
    if !len
      return nil if eof?
      rest = @string[@pos ... @string.size]
      @pos = @string.size + 1
      return rest
    end
    str = @string[@pos, len]
    @pos += len
    @pos += 1 if @pos == @string.size
    str
  end

  def read_all; read(); end

  alias sysread read
end


#===============================================================================
# Script Page: FileMixins
#===============================================================================
module FileInputMixin
  def fgetb
    ret = 0
    each_byte do |i|
      ret = i || 0
      break
    end
    return ret
  end

  def fgetw
    x = 0
    ret = 0
    each_byte do |i|
      break if !i
      ret |= (i << x)
      x += 8
      break if x == 16
    end
    return ret
  end

  def fgetdw
    x = 0
    ret = 0
    each_byte do |i|
      break if !i
      ret |= (i << x)
      x += 8
      break if x == 32
    end
    return ret
  end

  def fgetsb
    ret = fgetb
    ret -= 256 if (ret & 0x80) != 0
    return ret
  end

  def xfgetb(offset)
    self.pos = offset
    return fgetb
  end

  def xfgetw(offset)
    self.pos = offset
    return fgetw
  end

  def xfgetdw(offset)
    self.pos = offset
    return fgetdw
  end

  def getOffset(index)
    self.binmode
    self.pos = 0
    offset = fgetdw >> 3
    return 0 if index >= offset
    self.pos = index * 8
    return fgetdw
  end

  def getLength(index)
    self.binmode
    self.pos = 0
    offset = fgetdw >> 3
    return 0 if index >= offset
    self.pos = index * 8 + 4
    return fgetdw
  end

  def readName(index)
    self.binmode
    self.pos = 0
    offset = fgetdw >> 3
    return "" if index >= offset
    self.pos = index << 3
    offset = fgetdw
    length = fgetdw
    return "" if length == 0
    self.pos = offset
    return read(length)
  end
end

module FileOutputMixin
  def fputb(b)
    b &= 0xFF
    write(b.chr)
  end

  def fputw(w)
    2.times do
      b = w & 0xFF
      write(b.chr)
      w >>= 8
    end
  end

  def fputdw(w)
    4.times do
      b = w & 0xFF
      write(b.chr)
      w >>= 8
    end
  end
end

class File < IO
=begin
  unless defined?(debugopen)
    class << self
      alias debugopen open
    end
  end

  def open(f, m = "r")
    debugopen("debug.txt", "ab") { |file| file.write([f, m, Time.now.to_f].inspect + "\r\n") }
    if block_given?
      debugopen(f, m) { |file| yield file }
    else
      return debugopen(f, m)
    end
  end
=end
  include FileInputMixin
  include FileOutputMixin
end

class StringInput
  include FileInputMixin

  def each_byte
    while !eof?
      yield getc
    end
  end

  def binmode; end
end

class StringOutput
  include FileOutputMixin
end


#===============================================================================
# Script Page: HTTP_Utilities
#===============================================================================
#############################
#
# HTTP utility functions
#
#############################
def pbPostData(url, postdata, filename=nil, depth=0)
  if url[/^http:\/\/([^\/]+)(.*)$/]
    host = $1
    path = $2
    path = "/" if path.length==0
    userAgent = "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.0.14) Gecko/2009082707 Firefox/3.0.14"
    body = postdata.map { |key, value|
      keyString   = key.to_s
      valueString = value.to_s
      keyString.gsub!(/[^a-zA-Z0-9_\.\-]/n) { |s| sprintf('%%%02x', s[0]) }
      valueString.gsub!(/[^a-zA-Z0-9_\.\-]/n) { |s| sprintf('%%%02x', s[0]) }
      next "#{keyString}=#{valueString}"
    }.join('&')
    ret = HTTPLite.post_body(
      url,
      body,
      "application/x-www-form-urlencoded",
      {
        "Host" => host, # might not be necessary
        "Proxy-Connection" => "Close",
        "Content-Length" => body.bytesize.to_s,
        "Pragma" => "no-cache",
        "User-Agent" => userAgent
      }
    ) rescue ""
    return ret if !ret.is_a?(Hash)
    return "" if ret[:status] != 200
    return ret[:body] if !filename
    File.open(filename, "wb"){|f|f.write(ret[:body])}
    return ""
  end
  return ""
end

def pbDownloadData(url, filename = nil, authorization = nil, depth = 0, &block)
  headers = {
    "Proxy-Connection" => "Close",
    "Pragma" => "no-cache",
    "User-Agent" => "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.9.0.14) Gecko/2009082707 Firefox/3.0.14"
  }
  headers["authorization"] = authorization if authorization
  ret = HTTPLite.get(url, headers) rescue ""
  return ret if !ret.is_a?(Hash)
  return "" if ret[:status] != 200
  return ret[:body] if !filename
  File.open(filename, "wb") { |f| f.write(ret[:body]) }
  return ""
end

def pbDownloadToString(url)
  begin
    data = pbDownloadData(url)
    return data
  rescue
    return ""
  end
end

def pbDownloadToFile(url, file)
  begin
    pbDownloadData(url,file)
  rescue
  end
end

def pbPostToString(url, postdata)
  begin
    data = pbPostData(url, postdata)
    return data
  rescue
    return ""
  end
end

def pbPostToFile(url, postdata, file)
  begin
    pbPostData(url, postdata,file)
  rescue
  end
end


#===============================================================================
# Script Page: ==================
#===============================================================================


#===============================================================================
# Script Page: EventSystem
#===============================================================================
#===============================================================================
# Defines an event that procedures can subscribe to.
#===============================================================================
class Event
    def initialize
      @callbacks = []
    end
  
    # Sets an event handler for this event and removes all other event handlers.
    def set(method)
      @callbacks.clear
      @callbacks.push(method)
    end
  
    # Removes an event handler procedure from the event.
    def -(method)
      for i in 0...@callbacks.length
        next if @callbacks[i]!=method
        @callbacks.delete_at(i)
        break
      end
      return self
    end
  
    # Adds an event handler procedure from the event.
    def +(method)
      for i in 0...@callbacks.length
        return self if @callbacks[i]==method
      end
      @callbacks.push(method)
      return self
    end
  
    # Clears the event of event handlers.
    def clear
      @callbacks.clear
    end
  
    # Triggers the event and calls all its event handlers.  Normally called only
    # by the code where the event occurred.
    # The first argument is the sender of the event, the second argument contains
    # the event's parameters. If three or more arguments are given, this method
    # supports the following callbacks:
    # proc { |sender,params| } where params is an array of the other parameters, and
    # proc { |sender,arg0,arg1,...| }
    def trigger(*arg)
      arglist = arg[1,arg.length]
      for callback in @callbacks
        if callback.arity>2 && arg.length==callback.arity
          # Retrofitted for callbacks that take three or more arguments
          callback.call(*arg)
        else
          callback.call(arg[0],arglist)
        end
      end
    end
  
    # Triggers the event and calls all its event handlers. Normally called only
    # by the code where the event occurred. The first argument is the sender of
    # the event, the other arguments are the event's parameters.
    def trigger2(*arg)
      for callback in @callbacks
        callback.call(*arg)
      end
    end
  end
  
  #===============================================================================
  #
  #===============================================================================
  class HandlerHash
    def initialize(mod)
      @mod         = mod
      @hash        = {}
      @addIfs      = []
      @symbolCache = {}
    end
  
    def fromSymbol(sym)
      return sym unless sym.is_a?(Symbol) || sym.is_a?(String)
      mod = Object.const_get(@mod) rescue nil
      return nil if !mod
      return mod.const_get(sym.to_sym) rescue nil
    end
  
    def toSymbol(sym)
      return sym.to_sym if sym.is_a?(Symbol) || sym.is_a?(String)
      ret = @symbolCache[sym]
      return ret if ret
      mod = Object.const_get(@mod) rescue nil
      return nil if !mod
      for key in mod.constants
        next if mod.const_get(key)!=sym
        ret = key.to_sym
        @symbolCache[sym] = ret
        break
      end
      return ret
    end
  
    def addIf(conditionProc,handler=nil,&handlerBlock)
      if ![Proc,Hash].include?(handler.class) && !block_given?
        raise ArgumentError, "addIf call for #{self.class.name} has no valid handler (#{handler.inspect} was given)"
      end
      @addIfs.push([conditionProc,handler || handlerBlock])
    end
  
    def add(sym,handler=nil,&handlerBlock) # 'sym' can be an ID or symbol
      if ![Proc,Hash].include?(handler.class) && !block_given?
        raise ArgumentError, "#{self.class.name} for #{sym.inspect} has no valid handler (#{handler.inspect} was given)"
      end
      id = fromSymbol(sym)
      @hash[id] = handler || handlerBlock if id
      symbol = toSymbol(sym)
      @hash[symbol] = handler || handlerBlock if symbol
    end
  
    def copy(src,*dests)
      handler = self[src]
      if handler
        for dest in dests
          self.add(dest,handler)
        end
      end
    end
  
    def [](sym)   # 'sym' can be an ID or symbol
      id = fromSymbol(sym)
      ret = nil
      ret = @hash[id] if id && @hash[id]   # Real ID from the item
      symbol = toSymbol(sym)
      ret = @hash[symbol] if symbol && @hash[symbol]   # Symbol or string
      unless ret
        for addif in @addIfs
          return addif[1] if addif[0].call(id)
        end
      end
      return ret
    end
  
    def trigger(sym,*args)
      handler = self[sym]
      return (handler) ? handler.call(fromSymbol(sym),*args) : nil
    end
  
    def clear
      @hash.clear
    end
  end
  
  #===============================================================================
  # A stripped-down version of class HandlerHash which only deals with symbols and
  # doesn't care about whether those symbols actually relate to a defined thing.
  #===============================================================================
  class HandlerHash2
    def initialize
      @hash    = {}
      @add_ifs = []
    end
  
    def [](sym)
      sym = sym.id if !sym.is_a?(Symbol) && sym.respond_to?("id")
      return @hash[sym] if sym && @hash[sym]
      for add_if in @add_ifs
        return add_if[1] if add_if[0].call(sym)
      end
      return nil
    end
  
    def addIf(conditionProc, handler = nil, &handlerBlock)
      if ![Proc, Hash].include?(handler.class) && !block_given?
        raise ArgumentError, "addIf call for #{self.class.name} has no valid handler (#{handler.inspect} was given)"
      end
      @add_ifs.push([conditionProc, handler || handlerBlock])
    end
  
    def add(sym, handler = nil, &handlerBlock)
      if ![Proc, Hash].include?(handler.class) && !block_given?
        raise ArgumentError, "#{self.class.name} for #{sym.inspect} has no valid handler (#{handler.inspect} was given)"
      end
      @hash[sym] = handler || handlerBlock if sym
    end
  
    def copy(src, *dests)
      handler = self[src]
      return if !handler
      for dest in dests
        self.add(dest, handler)
      end
    end
  
    def clear
      @hash.clear
    end
  
    def trigger(sym, *args)
      sym = sym.id if !sym.is_a?(Symbol) && sym.respond_to?("id")
      handler = self[sym]
      return (handler) ? handler.call(sym, *args) : nil
    end

    def hasKey?(key)
      return !self[key].nil?
    end
    
    def eachKey
        @hash.each { |key, value| yield key }
    end
  end
  
  #===============================================================================
  # An even more stripped down version of class HandlerHash which just takes
  # hashes with keys, no matter what the keys are.
  #===============================================================================
  class HandlerHashBasic
    def initialize
      @ordered_keys = []
      @hash         = {}
      @addIfs       = []
    end
  
    def [](entry)
      ret = nil
      ret = @hash[entry] if entry && @hash[entry]
      unless ret
        for addif in @addIfs
          return addif[1] if addif[0].call(entry)
        end
      end
      return ret
    end
  
    def each
      @ordered_keys.each { |key| yield key, @hash[key] }
    end
  
    def add(entry, handler = nil, &handlerBlock)
      if ![Proc,Hash].include?(handler.class) && !block_given?
        raise ArgumentError, "#{self.class.name} for #{entry.inspect} has no valid handler (#{handler.inspect} was given)"
      end
      return if !entry || (entry.is_a?(String) && entry.empty?)
      @ordered_keys.push(entry) if !@ordered_keys.include?(entry)
      @hash[entry] = handler || handlerBlock
    end
  
    def addIf(conditionProc, handler = nil, &handlerBlock)
      if ![Proc, Hash].include?(handler.class) && !block_given?
        raise ArgumentError, "addIf call for #{self.class.name} has no valid handler (#{handler.inspect} was given)"
      end
      @addIfs.push([conditionProc, handler || handlerBlock])
    end
  
    def copy(src, *dests)
      handler = self[src]
      return if !handler
      dests.each { |dest| self.add(dest, handler) }
    end
  
    def clear
      @hash.clear
      @ordered_keys.clear
    end
  
    def trigger(entry, *args)
      handler = self[entry]
      return (handler) ? handler.call(*args) : nil
    end
  end

#===============================================================================
# Script Page: ==================
#===============================================================================


#===============================================================================
# Script Page: [[ Save data ]]
#===============================================================================


#===============================================================================
# Script Page: SaveData
#===============================================================================
# The SaveData module is used to manipulate save data. It contains the {Value}s
# that make up the save data and {Conversion}s for resolving incompatibilities
# between Essentials and game versions.
# @see SaveData.register
# @see SaveData.register_conversion
module SaveData
  # Contains the file path of the save file.
  FILE_PATH = if File.directory?(System.data_directory)
                System.data_directory + '/Game.rxdata'
              else
                './Game.rxdata'
              end

  # @return [Boolean] whether the save file exists
  def self.exists?
    return File.file?(FILE_PATH)
  end

  # Fetches the save data from the given file.
  # Returns an Array in the case of a pre-v19 save file.
  # @param file_path [String] path of the file to load from
  # @return [Hash, Array] loaded save data
  # @raise [IOError, SystemCallError] if file opening fails
  def self.get_data_from_file(file_path)
    validate file_path => String
    save_data = nil
    File.open(file_path) do |file|
      data = Marshal.load(file)
      if data.is_a?(Hash)
        save_data = data
        next
      end
      save_data = [data]
      save_data << Marshal.load(file) until file.eof?
    end
    return save_data
  end

  # Fetches save data from the given file. If it needed converting, resaves it.
    # @param file_path [String] path of the file to read from
    # @return [Hash] save data in Hash format
    # @raise (see .get_data_from_file)
    def self.read_from_file(file_path,convert=false)
        validate file_path => String
        save_data = get_data_from_file(file_path)
        save_data = to_hash_format(save_data) if save_data.is_a?(Array)
        # Updating to a new version
        if convert && !save_data.empty? && PluginManager.compare_versions(save_data[:game_version], Settings::GAME_VERSION) < 0
            if run_conversions(save_data, file_path)
                File.open(file_path, 'wb') { |file| Marshal.dump(save_data, file) }
            end
            if removeIllegalElementsFromAllPokemon(save_data)
                File.open(file_path, 'wb') { |file| Marshal.dump(save_data, file) }
            end
        end
        return save_data
    end

  # Compiles the save data and saves a marshaled version of it into
  # the given file.
  # @param file_path [String] path of the file to save into
  # @raise [InvalidValueError] if an invalid value is being saved
  def self.save_to_file(file_path)
    validate file_path => String
    save_data = self.compile_save_hash
    File.open(file_path, 'wb') { |file| Marshal.dump(save_data, file) }
  end
  
  # Compiles the save data and saves a marshaled version of it into
    # the given file.
    # @param file_path [String] path of the file to save into
    # @raise [InvalidValueError] if an invalid value is being saved
    def self.save_backup(file_path)
        validate file_path => String
        save_data = self.compile_save_hash
        File.open(file_path + ".bak", 'wb') { |file| Marshal.dump(save_data, file) }
    end

  def self.delete_file(file = FILE_PATH)
        File.delete(file)
        File.delete(file + '.bak') if File.file?(file + '.bak')
  end

  # Converts the pre-v19 format data to the new format.
  # @param old_format [Array] pre-v19 format save data
  # @return [Hash] save data in new format
  def self.to_hash_format(old_format)
    validate old_format => Array
    hash = {}
    @values.each do |value|
      data = value.get_from_old_format(old_format)
      hash[value.id] = data unless data.nil?
    end
    return hash
  end

  def self.move_old_windows_save
        FileSave.dirv19
        FileSave.dirv18
    end
end


#===============================================================================
# Script Page: SaveData_Value
#===============================================================================
module SaveData
  # Contains Value objects for each save element.
  # Populated during runtime by SaveData.register calls.
  # @type [Array<Value>]
  @values = []

  # An error raised if an invalid save value is being saved or loaded.
  class InvalidValueError < RuntimeError; end

  #=============================================================================
  # Represents a single value in save data.
  # New values are added using {SaveData.register}.
  class Value
    # @return [Symbol] the value id
    attr_reader :id

    # @param id [Symbol] value id
    def initialize(id, &block)
      validate id => Symbol, block => Proc
      @id = id
      @loaded = false
      @load_in_bootup = false
      instance_eval(&block)
      raise "No save_value defined for save value #{id.inspect}" if @save_proc.nil?
      raise "No load_value defined for save value #{id.inspect}" if @load_proc.nil?
    end

    # @param value [Object] value to check
    # @return [Boolean] whether the given value is valid
    def valid?(value)
      return true if @ensured_class.nil?
      return value.is_a?(Object.const_get(@ensured_class))
    end

    # Calls the value's load proc with the given argument passed into it.
    # @param value [Object] load proc argument
    # @raise [InvalidValueError] if an invalid value is being loaded
    def load(value)
      validate_value(value)
      @load_proc.call(value)
      @loaded = true
    end

    # Calls the value's save proc and returns its value.
    # @return [Object] save proc value
    # @raise [InvalidValueError] if an invalid value is being saved
    def save
      value = @save_proc.call
      validate_value(value)
      return value
    end

    # @return [Boolean] whether the value has a new game value proc defined
    def has_new_game_proc?
      return @new_game_value_proc.is_a?(Proc)
    end

    # Calls the save value's load proc with the value fetched
    # from the defined new game value proc.
    # @raise (see #load)
    def load_new_game_value
      unless self.has_new_game_proc?
        raise "Save value #{@id.inspect} has no new_game_value defined"
      end
      self.load(@new_game_value_proc.call)
    end

    # @return [Boolean] whether the value should be loaded during bootup
    def load_in_bootup?
      return @load_in_bootup
    end

    # @return [Boolean] whether the value has been loaded
    def loaded?
      return @loaded
    end

    # Uses the {#from_old_format} proc to select the correct data from
    # +old_format+ and return it.
    # Returns nil if the proc is undefined.
    # @param old_format [Array] old format to load value from
    # @return [Object] data from the old format
    def get_from_old_format(old_format)
      return nil if @old_format_get_proc.nil?
      return @old_format_get_proc.call(old_format)
    end

    private

    # Raises an {InvalidValueError} if the given value is invalid.
    # @param value [Object] value to check
    # @raise [InvalidValueError] if the value is invalid
    def validate_value(value)
      return if self.valid?(value)
      raise InvalidValueError, "Save value #{@id.inspect} is not a #{@ensured_class} (#{value.class.name} given)"
    end

    # @!group Configuration

    # If present, ensures that the value is of the given class.
    # @param class_name [Symbol] class to enforce
    # @see SaveData.register
    def ensure_class(class_name)
      validate class_name => Symbol
      @ensured_class = class_name
    end

    # Defines how the loaded value is placed into a global variable.
    # Requires a block with the loaded value as its parameter.
    # @see SaveData.register
    def load_value(&block)
      raise ArgumentError, 'No block given to load_value' unless block_given?
      @load_proc = block
    end

    # Defines what is saved into save data. Requires a block.
    # @see SaveData.register
    def save_value(&block)
      raise ArgumentError, 'No block given to save_value' unless block_given?
      @save_proc = block
    end

    # If present, defines what the value is set to at the start of a new game.
    # @see SaveData.register
    def new_game_value(&block)
      raise ArgumentError, 'No block given to new_game_value' unless block_given?
      @new_game_value_proc = block
    end

    # If present, sets the value to be loaded during bootup.
    # @see SaveData.register
    def load_in_bootup
      @load_in_bootup = true
    end

    # If present, defines how the value should be fetched from the pre-v19
    # save format. Requires a block with the old format array as its parameter.
    # @see SaveData.register
    def from_old_format(&block)
      raise ArgumentError, 'No block given to from_old_format' unless block_given?
      @old_format_get_proc = block
    end

    # @!endgroup
  end

  #=============================================================================
  # Registers a {Value} to be saved into save data.
  # Takes a block which defines the value's saving ({Value#save_value})
  # and loading ({Value#load_value}) procedures.
  #
  # It is also possible to provide a proc for fetching the value
  # from the pre-v19 format ({Value#from_old_format}), define
  # a value to be set upon starting a new game with {Value#new_game_value}
  # and ensure that the saved and loaded value is of the correct
  # class with {Value#ensure_class}.
  #
  # Values can be registered to be loaded on bootup with
  # {Value#load_in_bootup}. If a new_game_value proc is defined, it
  # will be called when the game is launched for the first time,
  # or if the save data does not contain the value in question.
  #
  # @example Registering a new value
  #   SaveData.register(:foo) do
  #     ensure_class :Foo
  #     save_value { $foo }
  #     load_value { |value| $foo = value }
  #     new_game_value { Foo.new }
  #     from_old_format { |old_format| old_format[16] if old_format[16].is_a?(Foo) }
  #   end
  # @example Registering a value to be loaded on bootup
  #   SaveData.register(:bar) do
  #     load_in_bootup
  #     save_value { $bar }
  #     load_value { |value| $bar = value }
  #     new_game_value { Bar.new }
  #   end
  # @param id [Symbol] value id
  # @yieldself [Value]
  def self.register(id, &block)
    validate id => Symbol
    unless block_given?
      raise ArgumentError, 'No block given to SaveData.register'
    end
    @values << Value.new(id, &block)
  end

  # @param save_data [Hash] save data to validate
  # @return [Boolean] whether the given save data is valid
  def self.valid?(save_data)
    validate save_data => Hash
    return @values.all? { |value| value.valid?(save_data[value.id]) }
  end

  # Loads values from the given save data.
  # An optional condition can be passed.
  # @param save_data [Hash] save data to load from
  # @param condition_block [Proc] optional condition
  # @api private
  def self.load_values(save_data, &condition_block)
    @values.each do |value|
      next if block_given? && !condition_block.call(value)
      if save_data.has_key?(value.id)
        value.load(save_data[value.id])
      elsif value.has_new_game_proc?
        value.load_new_game_value
      end
    end
  end

  # Loads the values from the given save data by
  # calling each {Value} object's {Value#load_value} proc.
  # Values that are already loaded are skipped.
  # If a value does not exist in the save data and has
  # a {Value#new_game_value} proc defined, that value
  # is loaded instead.
  # @param save_data [Hash] save data to load
  # @raise [InvalidValueError] if an invalid value is being loaded
  def self.load_all_values(save_data)
    validate save_data => Hash
    load_values(save_data) { |value| !value.loaded? }
  end

  # Loads each value from the given save data that has
  # been set to be loaded during bootup. Done when a save file exists.
  # @param save_data [Hash] save data to load
  # @raise [InvalidValueError] if an invalid value is being loaded
  def self.load_bootup_values(save_data)
    validate save_data => Hash
    load_values(save_data) { |value| !value.loaded? && value.load_in_bootup? }
  end

  # Goes through each value with {Value#load_in_bootup} enabled and loads their
  # new game value, if one is defined. Done when no save file exists.
  def self.initialize_bootup_values
    @values.each do |value|
      next unless value.load_in_bootup?
      value.load_new_game_value if value.has_new_game_proc? && !value.loaded?
    end
  end

  # Loads each {Value}'s new game value, if one is defined. Done when starting a
  # new game.
  def self.load_new_game_values
    @values.each do |value|
      value.load_new_game_value if value.has_new_game_proc? && !value.loaded?
    end
  end

  # @return [Hash{Symbol => Object}] a hash representation of the save data
  # @raise [InvalidValueError] if an invalid value is being saved
  def self.compile_save_hash
    save_data = {}
    @values.each { |value| save_data[value.id] = value.save }
    return save_data
  end
  
  def self.changeFILEPATH(new = nil)
        return if new.nil?
        const_set(:FILE_PATH, new)
    end
end


#===============================================================================
# Script Page: SaveData_Conversion
#===============================================================================
module SaveData
  # Contains Conversion objects for each defined conversion:
  # {
  #   :essentials => {
  #     '19'    => [<Conversion>, ...],
  #     '19.1'  => [<Conversion>, ...],
  #     ...
  #   },
  #   :game => {
  #     '1.1.0' => [<Conversion>, ...],
  #     '1.2.0' => [<Conversion>, ...],
  #     ...
  #   }
  # }
  # Populated during runtime by SaveData.register_conversion calls.
  @conversions = {
    essentials: {},
    game: {}
  }

  #=============================================================================
  # Represents a conversion made to save data.
  # New conversions are added using {SaveData.register_conversion}.
  class Conversion
    # @return [Symbol] conversion ID
    attr_reader :id
    # @return [String] conversion title
    attr_reader :title
    # @return [Symbol] trigger type of the conversion (+:essentials+ or +:game+)
    attr_reader :trigger_type
    # @return [String] trigger version of the conversion
    attr_reader :version

    # @param id [String] conversion ID
    def initialize(id, &block)
      @id = id
      @value_procs = {}
      @all_proc = nil
      @title = "Running conversion #{@id}"
      @trigger_type = nil
      @version = nil
      instance_eval(&block)
      if @trigger_type.nil? || @version.nil?
        raise "Conversion #{@id} is missing a condition"
      end
    end

    # Returns whether the conversion should be run with the given version.
    # @param version [String] version to check
    # @return [Boolean] whether the conversion should be run
    def should_run?(version)
      return PluginManager.compare_versions(version, @version) < 0
    end

    # Runs the conversion on the given save data.
    # @param save_data [Hash]
    def run(save_data)
      @value_procs.each do |value_id, proc|
        unless save_data.has_key?(value_id)
          raise "Save data does not have value #{value_id.inspect}"
        end
        proc.call(save_data[value_id])
      end
      @all_proc.call(save_data) if @all_proc.is_a?(Proc)
    end

    # Runs the conversion on the given object.
    # @param object
    # @param key [Symbol]
    def run_single(object, key)
      @value_procs[key].call(object) if @value_procs[key].is_a?(Proc)
    end

    private

    # @!group Configuration

    # Sets the conversion's title.
    # @param new_title [String] conversion title
    # @note Since conversions are run before loading the player's chosen language,
    #   conversion titles can not be localized.
    # @see SaveData.register_conversion
    def display_title(new_title)
      validate new_title => String
      @title = new_title
    end

    # Sets the conversion to trigger for save files created below
    # the given Essentials version.
    # @param version [Numeric, String]
    # @see SaveData.register_conversion
    def essentials_version(version)
      validate version => [Numeric, String]
      raise "Multiple conditions in conversion #{@id}" unless @version.nil?
      @trigger_type = :essentials
      @version = version.to_s
    end

    # Sets the conversion to trigger for save files created below
    # the given game version.
    # @param version [Numeric, String]
    # @see SaveData.register_conversion
    def game_version(version)
      validate version => [Numeric, String]
      raise "Multiple conditions in conversion #{@id}" unless @version.nil?
      @trigger_type = :game
      @version = version.to_s
    end

    # Defines a conversion to the given save value.
    # @param value_id [Symbol] save value ID
    # @see SaveData.register_conversion
    def to_value(value_id, &block)
      validate value_id => Symbol
      raise ArgumentError, 'No block given to to_value' unless block_given?
      if @value_procs[value_id].is_a?(Proc)
        raise "Multiple to_value definitions in conversion #{@id} for #{value_id}"
      end
      @value_procs[value_id] = block
    end

    # Defines a conversion to the entire save data.
    # @see SaveData.register_conversion
    def to_all(&block)
      raise ArgumentError, 'No block given to to_all' unless block_given?
      if @all_proc.is_a?(Proc)
        raise "Multiple to_all definitions in conversion #{@id}"
      end
      @all_proc = block
    end

    # @!endgroup
  end

  #=============================================================================
  # Registers a {Conversion} to occur for save data that meets the given criteria.
  # Two types of criteria can be defined: {Conversion#essentials_version} and
  # {Conversion#game_version}. The conversion is automatically run on save data
  # that contains an older version number.
  #
  # A single value can be modified with {Conversion#to_value}. The entire save data
  # is accessed with {Conversion#to_all}, and a conversion title can be specified
  # with {Conversion#display_title}.
  # @example Registering a new conversion
  #   SaveData.register_conversion(:my_conversion) do
  #     game_version '1.1.0'
  #     display_title 'Converting some stuff'
  #     to_value :player do |player|
  #       # code that modifies the :player value
  #     end
  #     to_all do |save_data|
  #       save_data[:new_value] = Foo.new
  #     end
  #   end
  # @yield self [Conversion]
  def self.register_conversion(id, &block)
    validate id => Symbol
    unless block_given?
      raise ArgumentError, 'No block given to SaveData.register_conversion'
    end
    conversion = Conversion.new(id, &block)
    @conversions[conversion.trigger_type][conversion.version] ||= []
    @conversions[conversion.trigger_type][conversion.version] << conversion
  end

  # @param save_data [Hash] save data to get conversions for
  # @return [Array<Conversion>] all conversions that should be run on the data
  def self.get_conversions(save_data)
    conversions_to_run = []
    versions = {
      essentials: save_data[:essentials_version] || '18.1',
      game: save_data[:game_version] || '0.0.0'
    }
    [:essentials, :game].each do |trigger_type|
      # Ensure the versions are sorted from lowest to highest
      sorted_versions = @conversions[trigger_type].keys.sort do |v1, v2|
        PluginManager.compare_versions(v1, v2)
      end
      sorted_versions.each do |version|
        @conversions[trigger_type][version].each do |conversion|
          next unless conversion.should_run?(versions[trigger_type])
          conversions_to_run << conversion
        end
      end
    end
    return conversions_to_run
  end

  # Runs all possible conversions on the given save data.
  # Saves a backup before running conversions.
  # @param save_data [Hash] save data to run conversions on
  # @return [Boolean] whether conversions were run
  def self.run_conversions(save_data, filePath = nil)
        validate save_data => Hash
        conversions_to_run = self.get_conversions(save_data)
        return false if conversions_to_run.none?
        filePath = SaveData::FILE_PATH unless filePath
        File.open(filePath + '.bak', 'wb') { |f| Marshal.dump(save_data, f) }
            echoln "Running #{conversions_to_run.length} conversions..."
            conversions_to_run.each do |conversion|
            echo "#{conversion.title}..."
            conversion.run(save_data)
            echoln ' done.'
        end
        echoln '' if conversions_to_run.length > 0
        save_data[:essentials_version] = Essentials::VERSION
        save_data[:game_version] = Settings::GAME_VERSION
        return true
    end

  # Runs all possible conversions on the given object.
  # @param object [Hash] object to run conversions on
  # @param key [Hash] object's key in save data
  # @param save_data [Hash] save data to run conversions on
  def self.run_single_conversions(object, key, save_data)
    validate key => Symbol
    conversions_to_run = self.get_conversions(save_data)
    conversions_to_run.each do |conversion|
      conversion.run_single(object, key)
    end
  end
end


#===============================================================================
# Script Page: Game_SaveValues
#===============================================================================
# Contains the save values defined in Essentials by default.

SaveData.register(:player) do
  ensure_class :Player
  save_value { $Trainer }
  load_value { |value| $Trainer = value }
  new_game_value {
    trainer_type = nil   # Get the first defined trainer type as a placeholder
    GameData::TrainerType.each { |t| trainer_type = t.id; break }
    Player.new("Unnamed", trainer_type)
  }
  from_old_format { |old_format| old_format[0] }
end

SaveData.register(:frame_count) do
  ensure_class :Integer
  save_value { Graphics.frame_count }
  load_value { |value| Graphics.frame_count = value }
  new_game_value { 0 }
  from_old_format { |old_format| old_format[1] }
end

SaveData.register(:game_system) do
  load_in_bootup
  ensure_class :Game_System
  save_value { $game_system }
  load_value { |value| $game_system = value }
  new_game_value { Game_System.new }
  from_old_format { |old_format| old_format[2] }
end

SaveData.register(:pokemon_system) do
  load_in_bootup
  ensure_class :PokemonSystem
  save_value { $PokemonSystem }
  load_value { |value| $PokemonSystem = value }
  new_game_value { PokemonSystem.new }
  from_old_format { |old_format| old_format[3] }
end

SaveData.register(:switches) do
  ensure_class :Game_Switches
  save_value { $game_switches }
  load_value { |value| $game_switches = value }
  new_game_value { Game_Switches.new }
  from_old_format { |old_format| old_format[5] }
end

SaveData.register(:variables) do
  ensure_class :Game_Variables
  save_value { $game_variables }
  load_value { |value| $game_variables = value }
  new_game_value { Game_Variables.new }
  from_old_format { |old_format| old_format[6] }
end

SaveData.register(:self_switches) do
  ensure_class :Game_SelfSwitches
  save_value { $game_self_switches }
  load_value { |value| $game_self_switches = value }
  new_game_value { Game_SelfSwitches.new }
  from_old_format { |old_format| old_format[7] }
end

SaveData.register(:game_screen) do
  ensure_class :Game_Screen
  save_value { $game_screen }
  load_value { |value| $game_screen = value }
  new_game_value { Game_Screen.new }
  from_old_format { |old_format| old_format[8] }
end

SaveData.register(:map_factory) do
  ensure_class :PokemonMapFactory
  save_value { $MapFactory }
  load_value { |value| $MapFactory = value }
  from_old_format { |old_format| old_format[9] }
end

SaveData.register(:game_player) do
  ensure_class :Game_Player
  save_value { $game_player }
  load_value { |value| $game_player = value }
  new_game_value { Game_Player.new }
  from_old_format { |old_format| old_format[10] }
end

SaveData.register(:global_metadata) do
  ensure_class :PokemonGlobalMetadata
  save_value { $PokemonGlobal }
  load_value { |value| $PokemonGlobal = value }
  new_game_value { PokemonGlobalMetadata.new }
  from_old_format { |old_format| old_format[11] }
end

SaveData.register(:map_metadata) do
  ensure_class :PokemonMapMetadata
  save_value { $PokemonMap }
  load_value { |value| $PokemonMap = value }
  new_game_value { PokemonMapMetadata.new }
  from_old_format { |old_format| old_format[12] }
end

SaveData.register(:bag) do
  ensure_class :PokemonBag
  save_value { $PokemonBag }
  load_value { |value| $PokemonBag = value }
  new_game_value { PokemonBag.new }
  from_old_format { |old_format| old_format[13] }
end

SaveData.register(:storage_system) do
  ensure_class :PokemonStorage
  save_value { $PokemonStorage }
  load_value { |value| $PokemonStorage = value }
  new_game_value { PokemonStorage.new }
  from_old_format { |old_format| old_format[14] }
end

SaveData.register(:essentials_version) do
  load_in_bootup
  ensure_class :String
  save_value { Essentials::VERSION }
  load_value { |value| $SaveVersion = value }
  new_game_value { Essentials::VERSION }
  from_old_format { |old_format| old_format[15] }
end

SaveData.register(:game_version) do
  load_in_bootup
  ensure_class :String
  save_value { Settings::GAME_VERSION }
  load_value { |value| $game_version = value }
  new_game_value { Settings::GAME_VERSION }
end


#===============================================================================
# Script Page: Game_SaveConversions
#===============================================================================
# Contains conversions defined in Essentials by default.

SaveData.register_conversion(:v19_define_versions) do
  essentials_version 19
  display_title 'Adding game version and Essentials version to save data'
  to_all do |save_data|
    unless save_data.has_key?(:essentials_version)
      save_data[:essentials_version] = Essentials::VERSION
    end
    unless save_data.has_key?(:game_version)
      save_data[:game_version] = Settings::GAME_VERSION
    end
  end
end

SaveData.register_conversion(:v19_convert_PokemonSystem) do
  essentials_version 19
  display_title 'Updating PokemonSystem class'
  to_all do |save_data|
    new_system = PokemonSystem.new
    new_system.textspeed   = save_data[:pokemon_system].textspeed || new_system.textspeed
    new_system.battlescene = save_data[:pokemon_system].battlescene || new_system.battlescene
    new_system.battlestyle = save_data[:pokemon_system].battlestyle || new_system.battlestyle
    new_system.frame       = save_data[:pokemon_system].frame || new_system.frame
    new_system.textskin    = save_data[:pokemon_system].textskin || new_system.textskin
    new_system.screensize  = save_data[:pokemon_system].screensize || new_system.screensize
    new_system.language    = save_data[:pokemon_system].language || new_system.language
    new_system.runstyle    = save_data[:pokemon_system].runstyle || new_system.runstyle
    new_system.bgmvolume   = save_data[:pokemon_system].bgmvolume || new_system.bgmvolume
    new_system.sevolume    = save_data[:pokemon_system].sevolume || new_system.sevolume
    new_system.textinput   = save_data[:pokemon_system].textinput || new_system.textinput
    save_data[:pokemon_system] = new_system
  end
end

SaveData.register_conversion(:v19_convert_player) do
  essentials_version 19
  display_title 'Converting player trainer class'
  to_all do |save_data|
    next if save_data[:player].is_a?(Player)
    # Conversion of the party is handled in PokeBattle_Trainer.convert
    save_data[:player] = PokeBattle_Trainer.convert(save_data[:player])
  end
end

SaveData.register_conversion(:v19_move_global_data_to_player) do
  essentials_version 19
  display_title 'Moving some global metadata data to player'
  to_all do |save_data|
    global = save_data[:global_metadata]
    player = save_data[:player]
    player.character_ID = global.playerID
    global.playerID = nil
    global.pokedexUnlocked.each_with_index do |value, i|
      if value
        player.pokedex.unlock(i)
      else
        player.pokedex.lock(i)
      end
    end
    player.coins = global.coins
    global.coins = nil
    player.soot = global.sootsack
    global.sootsack = nil
    player.has_running_shoes = global.runningShoes
    global.runningShoes = nil
    player.seen_storage_creator = global.seenStorageCreator
    global.seenStorageCreator = nil
    player.has_snag_machine = global.snagMachine
    global.snagMachine = nil
    player.seen_purify_chamber = global.seenPurifyChamber
    global.seenPurifyChamber = nil
  end
end

SaveData.register_conversion(:v19_convert_global_metadata) do
  essentials_version 19
  display_title 'Adding encounter version variable to global metadata'
  to_value :global_metadata do |global|
    global.bridge ||= 0
    global.encounter_version ||= 0
    if global.pcItemStorage
      global.pcItemStorage.items.each_with_index do |slot, i|
        item_data = GameData::Item.try_get(slot[0])
        if item_data
          slot[0] = item_data.id
        else
          global.pcItemStorage.items[i] = nil
        end
      end
      global.pcItemStorage.items.compact!
    end
    if global.mailbox
      global.mailbox.each_with_index do |mail, i|
        global.mailbox[i] = PokemonMail.convert(mail) if mail
      end
    end
    global.phoneNumbers.each do |contact|
      contact[1] = GameData::TrainerType.get(contact[1]).id if contact && contact.length == 8
    end
    if global.partner
      global.partner[0] = GameData::TrainerType.get(global.partner[0]).id
      global.partner[3].each_with_index do |pkmn, i|
        global.partner[3][i] = PokeBattle_Pokemon.convert(pkmn) if pkmn
      end
    end
    if global.daycare
      global.daycare.each do |slot|
        slot[0] = PokeBattle_Pokemon.convert(slot[0]) if slot && slot[0]
      end
    end
    if global.roamPokemon
      global.roamPokemon.each_with_index do |pkmn, i|
        global.roamPokemon[i] = PokeBattle_Pokemon.convert(pkmn) if pkmn && pkmn != true
      end
    end
    global.purifyChamber.sets.each do |set|
      set.shadow = PokeBattle_Pokemon.convert(set.shadow) if set.shadow
      set.list.each_with_index do |pkmn, i|
        set.list[i] = PokeBattle_Pokemon.convert(pkmn) if pkmn
      end
    end
    if global.hallOfFame
      global.hallOfFame.each do |team|
        next if !team
        team.each_with_index do |pkmn, i|
          team[i] = PokeBattle_Pokemon.convert(pkmn) if pkmn
        end
      end
    end
    if global.triads
      global.triads.items.each do |card|
        card[0] = GameData::Species.get(card[0]).id if card && card[0] && card[0] != 0
      end
    end
  end
end

SaveData.register_conversion(:v19_1_fix_phone_contacts) do
  essentials_version 19.1
  display_title 'Fixing phone contacts data'
  to_value :global_metadata do |global|
    global.phoneNumbers.each do |contact|
      contact[1] = GameData::TrainerType.get(contact[1]).id if contact && contact.length == 8
    end
  end
end

SaveData.register_conversion(:v19_convert_bag) do
  essentials_version 19
  display_title 'Converting item IDs in Bag'
  to_value :bag do |bag|
    bag.instance_eval do
      for pocket in self.pockets
        pocket.each_with_index do |item, i|
          next if !item || !item[0] || item[0] == 0
          item_data = GameData::Item.try_get(item[0])
          if item_data
            item[0] = item_data.id
          else
            pocket[i] = nil
          end
        end
        pocket.compact!
      end
      self.registeredIndex   # Just to ensure this data exists
      self.registeredItems.each_with_index do |item, i|
        next if !item
        if item == 0
          self.registeredItems[i] = nil
        else
          item_data = GameData::Item.try_get(item)
          if item_data
            self.registeredItems[i] = item_data.id
          else
            self.registeredItems[i] = nil
          end
        end
      end
      self.registeredItems.compact!
    end   # bag.instance_eval
  end   # to_value
end

SaveData.register_conversion(:v19_convert_game_variables) do
  essentials_version 19
  display_title 'Converting classes of things in Game Variables'
  to_all do |save_data|
    variables = save_data[:variables]
    for i in 0..5000
      value = variables[i]
      next if value.nil?
      if value.is_a?(Array)
        value.each_with_index do |value2, j|
          if value2.is_a?(PokeBattle_Pokemon)
            value[j] = PokeBattle_Pokemon.convert(value2)
          end
        end
      elsif value.is_a?(PokeBattle_Pokemon)
        variables[i] = PokeBattle_Pokemon.convert(value)
      elsif value.is_a?(PokemonBag)
        SaveData.run_single_conversions(value, :bag, save_data)
      end
    end
  end
end

SaveData.register_conversion(:v19_convert_storage) do
  essentials_version 19
  display_title 'Converting classes of Pokémon in storage'
  to_value :storage_system do |storage|
    storage.instance_eval do
      for box in 0...self.maxBoxes
        for i in 0...self.maxPokemon(box)
          self[box, i] = PokeBattle_Pokemon.convert(self[box, i]) if self[box, i]
        end
      end
      self.unlockedWallpapers   # Just to ensure this data exists
    end   # storage.instance_eval
  end   # to_value
end

SaveData.register_conversion(:v19_convert_game_player) do
  essentials_version 19
  display_title 'Converting game player character'
  to_value :game_player do |game_player|
    game_player.width = 1
    game_player.height = 1
    game_player.sprite_size = [Game_Map::TILE_WIDTH, Game_Map::TILE_HEIGHT]
    game_player.pattern_surf ||= 0
    game_player.lock_pattern ||= false
    game_player.move_speed = game_player.move_speed
  end
end

SaveData.register_conversion(:v19_convert_game_screen) do
  essentials_version 19
  display_title 'Converting game screen'
  to_value :game_screen do |game_screen|
    game_screen.weather(game_screen.weather_type, game_screen.weather_max, 0)
  end
end


#===============================================================================
# Script Page: ==================
#===============================================================================


#===============================================================================
# Script Page: [[ Game classes ]]
#===============================================================================


#===============================================================================
# Script Page: Game_System
#===============================================================================
#==============================================================================
# ** Game_System
#------------------------------------------------------------------------------
#  This class handles data surrounding the system. Backround music, etc.
#  is managed here as well. Refer to "$game_system" for the instance of
#  this class.
#==============================================================================
class Game_System
  attr_reader   :map_interpreter          # map event interpreter
  attr_reader   :battle_interpreter       # battle event interpreter
  attr_accessor :timer                    # timer
  attr_accessor :timer_working            # timer working flag
  attr_accessor :save_disabled            # save forbidden
  attr_accessor :menu_disabled            # menu forbidden
  attr_accessor :encounter_disabled       # encounter forbidden
  attr_accessor :message_position         # text option: positioning
  attr_accessor :message_frame            # text option: window frame
  attr_accessor :save_count               # save count
  attr_accessor :magic_number             # magic number
  attr_accessor :autoscroll_x_speed
  attr_accessor :autoscroll_y_speed
  attr_accessor :bgm_position

  def initialize
    @map_interpreter    = Interpreter.new(0, true)
    @battle_interpreter = Interpreter.new(0, false)
    @timer              = 0
    @timer_working      = false
    @save_disabled      = false
    @menu_disabled      = false
    @encounter_disabled = false
    @message_position   = 2
    @message_frame      = 0
    @save_count         = 0
    @magic_number       = 0
    @autoscroll_x_speed = 0
    @autoscroll_y_speed = 0
    @bgm_position       = 0
    @bgs_position       = 0
  end

################################################################################

  def bgm_play(bgm)
    old_pos = @bgm_position
    @bgm_position = 0
    bgm_play_internal(bgm,0)
    @bgm_position = old_pos
  end

  def bgm_play_internal2(name,volume,pitch,position) # :nodoc:
    vol = volume
    vol *= $PokemonSystem.bgmvolume/100.0
    vol = vol.to_i
    begin
      Audio.bgm_play(name,vol,pitch,position)
    rescue ArgumentError
      Audio.bgm_play(name,vol,pitch)
    end
  end

  def bgm_play_internal(bgm,position) # :nodoc:
    @bgm_position = position if !@bgm_paused
    @playing_bgm = (bgm==nil) ? nil : bgm.clone
    if bgm!=nil && bgm.name!=""
      if FileTest.audio_exist?("Audio/BGM/"+bgm.name)
        bgm_play_internal2("Audio/BGM/"+bgm.name,
           bgm.volume,bgm.pitch,@bgm_position) if !@defaultBGM
      end
    else
      @bgm_position = position if !@bgm_paused
      @playing_bgm = nil
      Audio.bgm_stop if !@defaultBGM
    end
    if @defaultBGM
      bgm_play_internal2("Audio/BGM/"+@defaultBGM.name,
         @defaultBGM.volume,@defaultBGM.pitch,@bgm_position)
    end
    Graphics.frame_reset
  end

  def bgm_pause(fadetime=0.0) # :nodoc:
    pos = Audio.bgm_pos rescue 0
    self.bgm_fade(fadetime) if fadetime>0.0
    @bgm_position = pos
    @bgm_paused   = true
  end

  def bgm_unpause  # :nodoc:
    @bgm_position = 0
    @bgm_paused   = false
  end

  def bgm_resume(bgm) # :nodoc:
    if @bgm_paused
      self.bgm_play_internal(bgm,@bgm_position)
      @bgm_position = 0
      @bgm_paused   = false
    end
  end

  def bgm_stop # :nodoc:
    @bgm_position = 0 if !@bgm_paused
    @playing_bgm  = nil
    Audio.bgm_stop if !@defaultBGM
  end

  def bgm_fade(time) # :nodoc:
    @bgm_position = 0 if !@bgm_paused
    @playing_bgm = nil
    Audio.bgm_fade((time*1000).floor) if !@defaultBGM
  end

  def playing_bgm
    return @playing_bgm
  end

  # Saves the currently playing background music for later playback.
  def bgm_memorize
    @memorized_bgm = @playing_bgm
  end

  # Plays the currently memorized background music
  def bgm_restore
    bgm_play(@memorized_bgm)
  end

  # Returns an RPG::AudioFile object for the currently playing background music
  def getPlayingBGM
    return (@playing_bgm) ? @playing_bgm.clone : nil
  end

  def setDefaultBGM(bgm,volume=80,pitch=100)
    bgm = RPG::AudioFile.new(bgm,volume,pitch) if bgm.is_a?(String)
    if bgm!=nil && bgm.name!=""
      @defaultBGM = nil
      self.bgm_play(bgm)
      @defaultBGM = bgm.clone
    else
      @defaultBGM = nil
      self.bgm_play(@playing_bgm)
    end
  end

################################################################################

  def me_play(me)
    me = RPG::AudioFile.new(me) if me.is_a?(String)
    if me!=nil && me.name!=""
      if FileTest.audio_exist?("Audio/ME/"+me.name)
        vol = me.volume
        vol *= $PokemonSystem.bgmvolume/100.0
        vol = vol.to_i
        Audio.me_play("Audio/ME/"+me.name,vol,me.pitch)
      end
    else
      Audio.me_stop
    end
    Graphics.frame_reset
  end

################################################################################

  def bgs_play(bgs)
    @playing_bgs = (bgs==nil) ? nil : bgs.clone
    if bgs!=nil && bgs.name!=""
      if FileTest.audio_exist?("Audio/BGS/"+bgs.name)
        vol = bgs.volume
        vol *= $PokemonSystem.sevolume/100.0
        vol = vol.to_i
        Audio.bgs_play("Audio/BGS/"+bgs.name,vol,bgs.pitch)
      end
    else
      @bgs_position = 0
      @playing_bgs  = nil
      Audio.bgs_stop
    end
    Graphics.frame_reset
  end

  def bgs_pause(fadetime=0.0) # :nodoc:
    if fadetime>0.0
      self.bgs_fade(fadetime)
    else
      self.bgs_stop
    end
    @bgs_paused = true
  end

  def bgs_unpause  # :nodoc:
    @bgs_paused = false
  end

  def bgs_resume(bgs) # :nodoc:
    if @bgs_paused
      self.bgs_play(bgs)
      @bgs_paused = false
    end
  end

  def bgs_stop
    @bgs_position = 0
    @playing_bgs  = nil
    Audio.bgs_stop
  end

  def bgs_fade(time)
    @bgs_position = 0
    @playing_bgs  = nil
    Audio.bgs_fade((time*1000).floor)
  end

  def playing_bgs
    return @playing_bgs
  end

  def bgs_memorize
    @memorized_bgs = @playing_bgs
  end

  def bgs_restore
    bgs_play(@memorized_bgs)
  end

  def getPlayingBGS
    return (@playing_bgs) ? @playing_bgs.clone : nil
  end

################################################################################

  def se_play(se)
    se = RPG::AudioFile.new(se) if se.is_a?(String)
    if se!=nil && se.name!="" && FileTest.audio_exist?("Audio/SE/"+se.name)
      vol = se.volume
      vol *= $PokemonSystem.sevolume/100.0
      vol = vol.to_i
      Audio.se_play("Audio/SE/"+se.name,vol,se.pitch)
    end
  end

  def se_stop
    Audio.se_stop
  end

################################################################################

  def battle_bgm
    return (@battle_bgm) ? @battle_bgm : $data_system.battle_bgm
  end

  def battle_bgm=(battle_bgm)
    @battle_bgm = battle_bgm
  end

  def battle_end_me
    return (@battle_end_me) ? @battle_end_me : $data_system.battle_end_me
  end

  def battle_end_me=(battle_end_me)
    @battle_end_me = battle_end_me
  end

################################################################################

  def windowskin_name
    if @windowskin_name==nil
      return $data_system.windowskin_name
    else
      return @windowskin_name
    end
  end

  def windowskin_name=(windowskin_name)
    @windowskin_name = windowskin_name
  end

  def update
    @timer -= 1 if @timer_working && @timer>0
    if Input.trigger?(Input::SPECIAL) && pbCurrentEventCommentInput(1,"Cut Scene")
      event = @map_interpreter.get_character(0)
      @map_interpreter.pbSetSelfSwitch(event.id,"A",true)
      @map_interpreter.command_end
      event.start
    end
  end
end


#===============================================================================
# Script Page: Game_Picture
#===============================================================================
#===============================================================================
# ** Game_Picture
#-------------------------------------------------------------------------------
#  This class handles the picture. It's used within the Game_Screen class
#  ($game_screen).
#===============================================================================

class Game_Picture
  #-----------------------------------------------------------------------------
  # * Public Instance Variables
  #-----------------------------------------------------------------------------
  attr_reader   :number                   # picture number
  attr_reader   :name                     # file name
  attr_reader   :origin                   # starting point
  attr_reader   :x                        # x-coordinate
  attr_reader   :y                        # y-coordinate
  attr_reader   :zoom_x                   # x directional zoom rate
  attr_reader   :zoom_y                   # y directional zoom rate
  attr_reader   :opacity                  # opacity level
  attr_reader   :blend_type               # blend method
  attr_reader   :tone                     # color tone
  attr_reader   :angle                    # rotation angle
  #-----------------------------------------------------------------------------
  # * Object Initialization
  #     number : picture number
  #-----------------------------------------------------------------------------
  def initialize(number)
    @number = number
    @name = ""
    @origin = 0
    @x = 0.0
    @y = 0.0
    @zoom_x = 100.0
    @zoom_y = 100.0
    @opacity = 255.0
    @blend_type = 1
    @duration = 0
    @target_x = @x
    @target_y = @y
    @target_zoom_x = @zoom_x
    @target_zoom_y = @zoom_y
    @target_opacity = @opacity
    @tone = Tone.new(0, 0, 0, 0)
    @tone_target = Tone.new(0, 0, 0, 0)
    @tone_duration = 0
    @angle = 0
    @rotate_speed = 0
  end
  #-----------------------------------------------------------------------------
  # * Show Picture
  #     name       : file name
  #     origin     : starting point
  #     x          : x-coordinate
  #     y          : y-coordinate
  #     zoom_x     : x directional zoom rate
  #     zoom_y     : y directional zoom rate
  #     opacity    : opacity level
  #     blend_type : blend method
  #-----------------------------------------------------------------------------
  def show(name, origin, x, y, zoom_x, zoom_y, opacity, blend_type)
    @name = name
    @origin = origin
    @x = x.to_f
    @y = y.to_f
    @zoom_x = zoom_x.to_f
    @zoom_y = zoom_y.to_f
    @opacity = opacity.to_f
    @blend_type = blend_type ? blend_type : 0
    @duration = 0
    @target_x = @x
    @target_y = @y
    @target_zoom_x = @zoom_x
    @target_zoom_y = @zoom_y
    @target_opacity = @opacity
    @tone = Tone.new(0, 0, 0, 0)
    @tone_target = Tone.new(0, 0, 0, 0)
    @tone_duration = 0
    @angle = 0
    @rotate_speed = 0
  end
  #-----------------------------------------------------------------------------
  # * Move Picture
  #     duration   : time
  #     origin     : starting point
  #     x          : x-coordinate
  #     y          : y-coordinate
  #     zoom_x     : x directional zoom rate
  #     zoom_y     : y directional zoom rate
  #     opacity    : opacity level
  #     blend_type : blend method
  #-----------------------------------------------------------------------------
  def move(duration, origin, x, y, zoom_x, zoom_y, opacity, blend_type)
    @duration       = duration
    @origin         = origin
    @target_x       = x.to_f
    @target_y       = y.to_f
    @target_zoom_x  = zoom_x.to_f
    @target_zoom_y  = zoom_y.to_f
    @target_opacity = opacity.to_f
    @blend_type     = blend_type ? blend_type : 0
  end
  #-----------------------------------------------------------------------------
  # * Change Rotation Speed
  #     speed : rotation speed
  #-----------------------------------------------------------------------------
  def rotate(speed)
    @rotate_speed = speed
  end
  #-----------------------------------------------------------------------------
  # * Start Change of Color Tone
  #     tone     : color tone
  #     duration : time
  #-----------------------------------------------------------------------------
  def start_tone_change(tone, duration)
    @tone_target = tone.clone
    @tone_duration = duration
    if @tone_duration == 0
      @tone = @tone_target.clone
    end
  end
  #-----------------------------------------------------------------------------
  # * Erase Picture
  #-----------------------------------------------------------------------------
  def erase
    @name = ""
  end
  #-----------------------------------------------------------------------------
  # * Frame Update
  #-----------------------------------------------------------------------------
  def update
    if @duration >= 1
      d = @duration
      @x = (@x * (d - 1) + @target_x) / d
      @y = (@y * (d - 1) + @target_y) / d
      @zoom_x = (@zoom_x * (d - 1) + @target_zoom_x) / d
      @zoom_y = (@zoom_y * (d - 1) + @target_zoom_y) / d
      @opacity = (@opacity * (d - 1) + @target_opacity) / d
      @duration -= 1
    end
    if @tone_duration >= 1
      d = @tone_duration
      @tone.red = (@tone.red * (d - 1) + @tone_target.red) / d
      @tone.green = (@tone.green * (d - 1) + @tone_target.green) / d
      @tone.blue = (@tone.blue * (d - 1) + @tone_target.blue) / d
      @tone.gray = (@tone.gray * (d - 1) + @tone_target.gray) / d
      @tone_duration -= 1
    end
    if @rotate_speed != 0
      @angle += @rotate_speed / 2.0
      while @angle < 0
        @angle += 360
      end
      @angle %= 360
    end
  end
end


#===============================================================================
# Script Page: Game_MapFactory
#===============================================================================
#===============================================================================
# Map Factory (allows multiple maps to be loaded at once and connected)
#===============================================================================
class PokemonMapFactory
  attr_reader :maps

  def initialize(id)
    @maps       = []
    @fixup      = false
    @mapChanged = false   # transient instance variable
    setup(id)
  end

  # Clears all maps and sets up the current map with id. This function also sets
  # the positions of neighboring maps and notifies the game system of a map
  # change.
  def setup(id)
    @maps.clear
    @maps[0] = Game_Map.new
    @mapIndex = 0
    oldID = ($game_map) ? $game_map.map_id : 0
    setMapChanging(id,@maps[0]) if oldID!=0 && oldID!=@maps[0].map_id
    $game_map = @maps[0]
    @maps[0].setup(id)
    setMapsInRange
    setMapChanged(oldID)
  end

  def map
    @mapIndex = 0 if !@mapIndex || @mapIndex<0
    return @maps[@mapIndex] if @maps[@mapIndex]
    raise "No maps in save file... (mapIndex=#{@mapIndex})" if @maps.length==0
    if @maps[0]
      echoln("Using next map, may be incorrect (mapIndex=#{@mapIndex}, length=#{@maps.length})")
      return @maps[0]
    end
    raise "No maps in save file... (all maps empty; mapIndex=#{@mapIndex})"
  end

  def hasMap?(id)
    for map in @maps
      return true if map.map_id==id
    end
    return false
  end

  def getMapIndex(id)
    for i in 0...@maps.length
      return i if @maps[i].map_id==id
    end
    return -1
  end

  def getMap(id,add=true)
    for map in @maps
      return map if map.map_id==id
    end
    map = Game_Map.new
    map.setup(id)
    @maps.push(map) if add
    return map
  end

  def getMapNoAdd(id)
    return getMap(id,false)
  end

  def getNewMap(playerX,playerY)
    id = $game_map.map_id
    conns = MapFactoryHelper.getMapConnections
    if conns[id]
      for conn in conns[id]
        mapidB = nil
        newx = 0
        newy = 0
        if conn[0] == id
          mapidB = conn[3]
          mapB = MapFactoryHelper.getMapDims(conn[3])
          newx = conn[4] - conn[1] + playerX
          newy = conn[5] - conn[2] + playerY
        else
          mapidB = conn[0]
          mapB = MapFactoryHelper.getMapDims(conn[0])
          newx = conn[1] - conn[4] + playerX
          newy = conn[2] - conn[5] + playerY
        end
        if newx >= 0 && newx < mapB[0] && newy >= 0 && newy < mapB[1]
          return [getMap(mapidB), newx, newy]
        end
      end
    end
    return nil
  end

  # Detects whether the player has moved onto a connected map, and if so, causes
  # their transfer to that map.
  def setCurrentMap
    return if $game_player.moving?
    return if $game_map.valid?($game_player.x,$game_player.y)
    newmap = getNewMap($game_player.x,$game_player.y)
    return if !newmap
    oldmap=$game_map.map_id
    if oldmap!=0 && oldmap!=newmap[0].map_id
      setMapChanging(newmap[0].map_id,newmap[0])
    end
    $game_map = newmap[0]
    @mapIndex = getMapIndex($game_map.map_id)
    $game_player.moveto(newmap[1],newmap[2])
    $game_map.update
    pbAutoplayOnTransition
    $game_map.refresh
    setMapChanged(oldmap)
    $game_screen.weather_duration = 20
  end

  def setMapsInRange
    return if @fixup
    @fixup = true
    id = $game_map.map_id
    conns = MapFactoryHelper.getMapConnections
    if conns[id]
      for conn in conns[id]
        if conn[0] == id
          mapA = getMap(conn[0])
          newdispx = (conn[4] - conn[1]) * Game_Map::REAL_RES_X + mapA.display_x
          newdispy = (conn[5] - conn[2]) * Game_Map::REAL_RES_Y + mapA.display_y
          if hasMap?(conn[3]) || MapFactoryHelper.mapInRangeById?(conn[3], newdispx, newdispy)
            mapB = getMap(conn[3])
            mapB.display_x = newdispx if mapB.display_x != newdispx
            mapB.display_y = newdispy if mapB.display_y != newdispy
          end
        else
          mapA = getMap(conn[3])
          newdispx = (conn[1] - conn[4]) * Game_Map::REAL_RES_X + mapA.display_x
          newdispy = (conn[2] - conn[5]) * Game_Map::REAL_RES_Y + mapA.display_y
          if hasMap?(conn[0]) || MapFactoryHelper.mapInRangeById?(conn[0], newdispx, newdispy)
            mapB = getMap(conn[0])
            mapB.display_x = newdispx if mapB.display_x != newdispx
            mapB.display_y = newdispy if mapB.display_y != newdispy
          end
        end
      end
    end
    @fixup = false
  end

  def setMapChanging(newID,newMap)
    Events.onMapChanging.trigger(self,newID,newMap)
  end

  def setMapChanged(prevMap)
    Events.onMapChange.trigger(self,prevMap)
    @mapChanged = true
  end

  def setSceneStarted(scene)
    Events.onMapSceneChange.trigger(self,scene,@mapChanged)
    @mapChanged = false
  end

  # Similar to Game_Player#passable?, but supports map connections
  def isPassableFromEdge?(x, y)
    return true if $game_map.valid?(x, y)
    newmap = getNewMap(x, y)
    return false if !newmap
    return isPassable?(newmap[0].map_id, newmap[1], newmap[2])
  end

  def isPassable?(mapID, x, y, thisEvent = nil)
    thisEvent = $game_player if !thisEvent
    map = getMapNoAdd(mapID)
    return false if !map
    return false if !map.valid?(x, y)
    return true if thisEvent.through
    # Check passability of tile
    if thisEvent.is_a?(Game_Player)
      return false unless ($DEBUG && Input.press?(Input::CTRL)) ||
         map.passable?(x, y, 0, thisEvent)
    else
      return false unless map.passable?(x, y, 0, thisEvent)
    end
    # Check passability of event(s) in that spot
    for event in map.events.values
      next if event == thisEvent || !event.at_coordinate?(x, y)
      return false if !event.through && event.character_name != ""
    end
    # Check passability of player
    if !thisEvent.is_a?(Game_Player)
      if $game_map.map_id == mapID && $game_player.x == x && $game_player.y == y
        return false if !$game_player.through && $game_player.character_name != ""
      end
    end
    return true
  end

  # Only used by dependent events
  def isPassableStrict?(mapID,x,y,thisEvent=nil)
    thisEvent = $game_player if !thisEvent
    map = getMapNoAdd(mapID)
    return false if !map
    return false if !map.valid?(x,y)
    return true if thisEvent.through
    if thisEvent==$game_player
      if !($DEBUG && Input.press?(Input::CTRL))
        return false if !map.passableStrict?(x,y,0,thisEvent)
      end
    else
      return false if !map.passableStrict?(x,y,0,thisEvent)
    end
    for event in map.events.values
      next if event == thisEvent || !event.at_coordinate?(x, y)
      return false if !event.through && event.character_name!=""
    end
    return true
  end

  def getTerrainTag(mapid,x,y,countBridge=false)
      map = getMapNoAdd(mapid)
      return map.terrain_tag(x,y,countBridge)
  end

  # NOTE: Assumes the event is 1x1 tile in size. Only returns one terrain tag.
  def getFacingTerrainTag(dir=nil,event=nil)
    tile = getFacingTile(dir,event)
    return GameData::TerrainTag.get(:None) if !tile
    return getTerrainTag(tile[0],tile[1],tile[2])
  end

  def getTerrainTagFromCoords(mapid,x,y,countBridge=false)
    tile = getRealTilePos(mapid,x,y)
    return GameData::TerrainTag.get(:None) if !tile
    return getTerrainTag(tile[0],tile[1],tile[2])
  end

  def areConnected?(mapID1, mapID2)
    return true if mapID1 == mapID2
    conns = MapFactoryHelper.getMapConnections
    if conns[mapID1]
      for conn in conns[mapID1]
        return true if conn[0] == mapID2 || conn[3] == mapID2
      end
    end
    return false
  end

  def getRelativePos(thisMapID, thisX, thisY, otherMapID, otherX, otherY)
    if thisMapID == otherMapID   # Both events share the same map
      return [otherX - thisX, otherY - thisY]
    end
    conns = MapFactoryHelper.getMapConnections
    if conns[thisMapID]
      for conn in conns[thisMapID]
        if conn[0] == otherMapID
          posX = thisX + conn[1] - conn[4] + otherX
          posY = thisY + conn[2] - conn[5] + otherY
          return [posX, posY]
        elsif conn[1] == otherMapID
          posX = thisX + conn[4] - conn[1] + otherX
          posY = thisY + conn[5] - conn[2] + otherY
          return [posX, posY]
        end
      end
    end
    return [0, 0]
  end

  # Gets the distance from this event to another event.  Example: If this event's
  # coordinates are (2,5) and the other event's coordinates are (5,1), returns
  # the array (3,-4), because (5-2=3) and (1-5=-4).
  def getThisAndOtherEventRelativePos(thisEvent,otherEvent)
    return [0,0] if !thisEvent || !otherEvent
    return getRelativePos(
       thisEvent.map.map_id,thisEvent.x,thisEvent.y,
       otherEvent.map.map_id,otherEvent.x,otherEvent.y)
  end

  def getThisAndOtherPosRelativePos(thisEvent,otherMapID,otherX,otherY)
    return [0,0] if !thisEvent
    return getRelativePos(
       thisEvent.map.map_id,thisEvent.x,thisEvent.y,otherMapID,otherX,otherY)
  end

  # Unused
  def getOffsetEventPos(event,xOffset,yOffset)
    event = $game_player if !event
    return nil if !event
    return getRealTilePos(event.map.map_id,event.x+xOffset,event.y+yOffset)
  end

  # NOTE: Assumes the event is 1x1 tile in size. Only returns one tile.
  def getFacingTile(direction=nil,event=nil,steps=1)
    event = $game_player if event==nil
    return [0,0,0] if !event
    x = event.x
    y = event.y
    id = event.map.map_id
    direction = event.direction if direction==nil
    return getFacingTileFromPos(id,x,y,direction,steps)
  end

  def getFacingTileFromPos(mapID,x,y,direction=0,steps=1)
    id = mapID
    case direction
    when 1
      x -= steps
      y += steps
    when 2
      y += steps
    when 3
      x += steps
      y += steps
    when 4
      x -= steps
    when 6
      x += steps
    when 7
      x -= steps
      y -= steps
    when 8
      y -= steps
    when 9
      x += steps
      y -= steps
    else
      return [id,x,y]
    end
    return getRealTilePos(mapID,x,y)
  end

  def getRealTilePos(mapID, x, y)
    id = mapID
    return [id, x, y] if getMapNoAdd(id).valid?(x, y)
    conns = MapFactoryHelper.getMapConnections
    if conns[id]
      for conn in conns[id]
        if conn[0] == id
          newX = x + conn[4] - conn[1]
          newY = y + conn[5] - conn[2]
          next if newX < 0 || newY < 0
          dims = MapFactoryHelper.getMapDims(conn[3])
          next if newX >= dims[0] || newY >= dims[1]
          return [conn[3], newX, newY]
        else
          newX = x + conn[1] - conn[4]
          newY = y + conn[2] - conn[5]
          next if newX < 0 || newY < 0
          dims = MapFactoryHelper.getMapDims(conn[0])
          next if newX >= dims[0] || newY >= dims[1]
          return [conn[0], newX, newY]
        end
      end
    end
    return nil
  end

  def getFacingCoords(x,y,direction=0,steps=1)
    case direction
    when 1
      x -= steps
      y += steps
    when 2
      y += steps
    when 3
      x += steps
      y += steps
    when 4
      x -= steps
    when 6
      x += steps
    when 7
      x -= steps
      y -= steps
    when 8
      y -= steps
    when 9
      x += steps
      y -= steps
    end
    return [x,y]
  end

  def updateMaps(scene)
    updateMapsInternal
    $MapFactory.setSceneStarted(scene) if @mapChanged
  end

  def updateMapsInternal
    return if $game_player.moving?
    if !MapFactoryHelper.hasConnections?($game_map.map_id)
      return if @maps.length==1
      for i in 0...@maps.length
        @maps[i] = nil if $game_map.map_id!=@maps[i].map_id
      end
      @maps.compact!
      @mapIndex = getMapIndex($game_map.map_id)
      return
    end
    setMapsInRange
    deleted = false
    for i in 0...@maps.length
      next if MapFactoryHelper.mapInRange?(@maps[i])
      @maps[i] = nil
      deleted = true
    end
    if deleted
      @maps.compact!
      @mapIndex = getMapIndex($game_map.map_id)
    end
  end
end

#===============================================================================
# Map Factory Helper (stores map connection and size data and calculations
# involving them)
#===============================================================================
module MapFactoryHelper
  @@MapConnections = nil
  @@MapDims        = nil

  def self.clear
    @@MapConnections = nil
    @@MapDims        = nil
  end

  def self.getMapConnections
    if !@@MapConnections
      @@MapConnections = []
      conns = load_data("Data/map_connections.dat")
      conns.each do |conn|
        # Ensure both maps in a connection are valid
        dimensions = getMapDims(conn[0])
        next if dimensions[0] == 0 || dimensions[1] == 0
        dimensions = getMapDims(conn[3])
        next if dimensions[0] == 0 || dimensions[1] == 0
        # Convert first map's edge and coordinate to pair of coordinates
        edge = getMapEdge(conn[0], conn[1])
        case conn[1]
        when "N", "S"
          conn[1] = conn[2]
          conn[2] = edge
        when "E", "W"
          conn[1] = edge
        end
        # Convert second map's edge and coordinate to pair of coordinates
        edge = getMapEdge(conn[3], conn[4])
        case conn[4]
        when "N", "S"
          conn[4] = conn[5]
          conn[5] = edge
        when "E", "W"
          conn[4] = edge
        end
        # Add connection to arrays for both maps
        @@MapConnections[conn[0]] = [] if !@@MapConnections[conn[0]]
        @@MapConnections[conn[0]].push(conn)
        @@MapConnections[conn[3]] = [] if !@@MapConnections[conn[3]]
        @@MapConnections[conn[3]].push(conn)
      end
    end
    return @@MapConnections
  end

  def self.hasConnections?(id)
    conns = MapFactoryHelper.getMapConnections
    return conns[id] ? true : false
  end

  # Gets the height and width of the map with id
  def self.getMapDims(id)
    # Create cache if doesn't exist
    @@MapDims = [] if !@@MapDims
    # Add map to cache if can't be found
    if !@@MapDims[id]
      begin
        map = load_data(sprintf("Data/Map%03d.rxdata", id))
        @@MapDims[id] = [map.width,map.height]
      rescue
        @@MapDims[id] = [0,0]
      end
    end
    # Return map in cache
    return @@MapDims[id]
  end

  # Returns the X or Y coordinate of an edge on the map with id.
  # Considers the special strings "N","W","E","S"
  def self.getMapEdge(id,edge)
    return 0 if edge=="N" || edge=="W"
    dims = getMapDims(id)   # Get dimensions
    return dims[0] if edge=="E"
    return dims[1] if edge=="S"
    return dims[0]   # real dimension (use width)
  end

  def self.mapInRange?(map)
    range = 6   # Number of tiles
    dispx = map.display_x
    dispy = map.display_y
    return false if dispx >= (map.width + range) * Game_Map::REAL_RES_X
    return false if dispy >= (map.height + range) * Game_Map::REAL_RES_Y
    return false if dispx <= -(Graphics.width + range * Game_Map::TILE_WIDTH) * Game_Map::X_SUBPIXELS
    return false if dispy <= -(Graphics.height + range * Game_Map::TILE_HEIGHT) * Game_Map::Y_SUBPIXELS
    return true
  end

  def self.mapInRangeById?(id,dispx,dispy)
    range = 6   # Number of tiles
    dims = MapFactoryHelper.getMapDims(id)
    return false if dispx >= (dims[0] + range) * Game_Map::REAL_RES_X
    return false if dispy >= (dims[1] + range) * Game_Map::REAL_RES_Y
    return false if dispx <= -(Graphics.width + range * Game_Map::TILE_WIDTH) * Game_Map::X_SUBPIXELS
    return false if dispy <= -(Graphics.height + range * Game_Map::TILE_HEIGHT) * Game_Map::Y_SUBPIXELS
    return true
  end
end

#===============================================================================
#
#===============================================================================
# Unused
def updateTilesets
  maps = $MapFactory.maps
  for map in maps
    map.updateTileset if map
  end
end


#===============================================================================
# Script Page: 
#===============================================================================


#===============================================================================
# Script Page: [[ Switches and Variables ]]
#===============================================================================


#===============================================================================
# Script Page: GlobalStateHandlers
#===============================================================================
class GlobalSwitchChanged < HandlerHashBasic
end

class GlobalVariableChanged < HandlerHashBasic
end

module GlobalStateHandlers
    GlobalSwitchChanged   = HandlerHashBasic.new
    GlobalVariableChanged = HandlerHashBasic.new
    
    #=============================================================================

    def self.triggerGlobalSwitchChanged(switchID,value)
        GlobalSwitchChanged.trigger(switchID,switchID,value)
    end
      
    def self.triggerGlobalVariableChanged(variableID,value)
        GlobalVariableChanged.trigger(variableID,variableID,value)
    end
end

#===============================================================================
# Script Page: Game_Switches
#===============================================================================
#===============================================================================
# ** Game_Switches
#-------------------------------------------------------------------------------
#  This class handles switches. It's a wrapper for the built-in class "Array."
#  Refer to "$game_switches" for the instance of this class.
#===============================================================================
class Game_Switches
  #-----------------------------------------------------------------------------
  # * Object Initialization
  #-----------------------------------------------------------------------------
  def initialize
    @data = []
  end
  #-----------------------------------------------------------------------------
  # * Get Switch
  #     switch_id : switch ID
  #-----------------------------------------------------------------------------
  def [](switch_id)
    return @data[switch_id] if switch_id <= 5000 && @data[switch_id] != nil
    return false
  end
  #-----------------------------------------------------------------------------
  # * Set Switch
  #     switch_id : switch ID
  #     value     : ON (true) / OFF (false)
  #-----------------------------------------------------------------------------
  def []=(switch_id, value)
    @data[switch_id] = value if switch_id <= 5000
    GlobalStateHandlers.triggerGlobalSwitchChanged(switch_id, value)
  end
end


#===============================================================================
# Script Page: Game_Variables
#===============================================================================
#===============================================================================
# ** Game_Variables
#-------------------------------------------------------------------------------
#  This class handles variables. It's a wrapper for the built-in class "Array."
#  Refer to "$game_variables" for the instance of this class.
#===============================================================================
class Game_Variables
  #-----------------------------------------------------------------------------
  # * Object Initialization
  #-----------------------------------------------------------------------------
  def initialize
    @data = []
  end
  #-----------------------------------------------------------------------------
  # * Get Variable
  #     variable_id : variable ID
  #-----------------------------------------------------------------------------
  def [](variable_id)
    return @data[variable_id] if variable_id <= 5000 && !@data[variable_id].nil?
    return 0
  end
  #-----------------------------------------------------------------------------
  # * Set Variable
  #     variable_id : variable ID
  #     value       : the variable's value
  #-----------------------------------------------------------------------------
  def []=(variable_id, value)
    @data[variable_id] = value if variable_id <= 5000
    GlobalStateHandlers.triggerGlobalVariableChanged(variable_id, value)
  end
end


#===============================================================================
# Script Page: Game_SelfSwitches
#===============================================================================
#===============================================================================
# ** Game_SelfSwitches
#-------------------------------------------------------------------------------
#  This class handles self switches. It's a wrapper for the built-in class
#  "Hash." Refer to "$game_self_switches" for the instance of this class.
#===============================================================================
class Game_SelfSwitches
  #-----------------------------------------------------------------------------
  # * Object Initialization
  #-----------------------------------------------------------------------------
  def initialize
    @data = {}
  end
  #-----------------------------------------------------------------------------
  # * Get Self Switch
  #     key : key
  #-----------------------------------------------------------------------------
  def [](key)
    return (@data[key]==true) ? true : false
  end
  #-----------------------------------------------------------------------------
  # * Set Self Switch
  #     key   : key
  #     value : ON (true) / OFF (false)
  #-----------------------------------------------------------------------------
  def []=(key, value)
    @data[key] = value
  end
end


#===============================================================================
# Script Page: ==================
#===============================================================================


#===============================================================================
# Script Page: [[ Sprites ]]
#===============================================================================


#===============================================================================
# Script Page: Sprite_Picture
#===============================================================================
class Sprite_Picture
  def initialize(viewport, picture)
    @viewport = viewport
    @picture = picture
    @sprite = nil
    update
  end

  def dispose
    @sprite.dispose if @sprite
  end

  def update
    @sprite.update if @sprite
    # If picture file name is different from current one
    if @picture_name != @picture.name
      # Remember file name to instance variables
      @picture_name = @picture.name
      # If file name is not empty
      if @picture_name != ""
        # Get picture graphic
        @sprite=IconSprite.new(0,0,@viewport) if !@sprite
        @sprite.setBitmap("Graphics/Pictures/"+@picture_name)
      end
    end
    # If file name is empty
    if @picture_name == ""
      # Set sprite to invisible
      if @sprite
        @sprite.dispose if @sprite
        @sprite=nil
      end
      return
    end
    # Set sprite to visible
    @sprite.visible = true
    # Set transfer starting point
    if @picture.origin == 0
      @sprite.ox = 0
      @sprite.oy = 0
    else
      @sprite.ox = @sprite.bitmap.width / 2
      @sprite.oy = @sprite.bitmap.height / 2
    end
    # Set sprite coordinates
    @sprite.x = @picture.x
    @sprite.y = @picture.y
    @sprite.z = @picture.number
    # Set zoom rate, opacity level, and blend method
    @sprite.zoom_x = @picture.zoom_x / 100.0
    @sprite.zoom_y = @picture.zoom_y / 100.0
    @sprite.opacity = @picture.opacity
    @sprite.blend_type = @picture.blend_type
    # Set rotation angle and color tone
    @sprite.angle = @picture.angle
    @sprite.tone = @picture.tone
  end
end


#===============================================================================
# Script Page: Sprite_Timer
#===============================================================================
class Sprite_Timer
  def initialize(viewport=nil)
    @viewport=viewport
    @timer=nil
    @total_sec=nil
    @disposed=false
  end

  def dispose
    @timer.dispose if @timer
    @timer=nil
    @disposed=true
  end

  def disposed?
    @disposed
  end

  def update
    return if disposed?
    if $game_system.timer_working
      @timer.visible = true if @timer
      if !@timer
        @timer=Window_AdvancedTextPokemon.newWithSize("",Graphics.width-120,0,120,64)
        @timer.width=@timer.borderX+96
        @timer.x=Graphics.width-@timer.width
        @timer.viewport=@viewport
        @timer.z=99998
      end
      curtime=$game_system.timer / Graphics.frame_rate
      curtime=0 if curtime<0
      if curtime != @total_sec
        # Calculate total number of seconds
        @total_sec = curtime
        # Make a string for displaying the timer
        min = @total_sec / 60
        sec = @total_sec % 60
        @timer.text = _ISPRINTF("<ac>{1:02d}:{2:02d}", min, sec)
      end
      @timer.update
    else
      @timer.visible=false if @timer
    end
  end
end


#===============================================================================
# Script Page: Sprite_Character
#===============================================================================
class BushBitmap
  def initialize(bitmap, isTile, depth)
    @bitmaps  = []
    @bitmap   = bitmap
    @isTile   = isTile
    @isBitmap = @bitmap.is_a?(Bitmap)
    @depth    = depth
  end

  def dispose
    @bitmaps.each { |b| b.dispose if b }
  end

  def bitmap
    thisBitmap = (@isBitmap) ? @bitmap : @bitmap.bitmap
    current = (@isBitmap) ? 0 : @bitmap.currentIndex
    if !@bitmaps[current]
      if @isTile
        @bitmaps[current] = pbBushDepthTile(thisBitmap, @depth)
      else
        @bitmaps[current] = pbBushDepthBitmap(thisBitmap, @depth)
      end
    end
    return @bitmaps[current]
  end

  def pbBushDepthBitmap(bitmap, depth)
    ret = Bitmap.new(bitmap.width, bitmap.height)
    charheight = ret.height / 4
    cy = charheight - depth - 2
    for i in 0...4
      y = i * charheight
      if cy >= 0
        ret.blt(0, y, bitmap, Rect.new(0, y, ret.width, cy))
        ret.blt(0, y + cy, bitmap, Rect.new(0, y + cy, ret.width, 2), 170)
      end
      ret.blt(0, y + cy + 2, bitmap, Rect.new(0, y + cy + 2, ret.width, 2), 85) if cy + 2 >= 0
    end
    return ret
  end

  def pbBushDepthTile(bitmap, depth)
    ret = Bitmap.new(bitmap.width, bitmap.height)
    charheight = ret.height
    cy = charheight - depth - 2
    y = charheight
    if cy >= 0
      ret.blt(0, y, bitmap, Rect.new(0, y, ret.width, cy))
      ret.blt(0, y + cy, bitmap, Rect.new(0, y + cy, ret.width, 2), 170)
    end
    ret.blt(0, y + cy + 2, bitmap, Rect.new(0, y + cy + 2, ret.width, 2), 85) if cy + 2 >= 0
    return ret
  end
end



class Sprite_Character < RPG::Sprite
    attr_accessor :steps
    attr_accessor :character
    
    def initialize(viewport, character = nil, is_follower = false)
      @viewport = viewport
      @is_follower = is_follower
      @ombrelist = []
      @character = character
      super(viewport)
      @oldbushdepth = 0
      @spriteoffset = false
      if !character || character == $game_player || (character.name[/reflection/i] rescue false)
        @reflection = Sprite_Reflection.new(self, character, viewport)
      end
      @surfbase = Sprite_SurfBase.new(self, character, viewport) if character == $game_player
      update
      @steps = []
    end
    
    def dispose
        @bushbitmap.dispose if @bushbitmap
        @bushbitmap = nil
        @charbitmap.dispose if @charbitmap
        @charbitmap = nil
        @reflection.dispose if @reflection
        @reflection = nil
        @surfbase.dispose if @surfbase
        @surfbase = nil
        super
    end

    def setReflection(event, viewport)
        @reflection ||= Sprite_Reflection.new(self, event, viewport)
    end
    
    def groundY
      return @character.screen_y_ground
    end
  
    def visible=(value)
      super(value)
      @reflection.visible = value if @reflection
    end
    
    def setShadows(map, shadows)
        if character.is_a?(Game_Event) && shadows.length > 0
            params = XPML_read(map, "Shadow", @character, 4)
            unless params.nil?
                for i in 0...shadows.size
                    @ombrelist.push(Sprite_Shadow.new(viewport, @character, shadows[i]))
                end
            end
        end
        if character.is_a?(Game_Player) && shadows.length > 0
            for i in 0...shadows.size
                @ombrelist.push(Sprite_Shadow.new(viewport, $game_player, shadows[i]))
            end
        end
        update
    end

    def clearShadows
        @ombrelist.each { |s| s.dispose if s }
        @ombrelist.clear
    end
  
    def update
        return if @character.is_a?(Game_Event) && !@character.should_update?
        super
        character_update
    end

    def character_update
        if @tile_id != @character.tile_id ||
           @character_name != @character.character_name ||
           @character_hue != @character.character_hue ||
           @oldbushdepth != @character.bush_depth
            @tile_id        = @character.tile_id
            @character_name = @character.character_name
            @character_hue  = @character.character_hue
            @oldbushdepth   = @character.bush_depth
            if @tile_id >= 384
                @charbitmap.dispose if @charbitmap
                @charbitmap = pbGetTileBitmap(@character.map.tileset_name, @tile_id,
                                              @character_hue, @character.width, @character.height)
                @charbitmapAnimated = false
                @bushbitmap.dispose if @bushbitmap
                @bushbitmap = nil
                @spriteoffset = false
                @cw = Game_Map::TILE_WIDTH * @character.width
                @ch = Game_Map::TILE_HEIGHT * @character.height
                src_rect.set(0, 0, @cw, @ch)
                self.ox = @cw / 2
                self.oy = @ch
                @character.sprite_size = [@cw, @ch]
            else
                @charbitmap.dispose if @charbitmap
                @charbitmap = AnimatedBitmap.new(
                    "Graphics/Characters/" + @character_name, @character_hue)
                RPG::Cache.retain("Graphics/Characters/", @character_name, @character_hue) if @character == $game_player
                @charbitmapAnimated = true
                @bushbitmap.dispose if @bushbitmap
                @bushbitmap = nil
                @spriteoffset = @character_name[/offset/i]
                @cw = @charbitmap.width / 4
                @ch = @charbitmap.height / 4
                self.ox = @cw / 2
                @character.sprite_size = [@cw, @ch]
            end
        end
        @charbitmap.update if @charbitmapAnimated
        bushdepth = @character.bush_depth
        if bushdepth == 0
            self.bitmap = @charbitmapAnimated ? @charbitmap.bitmap : @charbitmap
        else
            @bushbitmap ||= BushBitmap.new(@charbitmap, (@tile_id >= 384), bushdepth)
            self.bitmap = @bushbitmap.bitmap
        end
        self.visible = !@character.transparent
        if @tile_id == 0
            sx = @character.pattern * @cw
            sy = ((@character.direction - 2) / 2) * @ch
            src_rect.set(sx, sy, @cw, @ch)
            self.oy = if begin
                @spriteoffset
            rescue StandardError
                false
            end
                          @ch - 16
                      else
                          @ch
                      end
            self.oy -= @character.bob_height
        end
        if visible
            if @character.is_a?(Game_Event) && @character.name[/regulartone/i]
                tone.set(0, 0, 0, 0)
            else
                pbDayNightTint(self)
            end
        end
        self.x          = @character.screen_x
        self.y          = @character.screen_y
        self.z          = @character.screen_z(@ch)
        self.opacity    = @character.opacity
        self.blend_type = @character.blend_type
        if @character.animation_id != 0
            animation = $data_animations[@character.animation_id]
            animation(animation, true)
            @character.animation_id = 0
        end
        @reflection.update if @reflection
        @surfbase.update if @surfbase
    end
end


#===============================================================================
# Script Page: Sprite_Reflection
#===============================================================================
class Sprite_Reflection
  attr_reader :visible
  attr_accessor :event

  def initialize(sprite,event,viewport=nil)
    @rsprite  = sprite
    @sprite   = nil
    @event    = event
    @height   = 0
    @fixedheight = false
    if @event && @event!=$game_player
      if @event.name[/reflection\((\d+)\)/i]
        @height = $~[1].to_i || 0
        @fixedheight = true
      end
    end
    @viewport = viewport
    @disposed = false
    update
  end

  def dispose
    if !@disposed
      @sprite.dispose if @sprite
      @sprite   = nil
      @disposed = true
    end
  end

  def disposed?
    @disposed
  end

  def visible=(value)
    @visible = value
    @sprite.visible = value if @sprite && !@sprite.disposed?
  end

  def update
    return if disposed?
    shouldShow = @rsprite.visible
    if !shouldShow
      # Just-in-time disposal of sprite
      if @sprite
        @sprite.dispose
        @sprite = nil
      end
      return
    end
    # Just-in-time creation of sprite
    @sprite = Sprite.new(@viewport) if !@sprite
    if @sprite
      x = @rsprite.x-@rsprite.ox
      y = @rsprite.y-@rsprite.oy
      y -= 32 if @rsprite.character.character_name[/offset/i]
      @height = $PokemonGlobal.bridge if !@fixedheight
      y += @height*16
      width  = @rsprite.src_rect.width
      height = @rsprite.src_rect.height
      @sprite.x        = x+width/2
      @sprite.y        = y+height+height/2
      @sprite.ox       = width/2
      @sprite.oy       = height/2-2   # Hard-coded 2 pixel shift up
      @sprite.oy       -= @rsprite.character.bob_height*2
      @sprite.z        = -50   # Still water is -100, map is 0 and above
      @sprite.zoom_x   = @rsprite.zoom_x
      @sprite.zoom_y   = @rsprite.zoom_y
      frame = (Graphics.frame_count%40)/10
      @sprite.zoom_x   *= [1.0, 0.95, 1.0, 1.05][frame]
      @sprite.angle    = 180.0
      @sprite.mirror   = true
      @sprite.bitmap   = @rsprite.bitmap
      @sprite.tone     = @rsprite.tone
      if @height>0
        @sprite.color   = Color.new(48,96,160,255)   # Dark still water
        @sprite.opacity = @rsprite.opacity
        @sprite.visible = !Settings::TIME_SHADING   # Can't time-tone a colored sprite
      else
        @sprite.color   = Color.new(224,224,224,96)
        @sprite.opacity = @rsprite.opacity*3/4
        @sprite.visible = true
      end
      @sprite.src_rect = @rsprite.src_rect
    end
  end
end


#===============================================================================
# Script Page: Sprite_SurfBase
#===============================================================================
class Sprite_SurfBase
  attr_reader   :visible
  attr_accessor :event

  def initialize(sprite,event,viewport=nil)
    @rsprite  = sprite
    @sprite   = nil
    @event    = event
    @viewport = viewport
    @disposed = false
    @surfbitmap = AnimatedBitmap.new("Graphics/Characters/base_surf")
    @divebitmap = AnimatedBitmap.new("Graphics/Characters/base_dive")
    RPG::Cache.retain("Graphics/Characters/base_surf")
    RPG::Cache.retain("Graphics/Characters/base_dive")
    @cws = @surfbitmap.width/4
    @chs = @surfbitmap.height/4
    @cwd = @divebitmap.width/4
    @chd = @divebitmap.height/4
    update
  end

  def dispose
    return if @disposed
    @sprite.dispose if @sprite
    @sprite   = nil
    @surfbitmap.dispose
    @divebitmap.dispose
    @disposed = true
  end

  def disposed?
    @disposed
  end

  def visible=(value)
    @visible = value
    @sprite.visible = value if @sprite && !@sprite.disposed?
  end

  def update
    return if disposed?
    if !$PokemonGlobal.surfing && !$PokemonGlobal.diving
      # Just-in-time disposal of sprite
      if @sprite
        @sprite.dispose
        @sprite = nil
      end
      return
    end
    # Just-in-time creation of sprite
    @sprite = Sprite.new(@viewport) if !@sprite
    if @sprite
      if $PokemonGlobal.surfing
        @sprite.bitmap = @surfbitmap.bitmap
        cw = @cws
        ch = @chs
      elsif $PokemonGlobal.diving
        @sprite.bitmap = @divebitmap.bitmap
        cw = @cwd
        ch = @chd
      end
      sx = @event.pattern_surf*cw
      sy = ((@event.direction-2)/2)*ch
      @sprite.src_rect.set(sx,sy,cw,ch)
      if $PokemonTemp.surfJump
        @sprite.x = ($PokemonTemp.surfJump[0]*Game_Map::REAL_RES_X-@event.map.display_x+3)/4+(Game_Map::TILE_WIDTH/2)
        @sprite.y = ($PokemonTemp.surfJump[1]*Game_Map::REAL_RES_Y-@event.map.display_y+3)/4+(Game_Map::TILE_HEIGHT/2)+16
      else
        @sprite.x = @rsprite.x
        @sprite.y = @rsprite.y
      end
      @sprite.ox      = cw/2
      @sprite.oy      = ch-16   # Assume base needs offsetting
      @sprite.oy      -= @event.bob_height
      @sprite.z       = @event.screen_z(ch)-1
      @sprite.zoom_x  = @rsprite.zoom_x
      @sprite.zoom_y  = @rsprite.zoom_y
      @sprite.tone    = @rsprite.tone
      @sprite.color   = @rsprite.color
      @sprite.opacity = @rsprite.opacity
    end
  end
end


#===============================================================================
# Script Page: PictureEx
#===============================================================================
class PictureOrigin
  TopLeft     = 0
  Center      = 1
  TopRight    = 2
  BottomLeft  = 3
  LowerLeft   = 3
  BottomRight = 4
  LowerRight  = 4
  Top         = 5
  Bottom      = 6
  Left        = 7
  Right       = 8
end



class Processes
  XY         = 0
  DeltaXY    = 1
  Z          = 2
  Curve      = 3
  Zoom       = 4
  Angle      = 5
  Tone       = 6
  Color      = 7
  Hue        = 8
  Opacity    = 9
  Visible    = 10
  BlendType  = 11
  SE         = 12
  Name       = 13
  Origin     = 14
  Src        = 15
  SrcSize    = 16
  CropBottom = 17
end



def getCubicPoint2(src,t)
  x0  = src[0];  y0 = src[1]
  cx0 = src[2]; cy0 = src[3]
  cx1 = src[4]; cy1 = src[5]
  x1  = src[6];  y1 = src[7]

  x1 = cx1+(x1-cx1)*t
  x0 = x0+(cx0-x0)*t
  cx0 = cx0+(cx1-cx0)*t
  cx1 = cx0+(x1-cx0)*t
  cx0 = x0+(cx0-x0)*t
  cx = cx0+(cx1-cx0)*t
  # a = x1 - 3 * cx1 + 3 * cx0 - x0
  # b = 3 * (cx1 - 2 * cx0 + x0)
  # c = 3 * (cx0 - x0)
  # d = x0
  # cx = a*t*t*t + b*t*t + c*t + d
  y1 = cy1+(y1-cy1)*t
  y0 = y0+(cy0-y0)*t
  cy0 = cy0+(cy1-cy0)*t
  cy1 = cy0+(y1-cy0)*t
  cy0 = y0+(cy0-y0)*t
  cy = cy0+(cy1-cy0)*t
  # a = y1 - 3 * cy1 + 3 * cy0 - y0
  # b = 3 * (cy1 - 2 * cy0 + y0)
  # c = 3 * (cy0 - y0)
  # d = y0
  # cy = a*t*t*t + b*t*t + c*t + d
  return [cx,cy]
end



#===============================================================================
# PictureEx
#===============================================================================
class PictureEx
  attr_accessor :x              # x-coordinate
  attr_accessor :y              # y-coordinate
  attr_accessor :z              # z value
  attr_accessor :zoom_x         # x directional zoom rate
  attr_accessor :zoom_y         # y directional zoom rate
  attr_accessor :angle          # rotation angle
  attr_accessor :tone           # tone
  attr_accessor :color          # color
  attr_accessor :hue            # filename hue
  attr_accessor :opacity        # opacity level
  attr_accessor :visible        # visibility boolean
  attr_accessor :blend_type     # blend method
  attr_accessor :name           # file name
  attr_accessor :origin         # starting point
  attr_reader   :src_rect       # source rect
  attr_reader   :cropBottom     # crops sprite to above this y-coordinate
  attr_reader   :frameUpdates   # Array of processes updated in a frame

  def initialize(z)
    # process: [type, delay, total_duration, frame_counter, cb, etc.]
    @processes     = []
    @x             = 0.0
    @y             = 0.0
    @z             = z
    @zoom_x        = 100.0
    @zoom_y        = 100.0
    @angle         = 0
    @rotate_speed  = 0
    @tone          = Tone.new(0, 0, 0, 0)
    @tone_duration = 0
    @color         = Color.new(0, 0, 0, 0)
    @hue           = 0
    @opacity       = 255.0
    @visible       = true
    @blend_type    = 0
    @name          = ""
    @origin        = PictureOrigin::TopLeft
    @src_rect      = Rect.new(0,0,-1,-1)
    @cropBottom    = -1
    @frameUpdates  = []
  end

  def callback(cb)
    if cb.is_a?(Proc);      cb.call(self)
    elsif cb.is_a?(Array);  cb[0].method(cb[1]).call(self)
    elsif cb.is_a?(Method); cb.call(self)
    end
  end

  def setCallback(delay, cb=nil)
    delay = ensureDelayAndDuration(delay)
    @processes.push([nil,delay,0,0,cb])
  end

  def running?
    return @processes.length>0
  end

  def totalDuration
    ret = 0
    for process in @processes
      dur = process[1]+process[2]
      ret = dur if dur>ret
    end
    ret *= 20.0/Graphics.frame_rate
    return ret.to_i
  end

  def ensureDelayAndDuration(delay, duration=nil)
    delay = self.totalDuration if delay<0
    delay *= Graphics.frame_rate/20.0
    if !duration.nil?
      duration *= Graphics.frame_rate/20.0
      return delay.to_i, duration.to_i
    end
    return delay.to_i
  end

  def ensureDelay(delay)
    return ensureDelayAndDuration(delay)
  end

  # speed is the angle to change by in 1/20 of a second. @rotate_speed is the
  # angle to change by per frame.
  # NOTE: This is not compatible with manually changing the angle at a certain
  #       point. If you make a sprite auto-rotate, you should not try to alter
  #       the angle another way too.
  def rotate(speed)
    @rotate_speed = speed*20.0/Graphics.frame_rate
    while @rotate_speed<0; @rotate_speed += 360; end
    @rotate_speed %= 360
  end

  def erase
    self.name = ""
  end

  def clearProcesses
    @processes = []
  end

  def adjustPosition(xOffset, yOffset)
    for process in @processes
      next if process[0]!=Processes::XY
      process[5] += xOffset
      process[6] += yOffset
      process[7] += xOffset
      process[8] += yOffset
    end
  end

  def move(delay, duration, origin, x, y, zoom_x=100.0, zoom_y=100.0, opacity=255)
    setOrigin(delay,duration,origin)
    moveXY(delay,duration,x,y)
    moveZoomXY(delay,duration,zoom_x,zoom_y)
    moveOpacity(delay,duration,opacity)
  end

  def moveXY(delay, duration, x, y, cb=nil)
    delay, duration = ensureDelayAndDuration(delay,duration)
    @processes.push([Processes::XY,delay,duration,0,cb,@x,@y,x,y])
  end

  def setXY(delay, x, y, cb=nil)
    moveXY(delay,0,x,y,cb)
  end

  def moveCurve(delay, duration, x1, y1, x2, y2, x3, y3, cb=nil)
    delay, duration = ensureDelayAndDuration(delay,duration)
    @processes.push([Processes::Curve,delay,duration,0,cb,[@x,@y,x1,y1,x2,y2,x3,y3]])
  end

  def moveDelta(delay, duration, x, y, cb=nil)
    delay, duration = ensureDelayAndDuration(delay,duration)
    @processes.push([Processes::DeltaXY,delay,duration,0,cb,@x,@y,x,y])
  end

  def setDelta(delay, x, y, cb=nil)
    moveDelta(delay,0,x,y,cb)
  end

  def moveZ(delay, duration, z, cb=nil)
    delay, duration = ensureDelayAndDuration(delay,duration)
    @processes.push([Processes::Z,delay,duration,0,cb,@z,z])
  end

  def setZ(delay, z, cb=nil)
    moveZ(delay,0,z,cb)
  end

  def moveZoomXY(delay, duration, zoom_x, zoom_y, cb=nil)
    delay, duration = ensureDelayAndDuration(delay,duration)
    @processes.push([Processes::Zoom,delay,duration,0,cb,@zoom_x,@zoom_y,zoom_x,zoom_y])
  end

  def setZoomXY(delay, zoom_x, zoom_y, cb=nil)
    moveZoomXY(delay,0,zoom_x,zoom_y,cb)
  end

  def moveZoom(delay, duration, zoom, cb=nil)
    moveZoomXY(delay,duration,zoom,zoom,cb)
  end

  def setZoom(delay, zoom, cb=nil)
    moveZoomXY(delay,0,zoom,zoom,cb)
  end

  def moveAngle(delay, duration, angle, cb=nil)
    delay, duration = ensureDelayAndDuration(delay,duration)
    @processes.push([Processes::Angle,delay,duration,0,cb,@angle,angle])
  end

  def setAngle(delay, angle, cb=nil)
    moveAngle(delay,0,angle,cb)
  end

  def moveTone(delay, duration, tone, cb=nil)
    delay, duration = ensureDelayAndDuration(delay,duration)
    target = (tone) ? tone.clone : Tone.new(0,0,0,0)
    @processes.push([Processes::Tone,delay,duration,0,cb,@tone.clone,target])
  end

  def setTone(delay, tone, cb=nil)
    moveTone(delay,0,tone,cb)
  end

  def moveColor(delay, duration, color, cb=nil)
    delay, duration = ensureDelayAndDuration(delay,duration)
    target = (color) ? color.clone : Color.new(0,0,0,0)
    @processes.push([Processes::Color,delay,duration,0,cb,@color.clone,target])
  end

  def setColor(delay, color, cb=nil)
    moveColor(delay,0,color,cb)
  end

  # Hue changes don't actually work.
  def moveHue(delay, duration, hue, cb=nil)
    delay, duration = ensureDelayAndDuration(delay,duration)
    @processes.push([Processes::Hue,delay,duration,0,cb,@hue,hue])
  end

  # Hue changes don't actually work.
  def setHue(delay, hue, cb=nil)
    moveHue(delay,0,hue,cb)
  end

  def moveOpacity(delay, duration, opacity, cb=nil)
    delay, duration = ensureDelayAndDuration(delay,duration)
    @processes.push([Processes::Opacity,delay,duration,0,cb,@opacity,opacity])
  end

  def setOpacity(delay, opacity, cb=nil)
    moveOpacity(delay,0,opacity,cb)
  end

  def setVisible(delay, visible, cb=nil)
    delay = ensureDelay(delay)
    @processes.push([Processes::Visible,delay,0,0,cb,visible])
  end

  # Only values of 0 (normal), 1 (additive) and 2 (subtractive) are allowed.
  def setBlendType(delay, blend, cb=nil)
    delay = ensureDelayAndDuration(delay)
    @processes.push([Processes::BlendType,delay,0,0,cb,blend])
  end

  def setSE(delay, seFile, volume=nil, pitch=nil, cb=nil)
    delay = ensureDelay(delay)
    @processes.push([Processes::SE,delay,0,0,cb,seFile,volume,pitch])
  end

  def setName(delay, name, cb=nil)
    delay = ensureDelay(delay)
    @processes.push([Processes::Name,delay,0,0,cb,name])
  end

  def setOrigin(delay, origin, cb=nil)
    delay = ensureDelay(delay)
    @processes.push([Processes::Origin,delay,0,0,cb,origin])
  end

  def setSrc(delay, srcX, srcY, cb=nil)
    delay = ensureDelay(delay)
    @processes.push([Processes::Src,delay,0,0,cb,srcX,srcY])
  end

  def setSrcSize(delay, srcWidth, srcHeight, cb=nil)
    delay = ensureDelay(delay)
    @processes.push([Processes::SrcSize,delay,0,0,cb,srcWidth,srcHeight])
  end

  # Used to cut Pokémon sprites off when they faint and sink into the ground.
  def setCropBottom(delay, y, cb=nil)
    delay = ensureDelay(delay)
    @processes.push([Processes::CropBottom,delay,0,0,cb,y])
  end

  def update
    procEnded = false
    @frameUpdates.clear
    for i in 0...@processes.length
      process = @processes[i]
      # Decrease delay of processes that are scheduled to start later
      if process[1]>=0
        # Set initial values if the process will start this frame
        if process[1]==0
          case process[0]
          when Processes::XY
            process[5] = @x
            process[6] = @y
          when Processes::DeltaXY
            process[5] = @x
            process[6] = @y
            process[7] += @x
            process[8] += @y
          when Processes::Curve
            process[5][0] = @x
            process[5][1] = @y
          when Processes::Z
            process[5] = @z
          when Processes::Zoom
            process[5] = @zoom_x
            process[6] = @zoom_y
          when Processes::Angle
            process[5] = @angle
          when Processes::Tone
            process[5] = @tone.clone
          when Processes::Color
            process[5] = @color.clone
          when Processes::Hue
            process[5] = @hue
          when Processes::Opacity
            process[5] = @opacity
          end
        end
        # Decrease delay counter
        process[1] -= 1
        # Process hasn't started yet, skip to the next one
        next if process[1]>=0
      end
      # Update process
      @frameUpdates.push(process[0]) if !@frameUpdates.include?(process[0])
      fra = (process[2]==0) ? 1 : process[3]   # Frame counter
      dur = (process[2]==0) ? 1 : process[2]   # Total duration of process
      case process[0]
      when Processes::XY, Processes::DeltaXY
        @x = process[5] + fra * (process[7] - process[5]) / dur
        @y = process[6] + fra * (process[8] - process[6]) / dur
      when Processes::Curve
        @x, @y = getCubicPoint2(process[5],fra.to_f/dur)
      when Processes::Z
        @z = process[5] + fra * (process[6] - process[5]) / dur
      when Processes::Zoom
        @zoom_x = process[5] + fra * (process[7] - process[5]) / dur
        @zoom_y = process[6] + fra * (process[8] - process[6]) / dur
      when Processes::Angle
        @angle = process[5] + fra * (process[6] - process[5]) / dur
      when Processes::Tone
        @tone.red   = process[5].red + fra * (process[6].red - process[5].red) / dur
        @tone.green = process[5].green + fra * (process[6].green - process[5].green) / dur
        @tone.blue  = process[5].blue + fra * (process[6].blue - process[5].blue) / dur
        @tone.gray  = process[5].gray + fra * (process[6].gray - process[5].gray) / dur
      when Processes::Color
        @color.red   = process[5].red + fra * (process[6].red - process[5].red) / dur
        @color.green = process[5].green + fra * (process[6].green - process[5].green) / dur
        @color.blue  = process[5].blue + fra * (process[6].blue - process[5].blue) / dur
        @color.alpha = process[5].alpha + fra * (process[6].alpha - process[5].alpha) / dur
      when Processes::Hue
        @hue = (process[6] - process[5]).to_f / dur
      when Processes::Opacity
        @opacity = process[5] + fra * (process[6] - process[5]) / dur
      when Processes::Visible
        @visible = process[5]
      when Processes::BlendType
        @blend_type = process[5]
      when Processes::SE
        pbSEPlay(process[5],process[6],process[7])
      when Processes::Name
        @name = process[5]
      when Processes::Origin
        @origin = process[5]
      when Processes::Src
        @src_rect.x = process[5]
        @src_rect.y = process[6]
      when Processes::SrcSize
        @src_rect.width  = process[5]
        @src_rect.height = process[6]
      when Processes::CropBottom
        @cropBottom = process[5]
      end
      # Increase frame counter
      process[3] += 1
      if process[3]>process[2]
        # Process has ended, erase it
        callback(process[4]) if process[4]
        @processes[i] = nil
        procEnded = true
      end
    end
    # Clear out empty spaces in @processes array caused by finished processes
    @processes.compact! if procEnded
    # Add the constant rotation speed
    if @rotate_speed != 0
      @frameUpdates.push(Processes::Angle) if !@frameUpdates.include?(Processes::Angle)
      @angle += @rotate_speed
      while @angle<0; @angle += 360; end
      @angle %= 360
    end
  end
end



#===============================================================================
#
#===============================================================================
def setPictureSprite(sprite, picture, iconSprite=false)
  return if picture.frameUpdates.length==0
  for i in 0...picture.frameUpdates.length
    case picture.frameUpdates[i]
    when Processes::XY, Processes::DeltaXY
      sprite.x = picture.x.round
      sprite.y = picture.y.round
    when Processes::Z
      sprite.z = picture.z
    when Processes::Zoom
      sprite.zoom_x = picture.zoom_x / 100.0
      sprite.zoom_y = picture.zoom_y / 100.0
    when Processes::Angle
      sprite.angle = picture.angle
    when Processes::Tone
      sprite.tone = picture.tone
    when Processes::Color
      sprite.color = picture.color
    when Processes::Hue
      # This doesn't do anything.
    when Processes::BlendType
      sprite.blend_type = picture.blend_type
    when Processes::Opacity
      sprite.opacity = picture.opacity
    when Processes::Visible
      sprite.visible = picture.visible
    when Processes::Name
      sprite.name = picture.name if iconSprite && sprite.name != picture.name
    when Processes::Origin
      case picture.origin
      when PictureOrigin::TopLeft, PictureOrigin::Left, PictureOrigin::BottomLeft
        sprite.ox = 0
      when PictureOrigin::Top, PictureOrigin::Center, PictureOrigin::Bottom
        sprite.ox = (sprite.bitmap && !sprite.bitmap.disposed?) ? sprite.src_rect.width/2 : 0
      when PictureOrigin::TopRight, PictureOrigin::Right, PictureOrigin::BottomRight
        sprite.ox = (sprite.bitmap && !sprite.bitmap.disposed?) ? sprite.src_rect.width : 0
      end
      case picture.origin
      when PictureOrigin::TopLeft, PictureOrigin::Top, PictureOrigin::TopRight
        sprite.oy = 0
      when PictureOrigin::Left, PictureOrigin::Center, PictureOrigin::Right
        sprite.oy = (sprite.bitmap && !sprite.bitmap.disposed?) ? sprite.src_rect.height/2 : 0
      when PictureOrigin::BottomLeft, PictureOrigin::Bottom, PictureOrigin::BottomRight
        sprite.oy = (sprite.bitmap && !sprite.bitmap.disposed?) ? sprite.src_rect.height : 0
      end
    when Processes::Src
      next unless iconSprite && sprite.src_rect
      sprite.src_rect.x = picture.src_rect.x
      sprite.src_rect.y = picture.src_rect.y
    when Processes::SrcSize
      next unless iconSprite && sprite.src_rect
      sprite.src_rect.width  = picture.src_rect.width
      sprite.src_rect.height = picture.src_rect.height
    end
  end
  if iconSprite && sprite.src_rect && picture.cropBottom>=0
    spriteBottom = sprite.y-sprite.oy+sprite.src_rect.height
    if spriteBottom>picture.cropBottom
      sprite.src_rect.height = [picture.cropBottom-sprite.y+sprite.oy,0].max
    end
  end
end

def setPictureIconSprite(sprite, picture)
  setPictureSprite(sprite,picture,true)
end


#===============================================================================
# Script Page: Interpolators
#===============================================================================
class Interpolator
  ZOOM_X  = 1
  ZOOM_Y  = 2
  X       = 3
  Y       = 4
  OPACITY = 5
  COLOR   = 6
  WAIT    = 7

  def initialize
    @tweening = false
    @tweensteps = []
    @sprite = nil
    @frames = 0
    @step = 0
  end

  def tweening?
    return @tweening
  end

  def tween(sprite,items,frames)
    @tweensteps = []
    if sprite && !sprite.disposed? && frames>0
      @frames = frames
      @step = 0
      @sprite = sprite
      for item in items
        case item[0]
        when ZOOM_X
          @tweensteps[item[0]] = [sprite.zoom_x,item[1]-sprite.zoom_x]
        when ZOOM_Y
          @tweensteps[item[0]] = [sprite.zoom_y,item[1]-sprite.zoom_y]
        when X
          @tweensteps[item[0]] = [sprite.x,item[1]-sprite.x]
        when Y
          @tweensteps[item[0]] = [sprite.y,item[1]-sprite.y]
        when OPACITY
          @tweensteps[item[0]] = [sprite.opacity,item[1]-sprite.opacity]
        when COLOR
          @tweensteps[item[0]] = [sprite.color.clone,Color.new(
             item[1].red-sprite.color.red,
             item[1].green-sprite.color.green,
             item[1].blue-sprite.color.blue,
             item[1].alpha-sprite.color.alpha
          )]
        end
      end
      @tweening = true
    end
  end

  def update
    if @tweening
      t = (@step*1.0)/@frames
      for i in 0...@tweensteps.length
        item = @tweensteps[i]
        next if !item
        case i
        when ZOOM_X
          @sprite.zoom_x = item[0]+item[1]*t
        when ZOOM_Y
          @sprite.zoom_y = item[0]+item[1]*t
        when X
          @sprite.x = item[0]+item[1]*t
        when Y
          @sprite.y = item[0]+item[1]*t
        when OPACITY
          @sprite.opacity = item[0]+item[1]*t
        when COLOR
          @sprite.color = Color.new(
             item[0].red+item[1].red*t,
             item[0].green+item[1].green*t,
             item[0].blue+item[1].blue*t,
             item[0].alpha+item[1].alpha*t
          )
        end
      end
      @step += 1
      if @step==@frames
        @step = 0
        @frames = 0
        @tweening = false
      end
    end
  end
end



class RectInterpolator
  def initialize(oldrect,newrect,frames)
    restart(oldrect,newrect,frames)
  end

  def restart(oldrect,newrect,frames)
    @oldrect = oldrect
    @newrect = newrect
    @frames = [frames,1].max
    @curframe = 0
    @rect = oldrect.clone
  end

  def set(rect)
    rect.set(@rect.x,@rect.y,@rect.width,@rect.height)
  end

  def done?
    @curframe>@frames
  end

  def update
    return if done?
    t = (@curframe*1.0/@frames)
    x1 = @oldrect.x
    x2 = @newrect.x
    x = x1+t*(x2-x1)
    y1 = @oldrect.y
    y2 = @newrect.y
    y = y1+t*(y2-y1)
    rx1 = @oldrect.x+@oldrect.width
    rx2 = @newrect.x+@newrect.width
    rx = rx1+t*(rx2-rx1)
    ry1 = @oldrect.y+@oldrect.height
    ry2 = @newrect.y+@newrect.height
    ry = ry1+t*(ry2-ry1)
    minx = x<rx ? x : rx
    maxx = x>rx ? x : rx
    miny = y<ry ? y : ry
    maxy = y>ry ? y : ry
    @rect.set(minx,miny,maxx-minx,maxy-miny)
    @curframe += 1
  end
end



class PointInterpolator
  attr_reader :x
  attr_reader :y

  def initialize(oldx,oldy,newx,newy,frames)
    restart(oldx,oldy,newx,newy,frames)
  end

  def restart(oldx,oldy,newx,newy,frames)
    @oldx = oldx
    @oldy = oldy
    @newx = newx
    @newy = newy
    @frames = frames
    @curframe = 0
    @x = oldx
    @y = oldy
  end

  def done?
    @curframe>@frames
  end

  def update
    return if done?
    t = (@curframe*1.0/@frames)
    rx1 = @oldx
    rx2 = @newx
    @x = rx1+t*(rx2-rx1)
    ry1 = @oldy
    ry2 = @newy
    @y = ry1+t*(ry2-ry1)
    @curframe += 1
  end
end


#===============================================================================
# Script Page: ScreenPosHelper
#===============================================================================
module ScreenPosHelper
  def self.pbScreenZoomX(ch)
    return Game_Map::TILE_WIDTH/32.0
  end

  def self.pbScreenZoomY(ch)
    return Game_Map::TILE_HEIGHT/32.0
  end

  def self.pbScreenX(ch)
    return ch.screen_x
  end

  def self.pbScreenY(ch)
    return ch.screen_y
  end

  @heightcache={}

  def self.bmHeight(bm)
    h=@heightcache[bm]
    if !h
      bmap=AnimatedBitmap.new("Graphics/Characters/"+bm,0)
      h=bmap.height
      @heightcache[bm]=h
      bmap.dispose
    end
    return h
  end

  def self.pbScreenZ(ch,height=nil)
    if height==nil
      height=0
      if ch.tile_id > 0
        height=32
      elsif ch.character_name!=""
        height=bmHeight(ch.character_name)/4
      end
    end
    ret=ch.screen_z(height)
    return ret
  end
end


#===============================================================================
# Script Page: ==================
#===============================================================================


#===============================================================================
# Script Page: [[ Map renderer ]]
#===============================================================================


#===============================================================================
# Script Page: TilemapLoader
#===============================================================================
class TilemapLoader
  def initialize(viewport)
    @viewport = viewport
    @tilemap  = nil
    @color    = Color.new(0,0,0,0)
    @tone     = Tone.new(0,0,0,0)
    updateClass
  end

  def updateClass
    setClass(CustomTilemap)
  end

  def setClass(cls)
    newtilemap = cls.new(@viewport)
    if @tilemap
      newtilemap.tileset      = @tilemap.tileset
      newtilemap.map_data     = @tilemap.map_data
      newtilemap.flash_data   = @tilemap.flash_data
      newtilemap.priorities   = @tilemap.priorities
      newtilemap.terrain_tags = @tilemap.terrain_tags
      newtilemap.visible      = @tilemap.visible
      newtilemap.ox           = @tilemap.ox
      newtilemap.oy           = @tilemap.oy
      for i in 0...7
        newtilemap.autotiles[i] = @tilemap.autotiles[i]
      end
      @tilemap.dispose
      @tilemap = newtilemap
      newtilemap.update
    else
      @tilemap = newtilemap
    end
  end

  def dispose;          @tilemap.dispose;                       end
  def disposed?;        @tilemap && @tilemap.disposed?;         end
  def update;           @tilemap.update;                        end
  def viewport;         @tilemap.viewport;                      end
  def autotiles;        @tilemap.autotiles;                     end
  def tileset;          @tilemap.tileset;                       end
  def tileset=(v);      @tilemap.tileset = v;                   end
  def map_data;         @tilemap.map_data;                      end
  def map_data=(v);     @tilemap.map_data = v;                  end
  def flash_data;       @tilemap.flash_data;                    end
  def flash_data=(v);   @tilemap.flash_data = v;                end
  def priorities;       @tilemap.priorities;                    end
  def priorities=(v);   @tilemap.priorities = v;                end
  def terrain_tags;     (@tilemap.terrain_tags rescue nil);     end
  def terrain_tags=(v); (@tilemap.terrain_tags = v rescue nil); end
  def visible;          @tilemap.visible;                       end
  def visible=(v);      @tilemap.visible = v;                   end
  def tone;             (@tilemap.tone rescue @tone);           end
  def tone=(value);     (@tilemap.tone = value rescue nil);     end
  def ox;               @tilemap.ox;                            end
  def ox=(v);           @tilemap.ox = v;                        end
  def oy;               @tilemap.oy;                            end
  def oy=(v);           @tilemap.oy = v;                        end
end


#===============================================================================
# Script Page: CustomTilemap
#===============================================================================
#=======================================================================
# This module is a little fix that works around PC hardware limitations.
# Since Essentials isn't working with software rendering anymore, it now
# has to deal with the limits of the GPU. For the most part this is no
# big deal, but people do have some really big tilesets.
#
# The fix is simple enough: If your tileset is too big, a new
# bitmap will be constructed with all the excess pixels sent to the
# image's right side. This basically means that you now have a limit
# far higher than you should ever actually need.
#
# Hardware limit   -> max tileset length:
# 1024px           -> 4096px
# 2048px           -> 16384px   (enough to get the normal limit)
# 4096px           -> 65536px   (enough to load pretty much any tileset)
# 8192px           -> 262144px
# 16384px          -> 1048576px (what most people have at this point)

#                             ~Roza/Zoroark
#=======================================================================

module TileWrap

  TILESET_WIDTH        = 0x100
  # Looks useless, but covers weird numbers given to mkxp.json or a funky driver
  MAX_TEX_SIZE         = (Bitmap.max_size / 1024) * 1024
  MAX_TEX_SIZE_BOOSTED = MAX_TEX_SIZE**2/TILESET_WIDTH

  def self.clamp(val, min, max)
    val = max if val > max
    val = min if val < min
    return val
  end

  def self.wrapTileset(originalbmp)
    width = originalbmp.width
    height = originalbmp.height
    if width == TILESET_WIDTH && originalbmp.mega?
      columns = (height / MAX_TEX_SIZE.to_f).ceil

      if columns * TILESET_WIDTH > MAX_TEX_SIZE
        raise "Tilemap is too long!\n\nSIZE: #{originalbmp.height}px\nHARDWARE LIMIT: #{MAX_TEX_SIZE}px\nBOOSTED LIMIT: #{MAX_TEX_SIZE_BOOSTED}px"
      end
      bmp = Bitmap.new(TILESET_WIDTH*columns, MAX_TEX_SIZE)
      remainder = height % MAX_TEX_SIZE

      columns.times{|col|
        srcrect = Rect.new(0, col * MAX_TEX_SIZE, width, (col + 1 == columns) ? remainder : MAX_TEX_SIZE)
        bmp.blt(col*TILESET_WIDTH, 0, originalbmp, srcrect)
      }
      return bmp
    end

    return originalbmp
  end

  def self.getWrappedRect(src_rect)
    ret = Rect.new(0,0,0,0)
    col = (src_rect.y / MAX_TEX_SIZE.to_f).floor
    ret.x = col * TILESET_WIDTH + clamp(src_rect.x,0,TILESET_WIDTH)
    ret.y = src_rect.y % MAX_TEX_SIZE
    ret.width = clamp(src_rect.width, 0, TILESET_WIDTH - src_rect.x)
    ret.height = clamp(src_rect.height, 0, MAX_TEX_SIZE)
    return ret
  end

  def self.blitWrappedPixels(destX, destY, dest, src, srcrect)
    if (srcrect.y + srcrect.width < MAX_TEX_SIZE)
      # Save the processing power
      dest.blt(destX, destY, src, srcrect)
      return
    end
    merge = (srcrect.y % MAX_TEX_SIZE) > ((srcrect.y + srcrect.height) % MAX_TEX_SIZE)

    srcrect_mod = getWrappedRect(srcrect)

    if !merge
      dest.blt(destX, destY, src, srcrect_mod)
    else
      #FIXME won't work on heights longer than two columns, but nobody should need
      # more than 32k pixels high at once anyway
      side = {:a => MAX_TEX_SIZE - srcrect_mod.y, :b => srcrect_mod.height - (MAX_TEX_SIZE - srcrect_mod.y)}
      dest.blt(destX, destY, src, Rect.new(srcrect_mod.x, srcrect_mod.y, srcrect_mod.width, side[:a]))
      dest.blt(destX, destY + side[:a], src, Rect.new(srcrect_mod.x + TILESET_WIDTH, 0, srcrect_mod.width, side[:b]))
    end
  end

  def self.stretchBlitWrappedPixels(destrect, dest, src, srcrect)
    if (srcrect.y + srcrect.width < MAX_TEX_SIZE)
      # Save the processing power
      dest.stretch_blt(destrect, src, srcrect)
      return
    end
    # Does a regular blit to a non-megasurface, then stretch_blts that to
    # the destination. Yes it is slow
    tmp = Bitmap.new(srcrect.width, srcrect.height)
    blitWrappedPixels(0,0,tmp,src,srcrect)
    dest.stretch_blt(destrect, tmp, Rect.new(0,0,srcrect.width,srcrect.height))
  end
end

#===============================================================================
#
#===============================================================================
class CustomTilemapAutotiles
  attr_accessor :changed

  def initialize
    @changed = true
    @tiles   = [nil,nil,nil,nil,nil,nil,nil]
  end

  def [](i)
    return @tiles[i]
  end

  def []=(i,value)
    @tiles[i] = value
    @changed  = true
  end
end



class CustomTilemapSprite < Sprite
end



#===============================================================================
#
#===============================================================================
class CustomTilemap
  attr_reader   :tileset
  attr_reader   :autotiles
  attr_reader   :map_data
  attr_reader   :flash_data
  attr_reader   :priorities
  attr_reader   :terrain_tags
  attr_reader   :visible
  attr_reader   :viewport
  attr_reader   :graphicsWidth
  attr_reader   :graphicsHeight
  attr_reader   :ox
  attr_reader   :oy
  attr_accessor :tone
  attr_accessor :color

  Autotiles = [
    [ [27, 28, 33, 34], [ 5, 28, 33, 34], [27,  6, 33, 34], [ 5,  6, 33, 34],
      [27, 28, 33, 12], [ 5, 28, 33, 12], [27,  6, 33, 12], [ 5,  6, 33, 12] ],
    [ [27, 28, 11, 34], [ 5, 28, 11, 34], [27,  6, 11, 34], [ 5,  6, 11, 34],
      [27, 28, 11, 12], [ 5, 28, 11, 12], [27,  6, 11, 12], [ 5,  6, 11, 12] ],
    [ [25, 26, 31, 32], [25,  6, 31, 32], [25, 26, 31, 12], [25,  6, 31, 12],
      [15, 16, 21, 22], [15, 16, 21, 12], [15, 16, 11, 22], [15, 16, 11, 12] ],
    [ [29, 30, 35, 36], [29, 30, 11, 36], [ 5, 30, 35, 36], [ 5, 30, 11, 36],
      [39, 40, 45, 46], [ 5, 40, 45, 46], [39,  6, 45, 46], [ 5,  6, 45, 46] ],
    [ [25, 30, 31, 36], [15, 16, 45, 46], [13, 14, 19, 20], [13, 14, 19, 12],
      [17, 18, 23, 24], [17, 18, 11, 24], [41, 42, 47, 48], [ 5, 42, 47, 48] ],
    [ [37, 38, 43, 44], [37,  6, 43, 44], [13, 18, 19, 24], [13, 14, 43, 44],
      [37, 42, 43, 48], [17, 18, 47, 48], [13, 18, 43, 48], [ 1,  2,  7,  8] ]
  ]
  Animated_Autotiles_Frames = 5*Graphics.frame_rate/20   # Frequency of updating animated autotiles
  FlashOpacity = [100,90,80,70,80,90]

  def initialize(viewport)
    @tileset             = nil    # Refers to Map Tileset Name
    @autotiles           = CustomTilemapAutotiles.new
    @map_data            = nil    # Refers to 3D Array Of Tile Settings
    @flash_data          = nil    # Refers to 3D Array of Tile Flashdata
    @priorities          = nil    # Refers to Tileset Priorities
    @terrain_tags        = nil    # Refers to Tileset Terrain Tags
    @visible             = true   # Refers to Tileset Visibleness
    @ox                  = 0      # Bitmap Offsets
    @oy                  = 0      # Bitmap Offsets
    @plane               = false
    @haveGraphicsWH      = (Graphics.width!=nil rescue false)
    if @haveGraphicsWH
      @graphicsWidth     = Graphics.width
      @graphicsHeight    = Graphics.height
    else
      @graphicsWidth     = 640
      @graphicsHeight    = 480
    end
    @tileWidth           = Game_Map::TILE_WIDTH rescue 32
    @tileHeight          = Game_Map::TILE_HEIGHT rescue 32
    @tileSrcWidth        = 32
    @tileSrcHeight       = 32
    @diffsizes           = (@tileWidth!=@tileSrcWidth) || (@tileHeight!=@tileSrcHeight)
    @tone                = Tone.new(0,0,0,0)
    @oldtone             = Tone.new(0,0,0,0)
    @color               = Color.new(0,0,0,0)
    @oldcolor            = Color.new(0,0,0,0)
    @selfviewport        = Viewport.new(0,0,graphicsWidth,graphicsHeight)
    @viewport            = (viewport) ? viewport : @selfviewport
    @tiles               = []
    @autotileInfo        = []
    @regularTileInfo     = []
    @oldOx               = 0
    @oldOy               = 0
    @oldViewportOx       = 0
    @oldViewportOy       = 0
    @layer0              = CustomTilemapSprite.new(viewport)
    @layer0.visible      = true
    @nowshown            = false
    @layer0.bitmap       = Bitmap.new([graphicsWidth+320,1].max,[graphicsHeight+320,1].max)
    @layer0.z            = 0
    @layer0.ox           = 0
    @layer0.oy           = 0
    @oxLayer0            = 0
    @oyLayer0            = 0
    @flash               = nil
    @oxFlash             = 0
    @oyFlash             = 0
    @priotiles           = {}
    @priotilesfast       = []
    @prioautotiles       = {}
    @autosprites         = []
    @framecount          = [0,0,0,0,0,0,0,0]   # For autotiles
    @tilesetChanged      = true
    @flashChanged        = false
    @firsttime           = true
    @disposed            = false
    @usedsprites         = false
    @layer0clip          = true
    @firsttimeflash      = true
    @fullyrefreshed      = false
    @fullyrefreshedautos = false
    @shouldWrap          = false
  end

  def dispose
    return if disposed?
    @help.dispose if @help
    @help = nil
    i = 0; len = @autotileInfo.length
    while i<len
      if @autotileInfo[i]
        @autotileInfo[i].dispose
        @autotileInfo[i] = nil
      end
      i += 1
    end
    i = 0; len = @regularTileInfo.length
    while i<len
      if @regularTileInfo[i]
        @regularTileInfo[i].dispose
        @regularTileInfo[i] = nil
      end
      i += 1
    end
    i = 0; len = @tiles.length
    while i<len
      @tiles[i].dispose
      @tiles[i] = nil
      i += 2
    end
    i = 0; len = @autosprites.length
    while i<len
      @autosprites[i].dispose
      @autosprites[i] = nil
      i += 2
    end
    if @layer0
      @layer0.bitmap.dispose if !@layer0.disposed?
      @layer0.bitmap = nil if !@layer0.disposed?
      @layer0.dispose
      @layer0 = nil
    end
    if @flash
      @flash.bitmap.dispose if !@flash.disposed?
      @flash.bitmap = nil if !@flash.disposed?
      @flash.dispose
      @flash = nil
    end
    for i in 0...7
      self.autotiles[i] = nil
    end
    @tiles.clear
    @autosprites.clear
    @autotileInfo.clear
    @regularTileInfo.clear
    @tilemap = nil
    @tileset = nil
    @priorities = nil
    @selfviewport.dispose
    @selfviewport = nil
    @disposed = true
  end

  def disposed?
    return @disposed
  end

  def flash_data=(value)
    @flash_data = value
    @flashChanged = true
  end

  def map_data=(value)
    @map_data = value
    @tilesetChanged = true
  end

  def priorities=(value)
    @priorities = value
    @tilesetChanged = true
  end

  def terrain_tags=(value)
    @terrain_tags = value
    @tilesetChanged = true
  end

  def tileset=(value)
    if value.mega?
      @tileset = TileWrap::wrapTileset(value)
      @shouldWrap = true
      value.dispose
    else
      @tileset = value
      @shouldWrap = false
    end
    @tilesetChanged = true
  end

  def ox=(val)
    wasshown = self.shown?
    @ox = val.floor
    @nowshown = (!wasshown && self.shown?)
  end

  def oy=(val)
    wasshown = self.shown?
    @oy = val.floor
    @nowshown = (!wasshown && self.shown?)
  end

  def visible=(val)
    wasshown = @visible
    @visible = val
    @nowshown = (!wasshown && val)
  end

  def shown?
    return false if !@visible
    xsize  = @map_data.xsize
    xStart = @ox/@tileWidth - 1
    xStart = 0 if xStart<0
    xStart = xsize-1 if xStart>=xsize
    xEnd   = (@ox+@viewport.rect.width)/@tileWidth + 1
    xEnd   = 0 if xEnd<0
    xEnd   = xsize-1 if xEnd>=xsize
    return false if xStart>=xEnd
    ysize  = @map_data.ysize
    yStart = @oy/@tileHeight - 1
    yStart = 0 if yStart<0
    yStart = ysize-1 if yStart>=ysize
    yEnd   = (@oy+@viewport.rect.height)/@tileHeight + 1
    yEnd   = 0 if yEnd<0
    yEnd   = ysize-1 if yEnd>=ysize
    return false if yStart>=yEnd
    return true
  end

  def autotileNumFrames(id)
    autotile = @autotiles[id/48-1]
    return 0 if !autotile || autotile.disposed?
    frames = 1
    if autotile.height==@tileHeight
      frames = autotile.width/@tileWidth
    else
      frames = autotile.width/(3*@tileWidth)
    end
    return frames
  end

  def autotileFrame(id)
    autotile = @autotiles[id/48-1]
    return -1 if !autotile || autotile.disposed?
    frames = 1
    if autotile.height==@tileHeight
      frames = autotile.width/@tileWidth
    else
      frames = autotile.width/(3*@tileWidth)
    end
    return (Graphics.frame_count/Animated_Autotiles_Frames)%frames
  end

  def repaintAutotiles
    for i in 0...@autotileInfo.length
      next if !@autotileInfo[i]
      frame = autotileFrame(i)
      @autotileInfo[i].clear
      bltAutotile(@autotileInfo[i],0,0,i,frame)
    end
  end

  def bltAutotile(bitmap,x,y,id,frame)
    return if frame<0
    autotile = @autotiles[id/48-1]
    return if !autotile || autotile.disposed?
    if autotile.height==@tileSrcHeight
      anim = frame*@tileSrcWidth
      src_rect = Rect.new(anim,0,@tileSrcWidth,@tileSrcHeight)
      if @diffsizes
        bitmap.stretch_blt(Rect.new(x,y,@tileWidth,@tileHeight),autotile,src_rect)
      else
        bitmap.blt(x,y,autotile,src_rect)
      end
    else
      anim = frame*3*@tileSrcWidth
      id %= 48
      tiles = Autotiles[id>>3][id&7]
      src = Rect.new(0,0,0,0)
      halfTileWidth     = @tileWidth>>1
      halfTileHeight    = @tileHeight>>1
      halfTileSrcWidth  = @tileSrcWidth>>1
      halfTileSrcHeight = @tileSrcHeight>>1
      for i in 0...4
        tile_position = tiles[i] - 1
        src.set( (tile_position % 6)*halfTileSrcWidth + anim,
           (tile_position / 6)*halfTileSrcHeight, halfTileSrcWidth, halfTileSrcHeight)
        if @diffsizes
          bitmap.stretch_blt(
             Rect.new(i%2*halfTileWidth+x,i/2*halfTileHeight+y,halfTileWidth,halfTileHeight),
             autotile,src)
        else
          bitmap.blt(i%2*halfTileWidth+x,i/2*halfTileHeight+y, autotile, src)
        end
      end
    end
  end

  def getAutotile(sprite,id)
    frames = @framecount[id/48-1]
    if frames<=1
      anim = 0
    else
      anim = (Graphics.frame_count/Animated_Autotiles_Frames)%frames
    end
    return if anim<0
    bitmap = @autotileInfo[id]
    if !bitmap
       bitmap = Bitmap.new(@tileWidth,@tileHeight)
       bltAutotile(bitmap,0,0,id,anim)
       @autotileInfo[id] = bitmap
    end
    sprite.bitmap = bitmap if sprite.bitmap!=bitmap
  end

  def getRegularTile(sprite,id)
    if @diffsizes
      bitmap = @regularTileInfo[id]
      if !bitmap
        bitmap = Bitmap.new(@tileWidth,@tileHeight)
        rect = Rect.new(((id - 384)&7)*@tileSrcWidth,((id - 384)>>3)*@tileSrcHeight,
           @tileSrcWidth,@tileSrcHeight)
        TileWrap::stretchBlitWrappedPixels(Rect.new(0,0,@tileWidth,@tileHeight), bitmap, @tileset, rect)
        @regularTileInfo[id] = bitmap
      end
      sprite.bitmap = bitmap if sprite.bitmap!=bitmap
    else
      sprite.bitmap = @tileset if sprite.bitmap!=@tileset
      rect = Rect.new(((id - 384)&7)*@tileSrcWidth,((id - 384)>>3)*@tileSrcHeight,
         @tileSrcWidth,@tileSrcHeight)
      rect = TileWrap::getWrappedRect(rect) if @shouldWrap
      sprite.src_rect = rect
    end
  end

  def addTile(tiles,count,xpos,ypos,id)
    terrain  = @terrain_tags[id]
    priority = @priorities[id]
    if id >= 384   # Tileset tile
      if count>=tiles.length
        sprite = CustomTilemapSprite.new(@viewport)
        tiles.push(sprite,0)
      else
        sprite = tiles[count]
        tiles[count+1] = 0
      end
      sprite.visible = @visible
      sprite.x       = xpos
      sprite.y       = ypos
      sprite.tone    = @tone
      sprite.color   = @color
      getRegularTile(sprite,id)
    else   # Autotile
      if count>=tiles.length
        sprite = CustomTilemapSprite.new(@viewport)
        tiles.push(sprite,1)
      else
        sprite = tiles[count]
        tiles[count+1] = 1
      end
      sprite.visible = @visible
      sprite.x       = xpos
      sprite.y       = ypos
      sprite.tone    = @tone
      sprite.color   = @color
      getAutotile(sprite,id)
    end
    terrain_tag_data = GameData::TerrainTag.try_get(terrain)
    if terrain_tag_data.shows_reflections
      spriteZ = -100
    elsif $PokemonGlobal.bridge > 0 && terrain_tag_data.bridge
      spriteZ = 1
    else
      spriteZ = (priority==0) ? 0 : ypos+priority*32+32
    end
    sprite.z = spriteZ
    count += 2
    return count
  end

  def refresh_flash
    if @flash_data && !@flash
      @flash = CustomTilemapSprite.new(viewport)
      @flash.visible    = true
      @flash.z          = 1
      @flash.tone       = tone
      @flash.color      = color
      @flash.blend_type = 1
      @flash.bitmap     = Bitmap.new([graphicsWidth*2,1].max,[graphicsHeight*2,1].max)
      @firsttimeflash = true
    elsif !@flash_data && @flash
      @flash.bitmap.dispose if @flash.bitmap
      @flash.dispose
      @flash = nil
      @firsttimeflash = false
    end
  end

  def refreshFlashSprite
    return if !@flash || @flash_data.nil?
    ptX = @ox-@oxFlash
    ptY = @oy-@oyFlash
    if !@firsttimeflash && !@usedsprites &&
       ptX>=0 && ptX+@viewport.rect.width<=@flash.bitmap.width &&
       ptY>=0 && ptY+@viewport.rect.height<=@flash.bitmap.height
      @flash.ox = 0
      @flash.oy = 0
      @flash.src_rect.set(ptX.round,ptY.round,
         @viewport.rect.width,@viewport.rect.height)
      return
    end
    width = @flash.bitmap.width
    height = @flash.bitmap.height
    bitmap = @flash.bitmap
    ysize = @map_data.ysize
    xsize = @map_data.xsize
    @firsttimeflash = false
    @oxFlash = @ox-(width>>2)
    @oyFlash = @oy-(height>>2)
    @flash.ox = 0
    @flash.oy = 0
    @flash.src_rect.set(width>>2,height>>2,
       @viewport.rect.width,@viewport.rect.height)
    @flash.bitmap.clear
    @oxFlash = @oxFlash.floor
    @oyFlash = @oyFlash.floor
    xStart = @oxFlash/@tileWidth
    xStart = 0 if xStart<0
    yStart = @oyFlash/@tileHeight
    yStart = 0 if yStart<0
    xEnd = xStart+(width/@tileWidth)+1
    yEnd = yStart+(height/@tileHeight)+1
    xEnd = xsize if xEnd>=xsize
    yEnd = ysize if yEnd>=ysize
    if xStart<xEnd && yStart<yEnd
      yrange = yStart...yEnd
      xrange = xStart...xEnd
      tmpcolor = Color.new(0,0,0,0)
      for y in yrange
        ypos = (y*@tileHeight)-@oyFlash
        for x in xrange
          xpos = (x*@tileWidth)-@oxFlash
          id = @flash_data[x, y, 0]
          r = (id>>8)&15
          g = (id>>4)&15
          b = (id)&15
          tmpcolor.set(r<<4,g<<4,b<<4)
          bitmap.fill_rect(xpos,ypos,@tileWidth,@tileHeight,tmpcolor)
        end
      end
    end
  end

  def refresh_tileset
    i = 0
    len = @regularTileInfo.length
    while i < len
      if @regularTileInfo[i]
        @regularTileInfo[i].dispose
        @regularTileInfo[i] = nil
      end
      i += 1
    end
    @regularTileInfo.clear
    @priotiles.clear
    ysize = @map_data.ysize
    xsize = @map_data.xsize
    zsize = @map_data.zsize
    if xsize > 100 || ysize > 100
      @fullyrefreshed = false
    else
      for z in 0...zsize
        for y in 0...ysize
          for x in 0...xsize
            id = @map_data[x, y, z]
            next if id == 0
            next if @priorities[id] == 0 && !GameData::TerrainTag.try_get(@terrain_tags[id]).shows_reflections
            @priotiles[[x, y]] = [] if !@priotiles[[x, y]]
            @priotiles[[x, y]].push([z, id])
          end
        end
      end
      @fullyrefreshed = true
    end
  end

  def refresh_autotiles
    i = 0
    len = @autotileInfo.length
    while i < len
      if @autotileInfo[i]
        @autotileInfo[i].dispose
        @autotileInfo[i] = nil
      end
      i += 1
    end
    i = 0
    len = @autosprites.length
    while i < len
      if @autosprites[i]
        @autosprites[i].dispose
        @autosprites[i] = nil
      end
      i += 2
    end
    @autosprites.clear
    @autotileInfo.clear
    @prioautotiles.clear
    @priorect = nil
    @priorectautos = nil
    hasanimated = false
    for i in 0...7
      numframes = autotileNumFrames(48 * (i + 1))
      hasanimated = true if numframes >= 2
      @framecount[i] = numframes
    end
    if hasanimated
      ysize = @map_data.ysize
      xsize = @map_data.xsize
      zsize = @map_data.zsize
      if xsize > 100 || ysize > 100
        @fullyrefreshedautos = false
      else
        for y in 0...ysize
          for x in 0...xsize
            for z in 0...zsize
              id = @map_data[x, y, z]
              next if id == 0 || id >= 384   # Skip non-autotiles
              next if @priorities[id] != 0 || GameData::TerrainTag.try_get(@terrain_tags[id]).shows_reflections
              next if @framecount[id / 48 - 1] < 2
              @prioautotiles[[x, y]] = true
              break
            end
          end
        end
        @fullyrefreshedautos = true
      end
    else
      @fullyrefreshedautos = true
    end
  end

  def refreshLayer0(autotiles = false)
    return true if autotiles && !shown?
    ptX = @ox - @oxLayer0
    ptY = @oy - @oyLayer0
    if !autotiles && !@firsttime && !@usedsprites &&
       ptX >= 0 && ptX + @viewport.rect.width <= @layer0.bitmap.width &&
       ptY >= 0 && ptY + @viewport.rect.height <= @layer0.bitmap.height
      if @layer0clip && @viewport.ox == 0 && @viewport.oy == 0
        @layer0.ox = 0
        @layer0.oy = 0
        @layer0.src_rect.set(ptX.round, ptY.round, @viewport.rect.width, @viewport.rect.height)
      else
        @layer0.ox = ptX.round
        @layer0.oy = ptY.round
        @layer0.src_rect.set(0, 0, @layer0.bitmap.width, @layer0.bitmap.height)
      end
      return true
    end
    width  = @layer0.bitmap.width
    height = @layer0.bitmap.height
    bitmap = @layer0.bitmap
    ysize = @map_data.ysize
    xsize = @map_data.xsize
    zsize = @map_data.zsize
    twidth  = @tileWidth
    theight = @tileHeight
    mapdata = @map_data
    if autotiles
      return true if @fullyrefreshedautos && @prioautotiles.length == 0
      xStart = @oxLayer0 / twidth
      xStart = 0 if xStart < 0
      yStart = @oyLayer0 / theight
      yStart = 0 if yStart < 0
      xEnd = xStart + (width / twidth) + 1
      xEnd = xsize if xEnd > xsize
      yEnd = yStart + (height / theight) + 1
      yEnd = ysize if yEnd > ysize
      return true if xStart >= xEnd || yStart >= yEnd
      trans = Color.new(0, 0, 0, 0)
      temprect = Rect.new(0, 0, 0, 0)
      tilerect = Rect.new(0, 0, twidth, theight)
      zrange = 0...zsize
      overallcount = 0
      count = 0
      if !@fullyrefreshedautos
        for y in yStart..yEnd
          for x in xStart..xEnd
            for z in zrange
              id = mapdata[x, y, z]
              next if !id || id < 48 || id >= 384   # Skip non-autotiles
              prioid = @priorities[id]
              next if prioid != 0 || GameData::TerrainTag.try_get(@terrain_tags[id]).shows_reflections
              fcount = @framecount[id / 48 - 1]
              next if !fcount || fcount < 2
              overallcount += 1
              xpos = (x * twidth) - @oxLayer0
              ypos = (y * theight) - @oyLayer0
              bitmap.fill_rect(xpos, ypos, twidth, theight, trans) if overallcount <= 2000
              break
            end
            for z in zrange
              id = mapdata[x, y, z]
              next if !id || id < 48
              prioid = @priorities[id]
              next if prioid != 0 || GameData::TerrainTag.try_get(@terrain_tags[id]).shows_reflections
              if overallcount > 2000
                xpos = (x * twidth) - @oxLayer0
                ypos = (y * theight) - @oyLayer0
                count = addTile(@autosprites, count, xpos, ypos, id)
              elsif id >= 384   # Tileset tiles
                temprect.set(((id - 384) & 7) * @tileSrcWidth,
                             ((id - 384) >> 3) * @tileSrcHeight,
                             @tileSrcWidth, @tileSrcHeight)
                xpos = (x * twidth) - @oxLayer0
                ypos = (y * theight) - @oyLayer0
                if @diffsizes
                  TileWrap::stretchBlitWrappedPixels(Rect.new(xpos, ypos, twidth, theight), bitmap, @tileset, temprect)
                else
                  TileWrap::blitWrappedPixels(xpos,ypos, bitmap, @tileset, temprect)
                end
              else   # Autotiles
                tilebitmap = @autotileInfo[id]
                if !tilebitmap
                  anim = autotileFrame(id)
                  next if anim < 0
                  tilebitmap = Bitmap.new(twidth, theight)
                  bltAutotile(tilebitmap, 0, 0, id, anim)
                  @autotileInfo[id] = tilebitmap
                end
                xpos = (x * twidth) - @oxLayer0
                ypos = (y * theight) - @oyLayer0
                bitmap.blt(xpos, ypos, tilebitmap, tilerect)
              end
            end
          end
        end
        Graphics.frame_reset
      else
        if !@priorect || !@priorectautos ||
           @priorect[0] != xStart || @priorect[1] != yStart ||
           @priorect[2] != xEnd || @priorect[3] != yEnd
          @priorect = [xStart, yStart, xEnd, yEnd]
          @priorectautos = []
          for y in yStart..yEnd
            for x in xStart..xEnd
              @priorectautos.push([x, y]) if @prioautotiles[[x, y]]
            end
          end
        end
        for tile in @priorectautos
          x = tile[0]
          y = tile[1]
          overallcount += 1
          xpos = (x * twidth) - @oxLayer0
          ypos = (y * theight) - @oyLayer0
          bitmap.fill_rect(xpos, ypos, twidth, theight, trans)
          z = 0
          while z < zsize
            id = mapdata[x, y, z]
            z += 1
            next if !id || id < 48
            prioid = @priorities[id]
            next if prioid != 0 || GameData::TerrainTag.try_get(@terrain_tags[id]).shows_reflections
            if id >= 384   # Tileset tiles
              temprect.set(((id - 384) & 7) * @tileSrcWidth,
                           ((id - 384) >> 3) * @tileSrcHeight,
                           @tileSrcWidth, @tileSrcHeight)
              if @diffsizes
                TileWrap::stretchBlitWrappedPixels(Rect.new(xpos, ypos, twidth, theight), bitmap, @tileset, temprect)
              else
                TileWrap::blitWrappedPixels(xpos,ypos, bitmap, @tileset, temprect)
              end
            else   # Autotiles
              tilebitmap = @autotileInfo[id]
              if !tilebitmap
                anim = autotileFrame(id)
                next if anim < 0
                tilebitmap = Bitmap.new(twidth, theight)
                bltAutotile(tilebitmap, 0, 0, id, anim)
                @autotileInfo[id] = tilebitmap
              end
              bitmap.blt(xpos, ypos, tilebitmap, tilerect)
            end
          end
        end
        Graphics.frame_reset if overallcount > 500
      end
      @usedsprites = false
      return true
    end
    return false if @usedsprites
    @firsttime = false
    @oxLayer0 = @ox - (width >> 2)
    @oyLayer0 = @oy - (height >> 2)
    if @layer0clip
      @layer0.ox = 0
      @layer0.oy = 0
      @layer0.src_rect.set(width >> 2, height >> 2, @viewport.rect.width, @viewport.rect.height)
    else
      @layer0.ox = (width >> 2)
      @layer0.oy = (height >> 2)
    end
    @layer0.bitmap.clear
    @oxLayer0 = @oxLayer0.round
    @oyLayer0 = @oyLayer0.round
    xStart = @oxLayer0 / twidth
    xStart = 0 if xStart < 0
    yStart = @oyLayer0 / theight
    yStart = 0 if yStart < 0
    xEnd = xStart + (width / twidth) + 1
    xEnd = xsize if xEnd >= xsize
    yEnd = yStart + (height / theight) + 1
    yEnd = ysize if yEnd >= ysize
    if xStart < xEnd && yStart < yEnd
      tmprect = Rect.new(0, 0, 0, 0)
      yrange = yStart...yEnd
      xrange = xStart...xEnd
      for z in 0...zsize
        for y in yrange
          ypos = (y * theight) - @oyLayer0
          for x in xrange
            xpos = (x * twidth) - @oxLayer0
            id = mapdata[x, y, z]
            next if id == 0 || @priorities[id] != 0 || GameData::TerrainTag.try_get(@terrain_tags[id]).shows_reflections
            if id >= 384   # Tileset tiles
              tmprect.set(((id - 384) & 7) * @tileSrcWidth,
                          ((id - 384) >> 3) * @tileSrcHeight,
                          @tileSrcWidth, @tileSrcHeight)
              if @diffsizes
                TileWrap::stretchBlitWrappedPixels(Rect.new(xpos, ypos, twidth, theight), bitmap, @tileset, tmprect)
              else
                TileWrap::blitWrappedPixels(xpos,ypos, bitmap, @tileset, tmprect)
              end
            else   # Autotiles
              frames = @framecount[id / 48 - 1]
              if frames <= 1
                frame = 0
              else
                frame = (Graphics.frame_count / Animated_Autotiles_Frames) % frames
              end
              bltAutotile(bitmap, xpos, ypos, id, frame)
            end
          end
        end
      end
      Graphics.frame_reset
    end
    return true
  end

  def refresh(autotiles = false)
    @oldOx = @ox
    @oldOy = @oy
    usesprites = false
    if @layer0
      @layer0.visible = @visible
      usesprites = !refreshLayer0(autotiles)
      return if autotiles && !usesprites
    else
      usesprites = true
    end
    refreshFlashSprite
    xsize = @map_data.xsize
    ysize = @map_data.ysize
    minX = (@ox / @tileWidth) - 1
    minX = minX.clamp(0, xsize - 1)
    maxX = ((@ox + @viewport.rect.width) / @tileWidth) + 1
    maxX = maxX.clamp(0, xsize - 1)
    minY = (@oy / @tileHeight) - 1
    minY = minY.clamp(0, ysize - 1)
    maxY = ((@oy + @viewport.rect.height) / @tileHeight) + 1
    maxY = maxY.clamp(0, ysize - 1)
    count = 0
    if minX < maxX && minY < maxY
      @usedsprites = usesprites || @usedsprites
      @layer0.visible = false if usesprites && @layer0
      if !@priotilesrect || !@priotilesfast ||
         @priotilesrect[0] != minX || @priotilesrect[1] != minY ||
         @priotilesrect[2] != maxX || @priotilesrect[3] != maxY
        @priotilesrect = [minX, minY, maxX, maxY]
        @priotilesfast = []
        if @fullyrefreshed
          for y in minY..maxY
            for x in minX..maxX
              next if !@priotiles[[x, y]]
              @priotiles[[x, y]].each { |tile| @priotilesfast.push([x, y, tile[0], tile[1]]) }
            end
          end
        else
          for z in 0...@map_data.zsize
            for y in minY..maxY
              for x in minX..maxX
                id = @map_data[x, y, z]
                next if id == 0
                next if @priorities[id] == 0 && !GameData::TerrainTag.try_get(@terrain_tags[id]).shows_reflections
                @priotilesfast.push([x, y, z, id])
              end
            end
          end
        end
      end
      for prio in @priotilesfast
        xpos = (prio[0] * @tileWidth) - @ox
        ypos = (prio[1] * @tileHeight) - @oy
        count = addTile(@tiles, count, xpos, ypos, prio[3])
      end
    end
    if count < @tiles.length
      bigchange = (count <= (@tiles.length * 2 / 3)) && @tiles.length > 40
      j = count
      len = @tiles.length
      while j < len
        sprite = @tiles[j]
        @tiles[j + 1] = -1
        if bigchange
          sprite.dispose
          @tiles[j] = nil
          @tiles[j + 1] = nil
        elsif !@tiles[j].disposed?
          sprite.visible = false if sprite.visible
        end
        j += 2
      end
      @tiles.compact! if bigchange
    end
  end

  def update
    if @haveGraphicsWH
      @graphicsWidth  = Graphics.width
      @graphicsHeight = Graphics.height
    end
    # Update tone
    if @oldtone != @tone
      @layer0.tone = @tone
      @flash.tone  = @tone if @flash
      for sprite in @autosprites
        sprite.tone = @tone if sprite.is_a?(Sprite)
      end
      for sprite in @tiles
        sprite.tone = @tone if sprite.is_a?(Sprite)
      end
      @oldtone = @tone.clone
    end
    # Update color
    if @oldcolor != @color
      @layer0.color = @color
      @flash.color  = @color if @flash
      for sprite in @autosprites
        sprite.color = @color if sprite.is_a?(Sprite)
      end
      for sprite in @tiles
        sprite.color = @color if sprite.is_a?(Sprite)
      end
      @oldcolor = @color.clone
    end
    # Refresh anything that has changed
    if @autotiles.changed
      refresh_autotiles
      repaintAutotiles
    end
    refresh_flash if @flashChanged
    refresh_tileset if @tilesetChanged
    @flash.opacity = FlashOpacity[(Graphics.frame_count / 2) % 6] if @flash
    mustrefresh = (@oldOx != @ox || @oldOy != @oy || @tilesetChanged || @autotiles.changed)
    if @viewport.ox != @oldViewportOx || @viewport.oy != @oldViewportOy
      mustrefresh = true
      @oldViewportOx = @viewport.ox
      @oldViewportOy = @viewport.oy
    end
    refresh if mustrefresh
    if (Graphics.frame_count % Animated_Autotiles_Frames) == 0 || @nowshown
      repaintAutotiles
      refresh(true)
    end
    @nowshown          = false
    @autotiles.changed = false
    @tilesetChanged    = false
  end
end


#===============================================================================
# Script Page: ==================
#===============================================================================


#===============================================================================
# Script Page: [[ Compiler ]]
#===============================================================================


#===============================================================================
# Script Page: Compiler
#===============================================================================
#===============================================================================
# Records which file, section and line are currently being read
#===============================================================================
module FileLineData
    @file     = ""
    @linedata = ""
    @lineno   = 0
    @section  = nil
    @key      = nil
    @value    = nil
  
    def self.file; return @file; end
    def self.file=(value); @file = value; end
  
    def self.clear
      @file     = ""
      @linedata = ""
      @lineno   = ""
      @section  = nil
      @key      = nil
      @value    = nil
    end
  
    def self.setSection(section,key,value)
      @section = section
      @key     = key
      if value && value.length>200
        @value = _INTL("{1}...",value[0,200])
      else
        @value = (value) ? value.clone : ""
      end
    end
  
    def self.setLine(line,lineno)
      @section  = nil
      @linedata = (line && line.length>200) ? sprintf("%s...",line[0,200]) : line.clone
      @lineno   = lineno
    end
  
    def self.linereport
      if @section
        if @key!=nil
          return _INTL("File {1}, section {2}, key {3}\r\n{4}\r\n\r\n",@file,@section,@key,@value)
        else
          return _INTL("File {1}, section {2}\r\n{3}\r\n\r\n",@file,@section,@value)
        end
      else
        return _INTL("File {1}, line {2}\r\n{3}\r\n\r\n",@file,@lineno,@linedata)
      end
    end
  end
  
#===============================================================================
# Compiler
#===============================================================================
module Compiler
    module_function
  
    def findIndex(a)
      index = -1
      count = 0
      a.each { |i|
        if yield i
          index = count
          break
        end
        count += 1
      }
      return index
    end
  
    def prepline(line)
      line.sub!(/\s*\#.*$/,"")
      line.sub!(/^\s+/,"")
      line.sub!(/\s+$/,"")
      return line
    end
  
    def csvQuote(str,always=false)
      return "" if nil_or_empty?(str)
      if always || str[/[,\"]/]   # || str[/^\s/] || str[/\s$/] || str[/^#/]
        str = str.gsub(/[\"]/,"\\\"")
        str = "\"#{str}\""
      end
      return str
    end
  
    def csvQuoteAlways(str)
      return csvQuote(str,true)
    end
  
    #=============================================================================
    # PBS file readers
    #=============================================================================
    def pbEachFileSectionEx(f)
      lineno      = 1
      havesection = false
      sectionname = nil
      lastsection = {}
      f.each_line { |line|
        if lineno==1 && line[0].ord==0xEF && line[1].ord==0xBB && line[2].ord==0xBF
          line = line[3,line.length-3]
        end
        if !line[/^\#/] && !line[/^\s*$/]
          if line[/^\s*\[\s*(.*)\s*\]\s*$/]   # Of the format: [something]
            yield lastsection,sectionname if havesection
            sectionname = $~[1]
            havesection = true
            lastsection = {}
          else
            if sectionname==nil
              FileLineData.setLine(line,lineno)
              raise _INTL("Expected a section at the beginning of the file. This error may also occur if the file was not saved in UTF-8.\r\n{1}",FileLineData.linereport)
            end
            if !line[/^\s*(\w+)\s*=\s*(.*)$/]
              FileLineData.setSection(sectionname,nil,line)
              raise _INTL("Bad line syntax (expected syntax like XXX=YYY)\r\n{1}",FileLineData.linereport)
            end
            r1 = $~[1]
            r2 = $~[2]
            lastsection[r1] = r2.gsub(/\s+$/,"")
          end
        end
        lineno += 1
        Graphics.update if lineno%200==0
        pbSetWindowText(_INTL("Processing {1} line {2}",FileLineData.file,lineno)) if lineno%50==0
      }
      yield lastsection,sectionname if havesection
    end
  
    # Used for types.txt, pokemon.txt, metadata.txt
    def pbEachFileSection(f)
      pbEachFileSectionEx(f) { |section,name|
        yield section,name.to_i if block_given? && name[/^\d+$/]
      }
    end
  
    # Used for pokemonforms.txt
    def pbEachFileSection2(f)
      pbEachFileSectionEx(f) { |section,name|
        yield section,name if block_given? && name[/^\w+[-,\s]{1}\d+$/]
      }
    end
    
    # Used for pokemon_metrics.txt
    def pbEachFileSection3(f)
      pbEachFileSectionEx(f) { |section, name|
        yield section, name if block_given? && name[/^.+$/]
      }
    end
  
    # Used for phone.txt
    def pbEachSection(f)
      lineno      = 1
      havesection = false
      sectionname = nil
      lastsection = []
      f.each_line { |line|
        if lineno==1 && line[0].ord==0xEF && line[1].ord==0xBB && line[2].ord==0xBF
          line = line[3,line.length-3]
        end
        if !line[/^\#/] && !line[/^\s*$/]
          if line[/^\s*\[\s*(.+?)\s*\]\s*$/]
            yield lastsection,sectionname  if havesection
            sectionname = $~[1]
            lastsection = []
            havesection = true
          else
            if sectionname==nil
              raise _INTL("Expected a section at the beginning of the file (line {1}). Sections begin with '[name of section]'",lineno)
            end
            lastsection.push(line.gsub(/^\s+/,"").gsub(/\s+$/,""))
          end
        end
        lineno += 1
        Graphics.update if lineno%500==0
      }
      yield lastsection,sectionname  if havesection
    end
  
    # Unused
    def pbEachCommentedLine(f)
      lineno = 1
      f.each_line { |line|
        if lineno==1 && line[0].ord==0xEF && line[1].ord==0xBB && line[2].ord==0xBF
          line = line[3,line.length-3]
        end
        yield line, lineno if !line[/^\#/] && !line[/^\s*$/]
        lineno += 1
      }
    end
  
    # Used for many PBS files
    def pbCompilerEachCommentedLine(filename)
      File.open(filename,"rb") { |f|
        FileLineData.file = filename
        lineno = 1
        f.each_line { |line|
          if lineno==1 && line[0].ord==0xEF && line[1].ord==0xBB && line[2].ord==0xBF
            line = line[3,line.length-3]
          end
          if !line[/^\#/] && !line[/^\s*$/]
            FileLineData.setLine(line,lineno)
            yield line, lineno
          end
          lineno += 1
        }
      }
    end
  
    # Unused
    def pbEachPreppedLine(f)
      lineno = 1
      f.each_line { |line|
        if lineno==1 && line[0].ord==0xEF && line[1].ord==0xBB && line[2].ord==0xBF
          line = line[3,line.length-3]
        end
        line = prepline(line)
        yield line, lineno if !line[/^\#/] && !line[/^\s*$/]
        lineno += 1
      }
    end
  
    # Used for connections.txt, abilities.txt, moves.txt, regionaldexes.txt
    def pbCompilerEachPreppedLine(filename)
      File.open(filename,"rb") { |f|
        FileLineData.file = filename
        lineno = 1
        f.each_line { |line|
          if lineno==1 && line[0].ord==0xEF && line[1].ord==0xBB && line[2].ord==0xBF
            line = line[3,line.length-3]
          end
          line = prepline(line)
          if !line[/^\#/] && !line[/^\s*$/]
            FileLineData.setLine(line,lineno)
            yield line, lineno
          end
          lineno += 1
        }
      }
    end
  
    #=============================================================================
    # Convert a string to certain kinds of values
    #=============================================================================
    def csvfield!(str)
      ret = ""
      str.sub!(/^\s*/,"")
      if str[0,1]=="\""
        str[0,1] = ""
        escaped = false
        fieldbytes = 0
        str.scan(/./) do |s|
          fieldbytes += s.length
          break if s=="\"" && !escaped
          if s=="\\" && !escaped
            escaped = true
          else
            ret += s
            escaped = false
          end
        end
        str[0,fieldbytes] = ""
        if !str[/^\s*,/] && !str[/^\s*$/]
          raise _INTL("Invalid quoted field (in: {1})\r\n{2}",str,FileLineData.linereport)
        end
        str[0,str.length] = $~.post_match
      else
        if str[/,/]
          str[0,str.length] = $~.post_match
          ret = $~.pre_match
        else
          ret = str.clone
          str[0,str.length] = ""
        end
        ret.gsub!(/\s+$/,"")
      end
      return ret
    end
  
    def csvBoolean!(str,_line=-1)
      field = csvfield!(str)
      if field[/^1|[Tt][Rr][Uu][Ee]|[Yy][Ee][Ss]|[Yy]$/]
        return true
      elsif field[/^0|[Ff][Aa][Ll][Ss][Ee]|[Nn][Oo]|[Nn]$/]
        return false
      end
      raise _INTL("Field {1} is not a Boolean value (true, false, 1, 0)\r\n{2}",field,FileLineData.linereport)
    end
  
    def csvInt!(str,_line=-1)
      ret = csvfield!(str)
      if !ret[/^\-?\d+$/]
        raise _INTL("Field {1} is not an integer\r\n{2}",ret,FileLineData.linereport)
      end
      return ret.to_i
    end
  
    def csvPosInt!(str,_line=-1)
      ret = csvfield!(str)
      if !ret[/^\d+$/]
        raise _INTL("Field {1} is not a positive integer\r\n{2}",ret,FileLineData.linereport)
      end
      return ret.to_i
    end
  
    def csvFloat!(str,_line=-1)
      ret = csvfield!(str)
      return Float(ret) rescue raise _INTL("Field {1} is not a number\r\n{2}",ret,FileLineData.linereport)
    end
  
    def csvEnumField!(value,enumer,_key,_section)
      ret = csvfield!(value)
      return checkEnumField(ret,enumer)
    end
  
    def csvEnumFieldOrInt!(value,enumer,_key,_section)
      ret = csvfield!(value)
      return ret.to_i if ret[/\-?\d+/]
      return checkEnumField(ret,enumer)
    end
  
    def checkEnumField(ret,enumer)
      if enumer.is_a?(Module)
        begin
          if nil_or_empty?(ret) || !enumer.const_defined?(ret)
            raise _INTL("Undefined value {1} in {2}\r\n{3}",ret,enumer.name,FileLineData.linereport)
          end
        rescue NameError
          raise _INTL("Incorrect value {1} in {2}\r\n{3}",ret,enumer.name,FileLineData.linereport)
        end
        return enumer.const_get(ret.to_sym)
      elsif enumer.is_a?(Symbol) || enumer.is_a?(String)
        if !Kernel.const_defined?(enumer.to_sym) && GameData.const_defined?(enumer.to_sym)
          enumer = GameData.const_get(enumer.to_sym)
          begin
            if nil_or_empty?(ret) || !enumer.exists?(ret.to_sym)
              raise _INTL("Undefined value {1} in {2}\r\n{3}", ret, enumer.name, FileLineData.linereport)
            end
          rescue NameError
            raise _INTL("Incorrect value {1} in {2}\r\n{3}", ret, enumer.name, FileLineData.linereport)
          end
          return ret.to_sym
        end
        enumer = Object.const_get(enumer.to_sym)
        begin
          if nil_or_empty?(ret) || !enumer.const_defined?(ret)
            raise _INTL("Undefined value {1} in {2}\r\n{3}",ret,enumer.name,FileLineData.linereport)
          end
        rescue NameError
          raise _INTL("Incorrect value {1} in {2}\r\n{3}",ret,enumer.name,FileLineData.linereport)
        end
        return enumer.const_get(ret.to_sym)
      elsif enumer.is_a?(Array)
        idx = findIndex(enumer) { |item| ret==item }
        if idx<0
          raise _INTL("Undefined value {1} (expected one of: {2})\r\n{3}",ret,enumer.inspect,FileLineData.linereport)
        end
        return idx
      elsif enumer.is_a?(Hash)
        value = enumer[ret]
        if value==nil
          raise _INTL("Undefined value {1} (expected one of: {2})\r\n{3}",ret,enumer.keys.inspect,FileLineData.linereport)
        end
        return value
      end
      raise _INTL("Enumeration not defined\r\n{1}",FileLineData.linereport)
    end
  
    def checkEnumFieldOrNil(ret,enumer)
      if enumer.is_a?(Module)
        return nil if nil_or_empty?(ret) || !(enumer.const_defined?(ret) rescue false)
        return enumer.const_get(ret.to_sym)
      elsif enumer.is_a?(Symbol) || enumer.is_a?(String)
        if GameData.const_defined?(enumer.to_sym)
          enumer = GameData.const_get(enumer.to_sym)
          return nil if nil_or_empty?(ret) || !enumer.exists?(ret.to_sym)
          return ret.to_sym
        end
        enumer = Object.const_get(enumer.to_sym)
        return nil if nil_or_empty?(ret) || !(enumer.const_defined?(ret) rescue false)
        return enumer.const_get(ret.to_sym)
      elsif enumer.is_a?(Array)
        idx = findIndex(enumer) { |item| ret==item }
        return nil if idx<0
        return idx
      elsif enumer.is_a?(Hash)
        return enumer[ret]
      end
      return nil
    end
  
    #=============================================================================
    # Convert a string to values using a schema
    #=============================================================================
    def pbGetCsvRecord(rec,lineno,schema)
      record = []
      repeat = false
      start = 0
      if schema[1][0,1]=="*"
        repeat = true
        start = 1
      end
      begin
        for i in start...schema[1].length
          chr = schema[1][i,1]
          case chr
          when "i"   # Integer
            record.push(csvInt!(rec,lineno))
          when "I"   # Optional integer
            field = csvfield!(rec)
            if nil_or_empty?(field)
              record.push(nil)
            elsif !field[/^\-?\d+$/]
              raise _INTL("Field {1} is not an integer\r\n{2}",field,FileLineData.linereport)
            else
              record.push(field.to_i)
            end
          when "u"   # Positive integer or zero
            record.push(csvPosInt!(rec,lineno))
          when "U"   # Optional positive integer or zero
            field = csvfield!(rec)
            if nil_or_empty?(field)
              record.push(nil)
            elsif !field[/^\d+$/]
              raise _INTL("Field '{1}' must be 0 or greater\r\n{2}",field,FileLineData.linereport)
            else
              record.push(field.to_i)
            end
          when "v"   # Positive integer
            field = csvPosInt!(rec,lineno)
            raise _INTL("Field '{1}' must be greater than 0\r\n{2}",field,FileLineData.linereport) if field==0
            record.push(field)
          when "V"   # Optional positive integer
            field = csvfield!(rec)
            if nil_or_empty?(field)
              record.push(nil)
            elsif !field[/^\d+$/]
              raise _INTL("Field '{1}' must be greater than 0\r\n{2}",field,FileLineData.linereport)
            elsif field.to_i==0
              raise _INTL("Field '{1}' must be greater than 0\r\n{2}",field,FileLineData.linereport)
            else
              record.push(field.to_i)
            end
          when "x"   # Hexadecimal number
            field = csvfield!(rec)
            if !field[/^[A-Fa-f0-9]+$/]
              raise _INTL("Field '{1}' is not a hexadecimal number\r\n{2}",field,FileLineData.linereport)
            end
            record.push(field.hex)
          when "X"   # Optional hexadecimal number
            field = csvfield!(rec)
            if nil_or_empty?(field)
              record.push(nil)
            elsif !field[/^[A-Fa-f0-9]+$/]
              raise _INTL("Field '{1}' is not a hexadecimal number\r\n{2}",field,FileLineData.linereport)
            else
              record.push(field.hex)
            end
          when "f"   # Floating point number
            record.push(csvFloat!(rec,lineno))
          when "F"   # Optional floating point number
            field = csvfield!(rec)
            if nil_or_empty?(field)
              record.push(nil)
            elsif !field[/^\-?^\d*\.?\d*$/]
              raise _INTL("Field {1} is not a floating point number\r\n{2}",field,FileLineData.linereport)
            else
              record.push(field.to_f)
            end
          when "b"   # Boolean
            record.push(csvBoolean!(rec,lineno))
          when "B"   # Optional Boolean
            field = csvfield!(rec)
            if nil_or_empty?(field)
              record.push(nil)
            elsif field[/^1|[Tt][Rr][Uu][Ee]|[Yy][Ee][Ss]|[Tt]|[Yy]$/]
              record.push(true)
            else
              record.push(false)
            end
          when "n"   # Name
            field = csvfield!(rec)
            if !field[/^(?![0-9])\w+$/]
              raise _INTL("Field '{1}' must contain only letters, digits, and\r\nunderscores and can't begin with a number.\r\n{2}",field,FileLineData.linereport)
            end
            record.push(field)
          when "N"   # Optional name
            field = csvfield!(rec)
            if nil_or_empty?(field)
              record.push(nil)
            elsif !field[/^(?![0-9])\w+$/]
              raise _INTL("Field '{1}' must contain only letters, digits, and\r\nunderscores and can't begin with a number.\r\n{2}",field,FileLineData.linereport)
            else
              record.push(field)
            end
          when "s"   # String
            record.push(csvfield!(rec))
          when "S"   # Optional string
            field = csvfield!(rec)
            record.push((nil_or_empty?(field)) ? nil : field)
          when "q"   # Unformatted text
            record.push(rec)
            rec = ""
          when "Q"   # Optional unformatted text
            if nil_or_empty?(rec)
              record.push(nil)
            else
              record.push(rec)
              rec = ""
            end
          when "e"   # Enumerable
            record.push(csvEnumField!(rec,schema[2+i-start],"",FileLineData.linereport))
          when "E"   # Optional enumerable
            field = csvfield!(rec)
            record.push(checkEnumFieldOrNil(field,schema[2+i-start]))
          when "y"   # Enumerable or integer
            field = csvfield!(rec)
            record.push(csvEnumFieldOrInt!(field,schema[2+i-start],"",FileLineData.linereport))
          when "Y"   # Optional enumerable or integer
            field = csvfield!(rec)
            if nil_or_empty?(field)
              record.push(nil)
            elsif field[/^\-?\d+$/]
              record.push(field.to_i)
            else
              record.push(checkEnumFieldOrNil(field,schema[2+i-start]))
            end
          end
        end
        break if repeat && nil_or_empty?(rec)
      end while repeat
      return (schema[1].length==1) ? record[0] : record
    end
  
    #=============================================================================
    # Write values to a file using a schema
    #=============================================================================
    def pbWriteCsvRecord(record,file,schema)
      rec = (record.is_a?(Array)) ? record.clone : [record]
      for i in 0...schema[1].length
        chr = schema[1][i,1]
        file.write(",") if i>0
        if rec[i].nil?
          # do nothing
        elsif rec[i].is_a?(String)
          file.write(csvQuote(rec[i]))
        elsif rec[i].is_a?(Symbol)
          file.write(csvQuote(rec[i].to_s))
        elsif rec[i]==true
          file.write("true")
        elsif rec[i]==false
          file.write("false")
        elsif rec[i].is_a?(Numeric)
          case chr
          when "e", "E"   # Enumerable
            enumer = schema[2+i]
            if enumer.is_a?(Array)
              file.write(enumer[rec[i]])
            elsif enumer.is_a?(Symbol) || enumer.is_a?(String)
              mod = Object.const_get(enumer.to_sym)
              file.write(getConstantName(mod,rec[i]))
            elsif enumer.is_a?(Module)
              file.write(getConstantName(enumer,rec[i]))
            elsif enumer.is_a?(Hash)
              for key in enumer.keys
                if enumer[key]==rec[i]
                  file.write(key)
                  break
                end
              end
            end
          when "y", "Y"   # Enumerable or integer
            enumer = schema[2+i]
            if enumer.is_a?(Array)
              if enumer[rec[i]]!=nil
                file.write(enumer[rec[i]])
              else
                file.write(rec[i])
              end
            elsif enumer.is_a?(Symbol) || enumer.is_a?(String)
              mod = Object.const_get(enumer.to_sym)
              file.write(getConstantNameOrValue(mod,rec[i]))
            elsif enumer.is_a?(Module)
              file.write(getConstantNameOrValue(enumer,rec[i]))
            elsif enumer.is_a?(Hash)
              hasenum = false
              for key in enumer.keys
                if enumer[key]==rec[i]
                  file.write(key)
                  hasenum = true; break
                end
              end
              file.write(rec[i]) unless hasenum
            end
          else   # Any other record type
            file.write(rec[i].inspect)
          end
        else
          file.write(rec[i].inspect)
        end
      end
      return record
    end
  
    #=============================================================================
    # Parse string into a likely constant name and return its ID number (if any).
    # Last ditch attempt to figure out whether a constant is defined.
    #=============================================================================
    def pbGetConst(mod,item,err)
      isDef = false
      begin
        mod = Object.const_get(mod) if mod.is_a?(Symbol)
        isDef = mod.const_defined?(item.to_sym)
      rescue
        raise sprintf(err,item)
      end
      raise sprintf(err,item) if !isDef
      return mod.const_get(item.to_sym)
    end
  
    def parseItem(item)
      clonitem = item.upcase
      clonitem.sub!(/^\s*/, "")
      clonitem.sub!(/\s*$/, "")
      itm = GameData::Item.try_get(clonitem)
      if !itm
        raise _INTL("Undefined item constant name: {1}\r\nMake sure the item is defined in PBS/items.txt.\r\n{2}", item, FileLineData.linereport)
      end
      return itm.id
    end
  
    def parseSpecies(species)
      clonspecies = species.upcase
      clonspecies.gsub!(/^\s*/, "")
      clonspecies.gsub!(/\s*$/, "")
      clonspecies = "NIDORANmA" if clonspecies == "NIDORANMA"
      clonspecies = "NIDORANfE" if clonspecies == "NIDORANFE"
      spec = GameData::Species.try_get(clonspecies)
      if !spec
        raise _INTL("Undefined species constant name: {1}\r\nMake sure the species is defined in PBS/pokemon.txt.\r\n{2}", species, FileLineData.linereport)
      end
      return spec.id
    end
  
    def parseMove(move, skip_unknown = false)
      clonmove = move.upcase
      clonmove.sub!(/^\s*/, "")
      clonmove.sub!(/\s*$/, "")
      mov = GameData::Move.try_get(clonmove)
      if !mov
        return nil if skip_unknown
        raise _INTL("Undefined move constant name: {1}\r\nMake sure the move is defined in PBS/moves.txt.\r\n{2}", move, FileLineData.linereport)
      end
      return mov.id
    end
  
    # Unused
    def parseNature(nature)
      clonnature = nature.upcase
      clonnature.sub!(/^\s*/, "")
      clonnature.sub!(/\s*$/, "")
      nat = GameData::Nature.try_get(clonnature)
      if !nat
        raise _INTL("Undefined nature constant name: {1}\r\nMake sure the nature is defined in the scripts.\r\n{2}", nature, FileLineData.linereport)
      end
      return nat.id
    end
  
    # Unused
    def parseTrainer(type)
      clontype = type.clone
      clontype.sub!(/^\s*/, "")
      clontype.sub!(/\s*$/, "")
      typ = GameData::TrainerType.try_get(clontype)
      if !typ
        raise _INTL("Undefined Trainer type constant name: {1}\r\nMake sure the trainer type is defined in PBS/trainertypes.txt.\r\n{2}", type, FileLineData.linereport)
      end
      return typ.id
    end
    
    def add_PBS_header_to_file(file)
      file.write(0xEF.chr)
      file.write(0xBB.chr)
      file.write(0xBF.chr)
      file.write("\# " + _INTL("See the documentation on the wiki to learn how to edit this file.") + "\r\n")
    end
  
    #=============================================================================
    # Compile all data
    #=============================================================================
    def compile_all(mustCompile)
      FileLineData.clear
      if (!$INEDITOR || Settings::LANGUAGES.length < 2) && safeExists?("Data/messages.dat")
        MessageTypes.loadMessageFile("Data/messages.dat")
      end
      if mustCompile
        echoln _INTL("*** Starting full compile ***")
        echoln ""
        yield(_INTL("Compiling town map data"))
        compile_town_map               # No dependencies
        yield(_INTL("Compiling map connection data"))
        compile_connections            # No dependencies
        yield(_INTL("Compiling phone data"))
        compile_phone
        yield(_INTL("Compiling type data"))
        compile_types                  # No dependencies
        yield(_INTL("Compiling ability data"))
        compile_abilities              # No dependencies
        yield(_INTL("Compiling move data"))
        compile_moves                  # Depends on Type
        yield(_INTL("Compiling item data"))
        compile_items                  # Depends on Move
        yield(_INTL("Compiling species tribes"))
        compile_tribes
        yield(_INTL("Compiling Pokémon data"))
        compile_pokemon                # Depends on Move, Item, Type, Ability
        yield(_INTL("Compiling Pokémon forms data"))
        compile_pokemon_forms          # Depends on Species, Move, Item, Type, Ability
        yield(_INTL("Compiling Pokémon metrics data"))
        compile_pokemon_metrics        # No dependencies
        yield(_INTL("Compiling Old Pokémon data"))
        compile_pokemon_old            # Depends on Move, Item, Type, Ability
        yield(_INTL("Compiling battle metadata"))
        compile_battle_metadata        # Depends on Species, Move, Ability
        yield(_INTL("Compiling Regional Dexes"))
        compile_regional_dexes         # Depends on Species
        yield(_INTL("Compiling ribbon data"))
        compile_ribbons                # No dependencies
        yield(_INTL("Compiling encounter data"))
        compile_encounters             # Depends on Species
        yield(_INTL("Compiling species earliest encounter levels"))
        compile_species_earliest_levels
        yield(_INTL("Compiling Trainer policy data"))
        compile_trainer_policies
        yield(_INTL("Compiling Trainer type data"))
        compile_trainer_types          # No dependencies
        yield(_INTL("Compiling Trainer data"))
        compile_trainers               # Depends on Species, Item, Move
        yield(_INTL("Compiling battle Trainer data"))
        compile_trainer_lists          # Depends on TrainerType
        yield(_INTL("Compiling Avatar battle data"))
        compile_avatars                 # Depends on Species, Item, Move
        yield(_INTL("Compiling metadata"))
        compile_metadata               # Depends on TrainerType
        yield(_INTL("Compiling traits"))
        compile_traits
        yield(_INTL("Compiling likes"))
        compile_likes
        yield(_INTL("Compiling dislikes"))
        compile_dislikes
        yield(_INTL("Compiling achievements"))
        compile_achievements
        yield(_INTL("Compiling animations"))
        compile_animations
        yield(_INTL("Converting events"))
        compile_events
        yield(_INTL("Editing maps"))
        edit_maps
        yield(_INTL("Saving messages"))
        GameData::BattleEffect.set_effect_names_hash
        pbSetTextMessages
        MessageTypes.saveMessages
        echoln ""
        echoln _INTL("*** Finished full compile ***")
        echoln ""
        System.reload_cache

        write_all if ARGV.include?("compile") || pbConfirmMessageSerious(_INTL("\\ts[]Would you like to rewrite the PBS files from the compiled data?"))
      end
      pbSetWindowText(nil)
    end
    
    #=============================================================================
    # Save all data to PBS files
    #=============================================================================
    def write_all
      write_town_map
      write_connections
      write_phone
      write_types
      write_abilities
      write_moves
      write_items
      write_pokemon
      write_pokemon_forms
      write_pokemon_metrics
      write_regional_dexes
      write_ribbons
      write_encounters
      write_trainer_types
      write_trainers
      write_trainer_lists
      write_avatars
      write_metadata
      write_achievements
    end
    
    def getDataFiles
      return [
            "berry_plants.dat",
            "encounters.dat",
            "form2species.dat",
            "items.dat",
            "map_connections.dat",
            "metadata.dat",
            "moves.dat",
            "phone.dat",
            "regional_dexes.dat",
            "ribbons.dat",
            "shadow_movesets.dat",
            "species.dat",
            "species_eggmoves.dat",
            "species_evolutions.dat",
            "species_metrics.dat",
            "species_movesets.dat",
            "species_old.dat",
            "tm.dat",
            "town_map.dat",
            "trainer_lists.dat",
            "trainer_types.dat",
            "trainers.dat",
            "types.dat",
            "policies.dat",
            "avatars.dat"
        ]
      end
      
    def getTextFiles
      return [
            "abilities.txt",
            "berryplants.txt",
            "connections.txt",
            "encounters.txt",
            "items.txt",
            "metadata.txt",
            "moves.txt",
            "phone.txt",
            "pokemon.txt",
            "pokemon_old.txt",
            "pokemonforms.txt",
            "pokemon_metrics.txt",
            "regionaldexes.txt",
            "ribbons.txt",
            "shadowmoves.txt",
            "townmap.txt",
            "trainerlists.txt",
            "trainers.txt",
            "trainertypes.txt",
            "types.txt",
            "policies.txt",
            "avatars.txt",
            "achievements.txt",
        ]
    end
  
    def main
        return if !$DEBUG
        begin
        dataFiles = getDataFiles
        textFiles = getTextFiles
        latestDataTime = 0
        latestTextTime = 0
        mustCompile = false
        # Should recompile if new maps were imported
        mustCompile |= import_new_maps
        # If no PBS file, create one and fill it, then recompile
        if !safeIsDirectory?("PBS")
            Dir.mkdir("PBS") rescue nil
            write_all
            mustCompile = true
        end

        # Check data files and PBS files, and recompile if any PBS file was edited
        # more recently than the data files were last created
        dataFiles.each do |filename|
            next if !safeExists?("Data/" + filename)
            begin
            File.open("Data/#{filename}") { |file|
                latestDataTime = [latestDataTime, file.mtime.to_i].max
            }
            rescue SystemCallError
            mustCompile = true
            end
        end
        textFiles.each do |filename|
            next if !safeExists?("PBS/" + filename)
            begin
            File.open("PBS/#{filename}") { |file|
                latestTextTime = [latestTextTime, file.mtime.to_i].max
            }
            rescue SystemCallError
            end
        end
        MessageTypes.loadMessageFile("Data/messages.dat")

        # Should recompile if holding Ctrl
        Input.update
        mustCompile = true if Input.press?(Input::CTRL) || ARGV.include?("compile")
        
        # Delete old data files in preparation for recompiling
        if mustCompile
            for i in 0...dataFiles.length
            begin
                File.delete("Data/#{dataFiles[i]}") if safeExists?("Data/#{dataFiles[i]}")
                rescue SystemCallError
            end
            end
        end
        # Recompile all data
        compile_all(mustCompile) { |msg| pbSetWindowText(msg); echoln(msg) }
        rescue Exception
        e = $!
        raise e if "#{e.class}"=="Reset" || e.is_a?(Reset) || e.is_a?(SystemExit)
        pbPrintException(e)
        for i in 0...dataFiles.length
            begin
            File.delete("Data/#{dataFiles[i]}")
            rescue SystemCallError
            end
        end
        raise Reset.new if e.is_a?(Hangup)
        loop do
            Graphics.update
        end
        end
      end
      
    #=============================================================================
    # PBS Extensions
    #=============================================================================
    @@pbs_extentions = {}
  
    def register_extension(fileName,filePath)
      if @@pbs_extentions.key?(fileName)
        @@pbs_extentions[fileName].push(filePath)
      else
        @@pbs_extentions[fileName] = [filePath]
      end
      end
      
    def get_extensions(fileName)
      if @@pbs_extentions.key?(fileName)
        return @@pbs_extentions[fileName]
      else
        return []
      end
    end
      
    def list_extensions
      @@pbs_extentions.each do |fileName, textArray|
      echoln(fileName)
      echoln(textArray)
      end
    end
end

#===============================================================================
# Script Page: Compiler_MapsAndEvents
#===============================================================================
module Compiler
  module_function

  #=============================================================================
  # Add new map files to the map tree.
  #=============================================================================
  def import_new_maps
    return false if !$DEBUG
    mapfiles = {}
    # Get IDs of all maps in the Data folder
    Dir.chdir("Data") {
      mapData = sprintf("Map*.rxdata")
      for map in Dir.glob(mapData)
        mapfiles[$1.to_i(10)] = true if map[/map(\d+)\.rxdata/i]
      end
    }
    mapinfos = pbLoadMapInfos
    maxOrder = 0
    # Exclude maps found in mapinfos
    for id in mapinfos.keys
      next if !mapinfos[id]
      mapfiles.delete(id) if mapfiles[id]
      maxOrder = [maxOrder,mapinfos[id].order].max
    end
    # Import maps not found in mapinfos
    maxOrder += 1
    imported = false
    count = 0
    for id in mapfiles.keys
      next if id==999   # Ignore 999 (random dungeon map)
      mapinfo = RPG::MapInfo.new
      mapinfo.order = maxOrder
      mapinfo.name  = sprintf("MAP%03d",id)
      maxOrder += 1
      mapinfos[id] = mapinfo
      imported = true
      count += 1
    end
    if imported
      save_data(mapinfos,"Data/MapInfos.rxdata")
      $PokemonTemp.mapInfos = nil
      pbMessage(_INTL("{1} new map(s) copied to the Data folder were successfully imported.",count))
    end
    return imported
  end

  #=============================================================================
  # Generate and modify event commands.
  #=============================================================================
  def generate_move_route(commands)
    route           = RPG::MoveRoute.new
    route.repeat    = false
    route.skippable = true
    route.list.clear
    i = 0
    while i<commands.length
      case commands[i]
      when PBMoveRoute::Wait, PBMoveRoute::SwitchOn, PBMoveRoute::SwitchOff,
           PBMoveRoute::ChangeSpeed, PBMoveRoute::ChangeFreq, PBMoveRoute::Opacity,
           PBMoveRoute::Blending, PBMoveRoute::PlaySE, PBMoveRoute::Script
        route.list.push(RPG::MoveCommand.new(commands[i],[commands[i+1]]))
        i += 1
      when PBMoveRoute::ScriptAsync
        route.list.push(RPG::MoveCommand.new(PBMoveRoute::Script,[commands[i+1]]))
        route.list.push(RPG::MoveCommand.new(PBMoveRoute::Wait,[0]))
        i += 1
      when PBMoveRoute::Jump
        route.list.push(RPG::MoveCommand.new(commands[i],[commands[i+1],commands[i+2]]))
        i += 2
      when PBMoveRoute::Graphic
        route.list.push(RPG::MoveCommand.new(commands[i],[commands[i+1],commands[i+2],commands[i+3],commands[i+4]]))
        i += 4
      else
        route.list.push(RPG::MoveCommand.new(commands[i]))
      end
      i += 1
    end
    route.list.push(RPG::MoveCommand.new(0))
    return route
  end

  def push_move_route(list,character,route,indent=0)
    route = generate_move_route(route) if route.is_a?(Array)
    for i in 0...route.list.length
      list.push(RPG::EventCommand.new(
        (i==0) ? 209 : 509,indent,
        (i==0) ? [character,route] : [route.list[i-1]]))
    end
  end

  def push_move_route_and_wait(list,character,route,indent=0)
    push_move_route(list,character,route,indent)
    push_event(list,210,[],indent)
  end

  def push_wait(list,frames,indent=0)
    push_event(list,106,[frames],indent)
  end

  def push_event(list,cmd,params=nil,indent=0)
    list.push(RPG::EventCommand.new(cmd,indent,params ? params : []))
  end

  def push_end(list)
    list.push(RPG::EventCommand.new(0,0,[]))
  end

  def push_comment(list,cmt,indent=0)
    textsplit2 = cmt.split(/\n/)
    for i in 0...textsplit2.length
      list.push(RPG::EventCommand.new((i==0) ? 108 : 408,indent,[textsplit2[i].gsub(/\s+$/,"")]))
    end
  end

  def push_text(list,text,indent=0)
    return if !text
    textsplit = text.split(/\\m/)
    for t in textsplit
      first = true
      textsplit2 = t.split(/\n/)
      for i in 0...textsplit2.length
        textchunk = textsplit2[i].gsub(/\s+$/,"")
        if textchunk && textchunk!=""
          list.push(RPG::EventCommand.new((first) ? 101 : 401,indent,[textchunk]))
          first = false
        end
      end
    end
  end

  def push_script(list,script,indent=0)
    return if !script
    first = true
    textsplit2 = script.split(/\n/)
    for i in 0...textsplit2.length
      textchunk = textsplit2[i].gsub(/\s+$/,"")
      if textchunk && textchunk!=""
        list.push(RPG::EventCommand.new((first) ? 355 : 655,indent,[textchunk]))
        first = false
      end
    end
  end

  def push_exit(list,indent=0)
    list.push(RPG::EventCommand.new(115,indent,[]))
  end

  def push_else(list,indent=0)
    list.push(RPG::EventCommand.new(0,indent,[]))
    list.push(RPG::EventCommand.new(411,indent-1,[]))
  end

  def push_branch(list,script,indent=0)
    list.push(RPG::EventCommand.new(111,indent,[12,script]))
  end

  def push_branch_end(list,indent=0)
    list.push(RPG::EventCommand.new(0,indent,[]))
    list.push(RPG::EventCommand.new(412,indent-1,[]))
  end

  def push_self_switch(list,swtch,switchOn,indent=0)
    list.push(RPG::EventCommand.new(123,indent,[swtch,switchOn ? 0 : 1]))
  end

  def apply_pages(page,pages)
    for p in pages
      p.graphic       = page.graphic
      p.walk_anime    = page.walk_anime
      p.step_anime    = page.step_anime
      p.direction_fix = page.direction_fix
      p.through       = page.through
      p.always_on_top = page.always_on_top
    end
  end

  def add_passage_list(event,mapData)
    return if !event || event.pages.length==0
    page                         = RPG::Event::Page.new
    page.condition.switch1_valid = true
    page.condition.switch1_id    = mapData.registerSwitch('s:tsOff?("A")')
    page.graphic.character_name  = ""
    page.trigger                 = 3   # Autorun
    page.list.clear
    list = page.list
    push_branch(list,"get_character(0).onEvent?")
    push_event(list,208,[0],1)   # Change Transparent Flag
    push_wait(list,6,1)          # Wait
    push_event(list,208,[1],1)   # Change Transparent Flag
    push_move_route_and_wait(list,-1,[PBMoveRoute::Down],1)
    push_branch_end(list,1)
    push_script(list,"setTempSwitchOn(\"A\")")
    push_end(list)
    event.pages.push(page)
  end

  #=============================================================================
  #
  #=============================================================================
  def safequote(x)
    x = x.gsub(/\"\#\'\\/) { |a| "\\"+a }
    x = x.gsub(/\t/,"\\t")
    x = x.gsub(/\r/,"\\r")
    x = x.gsub(/\n/,"\\n")
    return x
  end

  def safequote2(x)
    x = x.gsub(/\"\#\'\\/) { |a| "\\"+a }
    x = x.gsub(/\t/,"\\t")
    x = x.gsub(/\r/,"\\r")
    x = x.gsub(/\n/," ")
    return x
  end

  def pbEventId(event)
    list = event.pages[0].list
    return nil if list.length==0
    codes = []
    i = 0
    while i<list.length
      codes.push(list[i].code)
      i += 1
    end
  end

  def pbEachPage(e)
    return true if !e
    if e.is_a?(RPG::CommonEvent)
      yield e
    else
      e.pages.each { |page| yield page }
    end
  end

  #=============================================================================
  #
  #=============================================================================
  class MapData
    attr_reader :mapinfos

    def initialize
      @mapinfos = pbLoadMapInfos
      @system   = load_data("Data/System.rxdata")
      @tilesets = load_data("Data/Tilesets.rxdata")
      @mapxy      = []
      @mapWidths  = []
      @mapHeights = []
      @maps       = []
      @registeredSwitches = {}
    end

    def switchName(id)
      return @system.switches[id] || ""
    end

    def mapFilename(mapID)
              return sprintf("Data/Map%03d.rxdata", mapID)
        end

    def getMap(mapID)
      return @maps[mapID] if @maps[mapID]
      begin
        @maps[mapID] = load_data(mapFilename(mapID))
        return @maps[mapID]
      rescue
        return nil
      end
    end

    def getEventFromXY(mapID,x,y)
      return nil if x<0 || y<0
      mapPositions = @mapxy[mapID]
      return mapPositions[y*@mapWidths[mapID]+x] if mapPositions
      map = getMap(mapID)
      return nil if !map
      @mapWidths[mapID]  = map.width
      @mapHeights[mapID] = map.height
      mapPositions = []
      width = map.width
      for e in map.events.values
        mapPositions[e.y*width+e.x] = e if e
      end
      @mapxy[mapID] = mapPositions
      return mapPositions[y*width+x]
    end

    def getEventFromID(mapID,id)
      map = getMap(mapID)
      return nil if !map
      return map.events[id]
    end

    def getTilesetPassages(map,mapID)
      begin
        return @tilesets[map.tileset_id].passages
      rescue
        raise "Tileset data for tileset number #{map.tileset_id} used on map #{mapID} was not found. " +
              "The tileset was likely deleted, but one or more maps still use it."
      end
    end

    def getTilesetPriorities(map,mapID)
      begin
        return @tilesets[map.tileset_id].priorities
      rescue
        raise "Tileset data for tileset number #{map.tileset_id} used on map #{mapID} was not found. " +
              "The tileset was likely deleted, but one or more maps still use it."
      end
    end

    def isPassable?(mapID,x,y)
      map = getMap(mapID)
      return false if !map
      return false if x<0 || x>=map.width || y<0 || y>=map.height
      passages   = getTilesetPassages(map,mapID)
      priorities = getTilesetPriorities(map,mapID)
      for i in [2, 1, 0]
        tile_id = map.data[x, y, i]
        return false if tile_id==nil
        passage = passages[tile_id]
        if !passage
          raise "The tile used on map #{mapID} at coordinates (#{x}, #{y}) on layer #{i+1} doesn't exist in the tileset. " +
                "It should be deleted to prevent errors."
        end
        return false if passage&0x0f==0x0f
        return true if priorities[tile_id]==0
      end
      return true
    end

    def isCounterTile?(mapID,x,y)
      map = getMap(mapID)
      return false if !map
      passages = getTilesetPassages(map,mapID)
      for i in [2, 1, 0]
        tile_id = map.data[x, y, i]
        return false if tile_id==nil
        passage = passages[tile_id]
        if !passage
          raise "The tile used on map #{mapID} at coordinates (#{x}, #{y}) on layer #{i+1} doesn't exist in the tileset. " +
                "It should be deleted to prevent errors."
        end
        return true if passage&0x80==0x80
      end
      return false
    end

    def setCounterTile(mapID,x,y)
      map = getMap(mapID)
      return if !map
      passages = getTilesetPassages(map,mapID)
      for i in [2, 1, 0]
        tile_id = map.data[x, y, i]
        next if tile_id==0
        passages[tile_id] |= 0x80
        break
      end
    end

    def registerSwitch(switch)
      return @registeredSwitches[switch] if @registeredSwitches[switch]
      for id in 1..5000
        name = @system.switches[id]
        next if name && name!="" && name!=switch
        @system.switches[id] = switch
        @registeredSwitches[switch] = id
        return id
      end
      return 1
    end

    def saveMap(mapID)
      save_data(getMap(mapID),mapFilename(mapID)) rescue nil
    end

    def saveTilesets
      save_data(@tilesets, "Data/Tilesets.rxdata")
      save_data(@system, "Data/System.rxdata")
    end
  end

  #=============================================================================
  #
  #=============================================================================
  class TrainerChecker
    def initialize
      @dontaskagain = false
    end

    def pbTrainerTypeCheck(trainer_type)
      return if !$DEBUG || @dontaskagain
      return if GameData::TrainerType.exists?(trainer_type)
      if pbConfirmMessage(_INTL("Add new trainer type {1}?", trainer_type.to_s))
        pbTrainerTypeEditorNew(trainer_type.to_s)
      end
    end

    def pbTrainerBattleCheck(tr_type, tr_name, tr_version)
      return if !$DEBUG || @dontaskagain
      # Check for existence of trainer type
      pbTrainerTypeCheck(tr_type)
      return if !GameData::TrainerType.exists?(tr_type)
      tr_type = GameData::TrainerType.get(tr_type).id
      # Check for existence of trainer
      return if GameData::Trainer.exists?(tr_type, tr_name, tr_version)
      # Add new trainer
      cmd = pbMissingTrainer(tr_type, tr_name, tr_version)
      if cmd == 2
        @dontaskagain = true
        Graphics.update
      end
    end
  end

  #=============================================================================
  # Convert trainer comments to trainer event.
  #=============================================================================
  def convert_to_trainer_event(event,trainerChecker)
    return nil if !event || event.pages.length==0
    list = event.pages[0].list
    return nil if list.length<2
    commands = []
    isFirstCommand = false
    # Find all the trainer comments in the event
    for i in 0...list.length
      next if list[i].code!=108   # Comment (first line)
      command = list[i].parameters[0]
      for j in (i+1)...list.length
        break if list[j].code!=408   # Comment (continuation line)
        command += "\r\n"+list[j].parameters[0]
      end
      if command[/^(Battle\:|Type\:|Name\:|BattleID\:|DoubleBattle\:|Backdrop\:|EndSpeech\:|Outcome\:|Continue\:|EndBattle\:|EndIfSwitch\:|VanishIfSwitch\:|RegSpeech\:)/i]
        commands.push(command)
        isFirstCommand = true if i==0
      end
    end
    return nil if commands.length==0
    # Found trainer comments; create a new Event object to replace this event
    ret = RPG::Event.new(event.x,event.y)
    ret.name = event.name
    ret.id   = event.id
    firstpage = Marshal::load(Marshal.dump(event.pages[0]))   # Copy event's first page
    firstpage.trigger = 2   # On event touch
    firstpage.list    = []   # Clear page's commands
    # Rename the event if there's nothing above the trainer comments
    if isFirstCommand
      if !event.name[/trainer/i]
        ret.name = "Trainer(3)"
      elsif event.name[/^\s*trainer\s*\((\d+)\)\s*$/i]
        ret.name = "Trainer(#{$1})"
      end
    end
    # Compile the trainer comments
    rewriteComments = false   # You can change this
    battles        = []
    trtype         = nil
    trname         = nil
    battleid       = 0
    doublebattle   = false
    backdrop       = nil
    endspeeches    = []
    outcome        = 0
    continue       = false
    endbattles     = []
    endifswitch    = []
    vanishifswitch = []
    regspeech      = nil
    for command in commands
      if command[/^Battle\:\s*([\s\S]+)$/i]
        battles.push($~[1])
        push_comment(firstpage.list,command) if rewriteComments
      elsif command[/^Type\:\s*([\s\S]+)$/i]
        trtype = $~[1].gsub(/^\s+/,"").gsub(/\s+$/,"")
        push_comment(firstpage.list,command) if rewriteComments
      elsif command[/^Name\:\s*([\s\S]+)$/i]
        trname = $~[1].gsub(/^\s+/,"").gsub(/\s+$/,"")
        push_comment(firstpage.list,command) if rewriteComments
      elsif command[/^BattleID\:\s*(\d+)$/i]
        battleid = $~[1].to_i
        push_comment(firstpage.list,command) if rewriteComments
      elsif command[/^DoubleBattle\:\s*([\s\S]+)$/i]
        value = $~[1].gsub(/^\s+/,"").gsub(/\s+$/,"")
        doublebattle = true if value.upcase=="TRUE" || value.upcase=="YES"
        push_comment(firstpage.list,command) if rewriteComments
      elsif command[/^Backdrop\:\s*([\s\S]+)$/i]
        backdrop = $~[1].gsub(/^\s+/,"").gsub(/\s+$/,"")
        push_comment(firstpage.list,command) if rewriteComments
      elsif command[/^EndSpeech\:\s*([\s\S]+)$/i]
        endspeeches.push($~[1].gsub(/^\s+/,"").gsub(/\s+$/,""))
        push_comment(firstpage.list,command) if rewriteComments
      elsif command[/^Outcome\:\s*(\d+)$/i]
        outcome = $~[1].to_i
        push_comment(firstpage.list,command) if rewriteComments
      elsif command[/^Continue\:\s*([\s\S]+)$/i]
        value = $~[1].gsub(/^\s+/,"").gsub(/\s+$/,"")
        continue = true if value.upcase=="TRUE" || value.upcase=="YES"
        push_comment(firstpage.list,command) if rewriteComments
      elsif command[/^EndBattle\:\s*([\s\S]+)$/i]
        endbattles.push($~[1].gsub(/^\s+/,"").gsub(/\s+$/,""))
        push_comment(firstpage.list,command) if rewriteComments
      elsif command[/^EndIfSwitch\:\s*([\s\S]+)$/i]
        endifswitch.push(($~[1].gsub(/^\s+/,"").gsub(/\s+$/,"")).to_i)
        push_comment(firstpage.list,command) if rewriteComments
      elsif command[/^VanishIfSwitch\:\s*([\s\S]+)$/i]
        vanishifswitch.push(($~[1].gsub(/^\s+/,"").gsub(/\s+$/,"")).to_i)
        push_comment(firstpage.list,command) if rewriteComments
      elsif command[/^RegSpeech\:\s*([\s\S]+)$/i]
        regspeech = $~[1].gsub(/^\s+/,"").gsub(/\s+$/,"")
        push_comment(firstpage.list,command) if rewriteComments
      end
    end
    return nil if battles.length<=0
    # Run trainer check now, except in editor
    trainerChecker.pbTrainerBattleCheck(trtype,trname,battleid) if !$INEDITOR
    # Set the event's charset to one depending on the trainer type if the event
    # doesn't have a charset
    if firstpage.graphic.character_name=="" && GameData::TrainerType.exists?(trtype)
      trainerid = GameData::TrainerType.get(trtype).id
      filename = GameData::TrainerType.charset_filename_brief(trainerid)
      if FileTest.image_exist?("Graphics/Characters/"+filename)
        firstpage.graphic.character_name = sprintf(filename)
      end
    end
    # Create strings that will be used repeatedly
    safetrcombo = sprintf(":%s,\"%s\"",trtype,safequote(trname))   # :YOUNGSTER,"Joey"
    introplay   = sprintf("pbTrainerIntro(:%s)",trtype)
    # Write first page
    push_script(firstpage.list,introplay)   # pbTrainerIntro
    push_script(firstpage.list,"pbNoticePlayer(get_character(0))")
    push_text(firstpage.list,battles[0])
    if battles.length>1   # Has rematches
      push_script(firstpage.list,sprintf("pbTrainerCheck(%s,%d,%d)",safetrcombo,battles.length,battleid))
    end
    push_script(firstpage.list,"setBattleRule(\"double\")") if doublebattle
    push_script(firstpage.list,sprintf("setBattleRule(\"backdrop\",\"%s\")",safequote(backdrop))) if backdrop
    push_script(firstpage.list,sprintf("setBattleRule(\"outcomeVar\",%d)",outcome)) if outcome>1
    push_script(firstpage.list,"setBattleRule(\"canLose\")") if continue
    espeech = (endspeeches[0]) ? sprintf("_I(\"%s\")",safequote2(endspeeches[0])) : "nil"
    if battleid>0
      battleString = sprintf("pbTrainerBattle(%s,%s,nil,%d)",safetrcombo,espeech,battleid)
    elsif endspeeches[0]
      battleString = sprintf("pbTrainerBattle(%s,%s)",safetrcombo,espeech)
    else
      battleString = sprintf("pbTrainerBattle(%s)",safetrcombo)
    end
    push_branch(firstpage.list,battleString)
    if battles.length>1   # Has rematches
      push_script(firstpage.list,
         sprintf("pbPhoneRegisterBattle(_I(\"%s\"),get_character(0),%s,%d)",
         regspeech,safetrcombo,battles.length),1)
    end
    push_self_switch(firstpage.list,"A",true,1)
    push_branch_end(firstpage.list,1)
    push_script(firstpage.list,"pbTrainerEnd",0)
    push_end(firstpage.list)
    # Copy first page to last page and make changes to its properties
    lastpage = Marshal::load(Marshal.dump(firstpage))
    lastpage.trigger   = 0   # On action
    lastpage.list      = []   # Clear page's commands
    lastpage.condition = firstpage.condition.clone
    lastpage.condition.self_switch_valid = true
    lastpage.condition.self_switch_ch    = "A"
    # Copy last page to rematch page
    rematchpage = Marshal::load(Marshal.dump(lastpage))
    rematchpage.list      = lastpage.list.clone   # Copy the last page's commands
    rematchpage.condition = lastpage.condition.clone
    rematchpage.condition.self_switch_valid = true
    rematchpage.condition.self_switch_ch    = "B"
    # Write rematch and last pages
    for i in 1...battles.length
      # Run trainer check now, except in editor
      trainerChecker.pbTrainerBattleCheck(trtype,trname,battleid+i) if !$INEDITOR
      if i==battles.length-1
        push_branch(rematchpage.list,sprintf("pbPhoneBattleCount(%s)>=%d",safetrcombo,i))
        push_branch(lastpage.list,sprintf("pbPhoneBattleCount(%s)>%d",safetrcombo,i))
      else
        push_branch(rematchpage.list,sprintf("pbPhoneBattleCount(%s)==%d",safetrcombo,i))
        push_branch(lastpage.list,sprintf("pbPhoneBattleCount(%s)==%d",safetrcombo,i))
      end
      # Rematch page
      push_script(rematchpage.list,introplay,1)   # pbTrainerIntro
      push_text(rematchpage.list,battles[i],1)
      push_script(rematchpage.list,"setBattleRule(\"double\")",1) if doublebattle
      push_script(rematchpage.list,sprintf("setBattleRule(\"backdrop\",%s)",safequote(backdrop)),1) if backdrop
      push_script(rematchpage.list,sprintf("setBattleRule(\"outcomeVar\",%d)",outcome),1) if outcome>1
      push_script(rematchpage.list,"setBattleRule(\"canLose\")",1) if continue
      espeech = nil
      if endspeeches.length>0
        espeech = (endspeeches[i]) ? endspeeches[i] : endspeeches[endspeeches.length-1]
      end
      espeech = (espeech) ? sprintf("_I(\"%s\")",safequote2(espeech)) : "nil"
      battleString = sprintf("pbTrainerBattle(%s,%s,nil,%d)",safetrcombo,espeech,battleid+i)
      push_branch(rematchpage.list,battleString,1)
      push_script(rematchpage.list,sprintf("pbPhoneIncrement(%s,%d)",safetrcombo,battles.length),2)
      push_self_switch(rematchpage.list,"A",true,2)
      push_self_switch(rematchpage.list,"B",false,2)
      push_script(rematchpage.list,"pbTrainerEnd",2)
      push_branch_end(rematchpage.list,2)
      push_exit(rematchpage.list,1)   # Exit Event Processing
      push_branch_end(rematchpage.list,1)
      # Last page
      if endbattles.length>0
        ebattle = (endbattles[i]) ? endbattles[i] : endbattles[endbattles.length-1]
        push_text(lastpage.list,ebattle,1)
      end
      push_script(lastpage.list,
         sprintf("pbPhoneRegisterBattle(_I(\"%s\"),get_character(0),%s,%d)",
         regspeech,safetrcombo,battles.length),1)
      push_exit(lastpage.list,1)   # Exit Event Processing
      push_branch_end(lastpage.list,1)
    end
    # Finish writing rematch page
    push_end(rematchpage.list)
    # Finish writing last page
    ebattle = (endbattles[0]) ? endbattles[0] : "..."
    push_text(lastpage.list,ebattle)
    if battles.length>1
      push_script(lastpage.list,
         sprintf("pbPhoneRegisterBattle(_I(\"%s\"),get_character(0),%s,%d)",
         regspeech,safetrcombo,battles.length))
    end
    push_end(lastpage.list)
    # Add pages to the new event
    if battles.length==1   # Only one battle
      ret.pages = [firstpage,lastpage]
    else   # Has rematches
      ret.pages = [firstpage,rematchpage,lastpage]
    end
    # Copy last page to endIfSwitch page
    for endswitch in endifswitch
      endIfSwitchPage = Marshal::load(Marshal.dump(lastpage))
      endIfSwitchPage.condition = lastpage.condition.clone
      if endIfSwitchPage.condition.switch1_valid   # Add another page condition
        endIfSwitchPage.condition.switch2_valid = true
        endIfSwitchPage.condition.switch2_id    = endswitch
      else
        endIfSwitchPage.condition.switch1_valid = true
        endIfSwitchPage.condition.switch1_id    = endswitch
      end
      endIfSwitchPage.condition.self_switch_valid = false
      endIfSwitchPage.list = []   # Clear page's commands
      ebattle = (endbattles[0]) ? endbattles[0] : "..."
      push_text(endIfSwitchPage.list,ebattle)
      push_end(endIfSwitchPage.list)
      ret.pages.push(endIfSwitchPage)
    end
    # Copy last page to vanishIfSwitch page
    for vanishswitch in vanishifswitch
      vanishIfSwitchPage = Marshal::load(Marshal.dump(lastpage))
      vanishIfSwitchPage.graphic.character_name = ""   # No charset
      vanishIfSwitchPage.condition = lastpage.condition.clone
      if vanishIfSwitchPage.condition.switch1_valid   # Add another page condition
        vanishIfSwitchPage.condition.switch2_valid = true
        vanishIfSwitchPage.condition.switch2_id    = vanishswitch
      else
        vanishIfSwitchPage.condition.switch1_valid = true
        vanishIfSwitchPage.condition.switch1_id    = vanishswitch
      end
      vanishIfSwitchPage.condition.self_switch_valid = false
      vanishIfSwitchPage.list = []   # Clear page's commands
      push_end(vanishIfSwitchPage.list)
      ret.pages.push(vanishIfSwitchPage)
    end
    return ret
  end

  #=============================================================================
  # Convert event name to item event.
  # Checks if the event's name is "Item:POTION" or "HiddenItem:POTION". If so,
  # rewrites the whole event into one now named "Item"/"HiddenItem" which gives
  # that item when interacted with.
  #=============================================================================
  def convert_to_item_event(event)
    return nil if !event || event.pages.length==0
    name = event.name
    ret       = RPG::Event.new(event.x,event.y)
    ret.name  = event.name
    ret.id    = event.id
    ret.pages = []
    itemName = ""
    hidden = false
    if name[/^hiddenitem\:\s*(\w+)\s*$/i]
      itemName = $1
      return nil if !GameData::Item.exists?(itemName)
      ret.name = "HiddenItem"
      hidden = true
    elsif name[/^item\:\s*(\w+)\s*$/i]
      itemName = $1
      return nil if !GameData::Item.exists?(itemName)
      ret.name = "Item"
    else
      return nil
    end
    # Event page 1
    page = RPG::Event::Page.new
    page.graphic.character_name = "Object ball" if !hidden
    page.list = []
    push_branch(page.list,sprintf("pbItemBall(:%s)",itemName))
    push_self_switch(page.list,"A",true,1)
    push_else(page.list,1)
    push_branch_end(page.list,1)
    push_end(page.list)
    ret.pages.push(page)
    # Event page 2
    page = RPG::Event::Page.new
    page.condition.self_switch_valid = true
    page.condition.self_switch_ch    = "A"
    ret.pages.push(page)
    return ret
  end

  #=============================================================================
  # Checks whether a given event is likely to be a door. If so, rewrite it to
  # include animating the event as though it was a door opening and closing as the
  # player passes through.
  #=============================================================================
  def update_door_event(event,mapData)
    changed = false
    return false if event.is_a?(RPG::CommonEvent)
    # Check if event has 2+ pages and the last page meets all of these criteria:
    #   - Has a condition of a Switch being ON
    #   - The event has a charset graphic
    #   - There are more than 5 commands in that page, the first of which is a
    #     Conditional Branch
    lastPage = event.pages[event.pages.length-1]
    if event.pages.length>=2 &&
       lastPage.condition.switch1_valid &&
       lastPage.graphic.character_name!="" &&
       lastPage.list.length>5 &&
       lastPage.list[0].code==111
      # This bit of code is just in case Switch 22 has been renamed/repurposed,
      # which is highly unlikely. It changes the Switch used in the condition to
      # whichever is named 's:tsOff?("A")'.
      if lastPage.condition.switch1_id==22 &&
         mapData.switchName(lastPage.condition.switch1_id)!='s:tsOff?("A")'
        lastPage.condition.switch1_id = mapData.registerSwitch('s:tsOff?("A")')
        changed = true
      end
      # If the last page's Switch condition uses a Switch named 's:tsOff?("A")',
      # check the penultimate page. If it contains exactly 1 "Transfer Player"
      # command and does NOT contain a "Change Transparent Flag" command, rewrite
      # both the penultimate page and the last page.
      if mapData.switchName(lastPage.condition.switch1_id)=='s:tsOff?("A")'
        list = event.pages[event.pages.length-2].list
        transferCommand = list.find_all { |cmd| cmd.code==201 }   # Transfer Player
        if transferCommand.length==1 && !list.any? { |cmd| cmd.code==208 }   # Change Transparent Flag
          # Rewrite penultimate page
          list.clear
          push_move_route_and_wait(list,0,[   # Move Route for door opening
             PBMoveRoute::PlaySE,RPG::AudioFile.new("Door enter"),PBMoveRoute::Wait,2,
             PBMoveRoute::TurnLeft,PBMoveRoute::Wait,2,
             PBMoveRoute::TurnRight,PBMoveRoute::Wait,2,
             PBMoveRoute::TurnUp,PBMoveRoute::Wait,2])
          push_move_route_and_wait(list,-1,[   # Move Route for player entering door
             PBMoveRoute::ThroughOn,PBMoveRoute::Up,PBMoveRoute::ThroughOff])
          push_event(list,208,[0])   # Change Transparent Flag (invisible)
          push_move_route_and_wait(list,0,[PBMoveRoute::Wait,2,   # Move Route for door closing
             PBMoveRoute::TurnRight,PBMoveRoute::Wait,2,
             PBMoveRoute::TurnLeft,PBMoveRoute::Wait,2,
             PBMoveRoute::TurnDown,PBMoveRoute::Wait,2])
          push_event(list,223,[Tone.new(-255,-255,-255),6])   # Change Screen Color Tone
          push_wait(list,8)   # Wait
          push_event(list,208,[1])   # Change Transparent Flag (visible)
          push_event(list,transferCommand[0].code,transferCommand[0].parameters)   # Transfer Player
          push_event(list,223,[Tone.new(0,0,0),6])   # Change Screen Color Tone
          push_end(list)
          # Rewrite last page
          list = lastPage.list
          list.clear
          push_branch(list,"get_character(0).onEvent?")   # Conditional Branch
          push_event(list,208,[0],1)   # Change Transparent Flag (invisible)
          push_move_route_and_wait(list,0,[   # Move Route for setting door to open
             PBMoveRoute::TurnLeft,PBMoveRoute::Wait,6],1)
          push_event(list,208,[1],1)   # Change Transparent Flag (visible)
          push_move_route_and_wait(list,-1,[PBMoveRoute::Down],1)   # Move Route for player exiting door
          push_move_route_and_wait(list,0,[   # Move Route for door closing
             PBMoveRoute::TurnUp,PBMoveRoute::Wait,2,
             PBMoveRoute::TurnRight,PBMoveRoute::Wait,2,
             PBMoveRoute::TurnDown,PBMoveRoute::Wait,2],1)
          push_branch_end(list,1)
          push_script(list,"setTempSwitchOn(\"A\")")
          push_end(list)
          changed = true
        end
      end
    end
    return changed
  end

  #=============================================================================
  # Fix up standard code snippets
  #=============================================================================
  def event_is_empty?(e)
    return true if !e
    return false if e.is_a?(RPG::CommonEvent)
    return e.pages.length==0
  end

  # Checks if the event has exactly 1 page, said page has no graphic, it has
  # less than 12 commands and at least one is a Transfer Player, and the tiles
  # to the left/right/upper left/upper right are not passable but the event's
  # tile is. Causes a second page to be added to the event which is the "is
  # player on me?" check that occurs when the map is entered.
  def likely_passage?(thisEvent,mapID,mapData)
    return false if !thisEvent || thisEvent.pages.length==0
    return false if thisEvent.pages.length!=1
    if thisEvent.pages[0].graphic.character_name=="" &&
       thisEvent.pages[0].list.length<=12 &&
       thisEvent.pages[0].list.any? { |cmd| cmd.code==201 } &&   # Transfer Player
#       mapData.isPassable?(mapID,thisEvent.x,thisEvent.y+1) &&
       mapData.isPassable?(mapID,thisEvent.x,thisEvent.y) &&
       !mapData.isPassable?(mapID,thisEvent.x-1,thisEvent.y) &&
       !mapData.isPassable?(mapID,thisEvent.x+1,thisEvent.y) &&
       !mapData.isPassable?(mapID,thisEvent.x-1,thisEvent.y-1) &&
       !mapData.isPassable?(mapID,thisEvent.x+1,thisEvent.y-1)
      return true
    end
    return false
  end

  def change_script(script,re)
    tmp = script[0].gsub(re) { yield($~) }
    if script[0]!=tmp
      script[0] = tmp
      return true
    end
    return false
  end

  def change_scripts(script)
    changed = false
    changed |= change_script(script,/\$game_variables\[(\d+)\](?!\s*(?:\=|\!|<|>))/) { |m| "pbGet("+m[1]+")" }
    changed |= change_script(script,/\$Trainer\.party\[\s*pbGet\((\d+)\)\s*\]/) { |m| "pbGetPokemon("+m[1]+")" }
    return changed
  end

  def fix_event_name(event)
    return false if !event
    case event.name.downcase
    when "tree"
      event.name = "CutTree"
    when "rock"
      event.name = "SmashRock"
    when "boulder"
      event.name = "StrengthBoulder"
    else
      return false
    end
    return true
  end

  def fix_event_use(event,_mapID,mapData)
    return nil if event_is_empty?(event)
    changed = false
    trainerMoneyRE = /^\s*\$Trainer\.money\s*(<|<=|>|>=)\s*(\d+)\s*$/
    # Rewrite event if it looks like a door
    changed = true if update_door_event(event,mapData)
    # Check through each page of the event in turn
    pbEachPage(event) do |page|
      i = 0
      list = page.list
      while i<list.length
        params = list[i].parameters
        case list[i].code
        when 655   # Script (continuation line)
          x = [params[0]]
          changed |= change_scripts(x)
          params[0] = x[0]
        when 355   # Script (first line)
          lastScript = i
          if !params[0].is_a?(String)
            i += 1
            next
          end
          x = [params[0]]
          changed |= change_scripts(x)
          params[0] = x[0]
          # Check if the script is an old way of healing the entire party, and if
          # so, replace it with a better version that uses event commands
          if params[0][0,1]!="f" && params[0][0,1]!="p" && params[0][0,1]!="K"
            i += 1
            next
          end
          # Script begins with "f" (for...), "p" (pbMethod) or "K" (Kernel.)
          script = " "+params[0]
          j = i+1
          while j<list.length
            break if list[j].code!=655   # Script (continuation line)
            script += list[j].parameters[0]
            lastScript = j
            j += 1
          end
          script.gsub!(/\s+/,"")
          # Using old method of recovering
          if script=="foriin$Trainer.partyi.healend"
            for j in i..lastScript
              list.delete_at(i)
            end
            list.insert(i,
               RPG::EventCommand.new(314,list[i].indent,[0])   # Recover All
            )
            changed=true
          elsif script=="pbFadeOutIn(99999){foriin$Trainer.partyi.healend}"
            oldIndent = list[i].indent
            for j in i..lastScript
              list.delete_at(i)
            end
            list.insert(i,
               RPG::EventCommand.new(223,oldIndent,[Tone.new(-255,-255,-255),6]),   # Fade to black
               RPG::EventCommand.new(106,oldIndent,[6]),                            # Wait
               RPG::EventCommand.new(314,oldIndent,[0]),                            # Recover All
               RPG::EventCommand.new(223,oldIndent,[Tone.new(0,0,0),6]),            # Fade to normal
               RPG::EventCommand.new(106,oldIndent,[6])                             # Wait
            )
            changed = true
          end
        when 108   # Comment (first line)
          # Replace a "SellItem:POTION,200" comment with event commands that do so
          if params[0][/SellItem\s*\(\s*(\w+)\s*\,\s*(\d+)\s*\)/]
            itemname = $1
            cost     = $2.to_i
            if GameData::Item.exists?(itemname)
              oldIndent = list[i].indent
              list.delete_at(i)
              newEvents = []
              if cost==0
                push_branch(newEvents,"$PokemonBag.pbCanStore?(:#{itemname})",oldIndent)
                push_text(newEvents,_INTL("Here you go!"),oldIndent+1)
                push_script(newEvents,"pbReceiveItem(:#{itemname})",oldIndent+1)
                push_else(newEvents,oldIndent+1)
                push_text(newEvents,_INTL("You have no room left in the Bag."),oldIndent+1)
                push_branch_end(newEvents,oldIndent+1)
              else
                push_event(newEvents,111,[7,cost,0],oldIndent)
                push_branch(newEvents,"$PokemonBag.pbCanStore?(:#{itemname})",oldIndent+1)
                push_event(newEvents,125,[1,0,cost],oldIndent+2)
                push_text(newEvents,_INTL("\\GHere you go!"),oldIndent+2)
                push_script(newEvents,"pbReceiveItem(:#{itemname})",oldIndent+2)
                push_else(newEvents,oldIndent+2)
                push_text(newEvents,_INTL("\\GYou have no room left in the Bag."),oldIndent+2)
                push_branch_end(newEvents,oldIndent+2)
                push_else(newEvents,oldIndent+1)
                push_text(newEvents,_INTL("\\GYou don't have enough money."),oldIndent+1)
                push_branch_end(newEvents,oldIndent+1)
              end
              list[i,0] = newEvents   # insert 'newEvents' at index 'i'
              changed = true
            end
          end
        when 115   # Exit Event Processing
          if i==list.length-2
            # Superfluous exit command, delete it
            list.delete_at(i)
            changed = true
          end
        when 201   # Transfer Player
          if list.length<=8
=begin
            if params[0]==0
              # Look for another event just above the position this Transfer
              # Player command will transfer to - it may be a door, in which case
              # this command should transfer the player onto the door instead of
              # in front of it.
              e = mapData.getEventFromXY(params[1],params[2],params[3]-1)
              # This bit of code is just in case Switch 22 has been renamed/
              # repurposed, which is highly unlikely. It changes the Switch used
              # in the found event's condition to whichever is named
              # 's:tsOff?("A")'.
              if e && e.pages.length>=2 &&
                 e.pages[e.pages.length-1].condition.switch1_valid &&
                 e.pages[e.pages.length-1].condition.switch1_id==22 &&
                 mapData.switchName(e.pages[e.pages.length-1].condition.switch1_id)!='s:tsOff?("A")' &&
                 e.pages[e.pages.length-1].list.length>5 &&
                 e.pages[e.pages.length-1].list[0].code==111   # Conditional Branch
                e.pages[e.pages.length-1].condition.switch1_id = mapData.registerSwitch('s:tsOff?("A")')
                mapData.saveMap(params[1])
                changed = true
              end
              # Checks if the found event is a simple Transfer Player one nestled
              # between tiles that aren't passable - it is likely a door, so give
              # it a second page with an "is player on me?" check.
              if likely_passage?(e,params[1],mapData)   # Checks the first page
                add_passage_list(e,mapData)
                mapData.saveMap(params[1])
                changed = true
              end
              # If the found event's last page's Switch condition uses a Switch
              # named 's:tsOff?("A")', it really does look like a door. Make this
              # command transfer the player on top of it rather than in front of
              # it.
              if e && e.pages.length>=2 &&
                 e.pages[e.pages.length-1].condition.switch1_valid &&
                 mapData.switchName(e.pages[e.pages.length-1].condition.switch1_id)=='s:tsOff?("A")'
                # If this is really a door, move transfer target to it
                params[3] -= 1   # Move this command's destination up 1 tile (onto the found event)
                params[5]  = 1   # No fade (the found event should take care of that)
                changed = true
              end
              deletedRoute = nil
              deleteMoveRouteAt = proc { |list,i|
                arr = []
                if list[i] && list[i].code==209   # Set Move Route
                  arr.push(list[i]); list.delete_at(i)
                  while i<list.length
                    break if !list[i] || list[i].code!=509   # Set Move Route (continuation line)
                    arr.push(list[i]); list.delete_at(i)
                  end
                end
                next arr
              }
              insertMoveRouteAt = proc { |list,i,route|
                j = route.length-1
                while j>=0
                  list.insert(i,route[j])
                  j -= 1
                end
              }
              # If the next event command is a Move Route that moves the player,
              # check whether all it does is turn the player in a direction (or
              # its first item is to move the player in a direction). If so, this
              # Transfer Player command may as well set the player's direction
              # instead; make it do so and delete that Move Route.
              if params[4]==0 &&   # Retain direction
                 i+1<list.length && list[i+1].code==209 && list[i+1].parameters[0]==-1   # Set Move Route
                route = list[i+1].parameters[1]
                if route && route.list.length<=2
                  # Delete superfluous move route command if necessary
                  if route.list[0].code==16      # Player Turn Down
                    deleteMoveRouteAt.call(list,i+1); params[4] = 2; changed = true
                  elsif route.list[0].code==17   # Player Turn Left
                    deleteMoveRouteAt.call(list,i+1); params[4] = 4; changed = true
                  elsif route.list[0].code==18   # Player Turn Right
                    deleteMoveRouteAt.call(list,i+1); params[4] = 6; changed = true
                  elsif route.list[0].code==19   # Player Turn Up
                    deleteMoveRouteAt.call(list,i+1); params[4] = 8; changed = true
                  elsif (route.list[0].code==1 || route.list[0].code==2 ||   # Player Move (4-dir)
                     route.list[0].code==3 || route.list[0].code==4) && list.length==4
                    params[4] = [0,2,4,6,8][route.list[0].code]
                    deletedRoute = deleteMoveRouteAt.call(list,i+1); changed = true
                  end
                end
              # If an event command before this one is a Move Route that just
              # turns the player, delete it and make this Transfer Player command
              # set the player's direction instead.
              # (I don't know if it makes sense to do this, as there could be a
              # lot of commands between then and this Transfer Player which this
              # code can't recognise and deal with, so I've quoted this code out.)
              elsif params[4]==0 && i>3   # Retain direction
#                for j in 0...i
#                  if list[j].code==209 && list[j].parameters[0]==-1   # Set Move Route
#                    route = list[j].parameters[1]
#                    if route && route.list.length<=2
#                      oldlistlength = list.length
#                      # Delete superfluous move route command if necessary
#                      if route.list[0].code==16      # Player Turn Down
#                        deleteMoveRouteAt.call(list,j); params[4] = 2; changed = true; i -= (oldlistlength-list.length)
#                      elsif route.list[0].code==17   # Player Turn Left
#                        deleteMoveRouteAt.call(list,j); params[4] = 4; changed = true; i -= (oldlistlength-list.length)
#                      elsif route.list[0].code==18   # Player Turn Right
#                        deleteMoveRouteAt.call(list,j); params[4] = 6; changed = true; i -= (oldlistlength-list.length)
#                      elsif route.list[0].code==19   # Player Turn Up
#                        deleteMoveRouteAt.call(list,j); params[4] = 8; changed = true; i -= (oldlistlength-list.length)
#                      end
#                    end
#                  end
#                end
              # If the next event command changes the screen color, and the one
              # after that is a Move Route which only turns the player in a
              # direction, this Transfer Player command may as well set the
              # player's direction instead; make it do so and delete that Move
              # Route.
              elsif params[4]==0 &&   # Retain direction
                 i+2<list.length &&
                 list[i+1].code==223 &&   # Change Screen Color Tone
                 list[i+2].code==209 &&   # Set Move Route
                 list[i+2].parameters[0]==-1
                route = list[i+2].parameters[1]
                if route && route.list.length<=2
                  # Delete superfluous move route command if necessary
                  if route.list[0].code==16      # Player Turn Down
                    deleteMoveRouteAt.call(list,i+2); params[4] = 2; changed = true
                  elsif route.list[0].code==17   # Player Turn Left
                    deleteMoveRouteAt.call(list,i+2); params[4] = 4; changed = true
                  elsif route.list[0].code==18   # Player Turn Right
                    deleteMoveRouteAt.call(list,i+2); params[4] = 6; changed = true
                  elsif route.list[0].code==19   # Player Turn Up
                    deleteMoveRouteAt.call(list,i+2); params[4] = 8; changed = true
                  end
                end
              end
            end
=end
            # If this is the only event command, convert to a full event
            if list.length==2 || (list.length==3 && (list[0].code==250 || list[1].code==250))   # Play SE
              params[5] = 1   # No fade
              fullTransfer = list[i]
              indent = list[i].indent
              (list.length-1).times { list.delete_at(0) }
              list.insert(0,
                 RPG::EventCommand.new(250,indent,[RPG::AudioFile.new("Exit Door",80,100)]),   # Play SE
                 RPG::EventCommand.new(223,indent,[Tone.new(-255,-255,-255),6]),               # Fade to black
                 RPG::EventCommand.new(106,indent,[8]),                                        # Wait
                 fullTransfer,                                                                 # Transfer event
                 RPG::EventCommand.new(223,indent,[Tone.new(0,0,0),6])                         # Fade to normal
              )
              changed = true
            end
            if false   # deletedRoute
              insertMoveRouteAt.call(list,list.length-1,deletedRoute)
              changed = true
            end
          end
        when 101   # Show Text
          # Capitalise/decapitalise various text formatting codes
          if list[i].parameters[0][0,1]=="\\"
            newx = list[i].parameters[0].clone
            newx.sub!(/^\\[Bb]\s+/,"\\b")
            newx.sub!(/^\\[Rr]\s+/,"\\r")
            newx.sub!(/^\\[Pp][Gg]\s+/,"\\pg")
            newx.sub!(/^\\[Pp][Oo][Gg]\s+/,"\\pog")
            newx.sub!(/^\\[Gg]\s+/,"\\G")
            newx.sub!(/^\\[Cc][Nn]\s+/,"\\CN")
            if list[i].parameters[0]!=newx
              list[i].parameters[0] = newx
              changed = true
            end
          end
          # Split Show Text commands with 5+ lines into multiple Show Text
          # commands each with a maximum of 4 lines
          lines = 1
          j = i+1
          while j<list.length
            break if list[j].code!=401   # Show Text (continuation line)
            if lines%4==0
              list[j].code = 101   # Show Text
              changed = true
            end
            lines += 1
            j += 1
          end
          # If this Show Text command has 2+ lines of text but not much actual
          # text in the first line, merge the second line into it
          if lines>=2 && list[i].parameters[0].length>0 && list[i].parameters[0].length<=20 &&
             !list[i].parameters[0][/\\n/]
            # Very short line
            list[i].parameters[0] += "\\n"+list[i+1].parameters[0]
            list.delete_at(i+1)
            i -= 1   # revisit this text command
            changed = true
          # Check whether this Show Text command has 3+ lines and the next command
          # is also a Show Text
          elsif lines>=3 && list[i+lines] && list[i+lines].code==101   # Show Text
            # Check whether a sentence is being broken midway between two Text
            # commands (i.e. the first Show Text doesn't end in certain punctuation)
            lastLine = list[i+lines-1].parameters[0].sub(/\s+$/,"")
            if lastLine.length>0 && !lastLine[/[\\<]/] && lastLine[/[^\.,\!\?\;\-\"]$/]
              message = list[i].parameters[0]
              j = i+1
              while j<list.length
                break if list[j].code!=401   # Show Text (continuation line)
                message += "\n"+list[j].parameters[0]
                j += 1
              end
              # Find a punctuation mark to split at
              punct = [message.rindex(". "),message.rindex(".\n"),
                 message.rindex("!"),message.rindex("?"),-1].compact.max
              if punct==-1
                punct = [message.rindex(", "),message.rindex(",\n"),-1].compact.max
              end
              if punct!=-1
                # Delete old message
                indent = list[i].indent
                newMessage  = message[0,punct+1].split("\n")
                nextMessage = message[punct+1,message.length].sub(/^\s+/,"").split("\n")
                list[i+lines].code = 401
                lines.times { list.delete_at(i) }
                j = nextMessage.length-1
                while j>=0
                  list.insert(i,RPG::EventCommand.new((j==0) ? 101 : 401,indent,[nextMessage[j]]))
                  j-=1
                end
                j = newMessage.length-1
                while j>=0
                  list.insert(i,RPG::EventCommand.new((j==0) ? 101 : 401,indent,[newMessage[j]]))
                  j -= 1
                end
                changed = true
                i += 1
                next
              end
            end
          end
        when 111   # Conditional Branch
          if list[i].parameters[0]==12   # script
            x = [list[i].parameters[1]]
            changed |= change_scripts(x)
            list[i].parameters[1] = x[0]
            script = x[0]
            if script[trainerMoneyRE]   # Compares $Trainer.money with a value
              # Checking money directly
              operator = $1
              amount   = $2.to_i
              if operator=="<"
                params[0] = 7   # gold
                params[2] = 1
                params[1] = amount-1
                changed = true
              elsif operator=="<="
                params[0] = 7   # gold
                params[2] = 1
                params[1] = amount
                changed = true
              elsif operator==">"
                params[0] = 7   # gold
                params[2] = 0
                params[1] = amount+1
                changed = true
              elsif operator==">="
                params[0] = 7   # gold
                params[2] = 0
                params[1] = amount
                changed = true
              end
            elsif script[/^\s*(Kernel\.)?(pbTrainerBattle|pbDoubleTrainerBattle)/]
              # Check if trainer battle conditional branch is empty
              j = i+1
              isempty = true
              elseIndex = -1
              # Check if page is empty
              while j<page.list.length
                if list[j].indent<=list[i].indent
                  if list[j].code==411   # Else
                    elseIndex = j
                  else
                    break   # Reached end of Conditional Branch
                  end
                end
                if list[j].code!=0 && list[j].code!=411   # Else
                  isempty = false
                  break
                end
                j += 1
              end
              if isempty
                if elseIndex>=0
                  list.insert(elseIndex+1,
                     RPG::EventCommand.new(115,list[i].indent+1,[])   # Exit Event Processing
                  )
                else
                  list.insert(i+1,
                     RPG::EventCommand.new(0,list[i].indent+1,[]),    # Empty Event
                     RPG::EventCommand.new(411,list[i].indent,[]),    # Else
                     RPG::EventCommand.new(115,list[i].indent+1,[])   # Exit Event Processing
                  )
                end
                changed = true
              end
            end
          end
        end
        i += 1
      end
    end
    return (changed) ? event : nil
  end

  #=============================================================================
  # Convert events used as counters into proper counters.
  #=============================================================================
  # Checks if the event has just 1 page, which has no conditions and no commands
  # and whose movement type is "Fixed".
  def plain_event?(event)
    return false unless event
    return false if event.pages.length>1
    return false if event.pages[0].move_type!=0
    return false if event.pages[0].condition.switch1_valid ||
                    event.pages[0].condition.switch2_valid ||
                    event.pages[0].condition.variable_valid ||
                    event.pages[0].condition.self_switch_valid
    return true if event.pages[0].list.length<=1
    return false
  end

  # Checks if the event has just 1 page, which has no conditions and whose
  # movement type is "Fixed". Then checks if there are no commands, or it looks
  # like a simple Mart or a Poké Center nurse event.
  def plain_event_or_mart?(event)
    return false unless event
    return false if event.pages.length>1
    return false if event.pages[0].move_type!=0
    return false if event.pages[0].condition.switch1_valid ||
                    event.pages[0].condition.switch2_valid ||
                    event.pages[0].condition.variable_valid ||
                    event.pages[0].condition.self_switch_valid
    # No commands in the event
    return true if event.pages[0].list.length<=1
    # pbPokemonMart events
    return true if event.pages[0].list.length<=12 &&
                   event.pages[0].graphic.character_name!="" &&   # Has charset
                   event.pages[0].list[0].code==355 &&   # First line is Script
                   event.pages[0].list[0].parameters[0][/^pbPokemonMart/]
    # pbSetPokemonCenter events
    return true if event.pages[0].list.length>8 &&
                   event.pages[0].graphic.character_name!="" &&   # Has charset
                   event.pages[0].list[0].code==355 &&   # First line is Script
                   event.pages[0].list[0].parameters[0][/^pbSetPokemonCenter/]
    return false
  end

  # Given two events that are next to each other, decides whether otherEvent is
  # likely to be a "counter event", i.e. is placed on a tile with the Counter
  # flag, or is on a non-passable tile between two passable tiles (e.g. a desk)
  # where one of those two tiles is occupied by thisEvent.
  def likely_counter?(thisEvent,otherEvent,mapID,mapData)
    # Check whether otherEvent is on a counter tile
    return true if mapData.isCounterTile?(mapID,otherEvent.x,otherEvent.y)
    # Check whether otherEvent is between an event with a graphic (e.g. an NPC)
    # and a spot where the player can be
    yonderX = otherEvent.x + (otherEvent.x - thisEvent.x)
    yonderY = otherEvent.y + (otherEvent.y - thisEvent.y)
    return thisEvent.pages[0].graphic.character_name!="" &&    # Has charset
           otherEvent.pages[0].graphic.character_name=="" &&   # Has no charset
           otherEvent.pages[0].trigger==0 &&                   # Action trigger
           mapData.isPassable?(mapID,thisEvent.x,thisEvent.y) &&
           !mapData.isPassable?(mapID,otherEvent.x,otherEvent.y) &&
           mapData.isPassable?(mapID,yonderX,yonderY)
  end

  # Checks all events in the given map to see if any look like they've been
  # placed on a desk with an NPC behind it, where the event on the desk is the
  # actual interaction with the NPC. In other words, it's not making proper use
  # of the counter flag (which lets the player interact with an event on the
  # other side of counter tiles).
  # Any events found to be like this have their contents merged into the NPC
  # event and the counter event itself is deleted. The tile below the counter
  # event gets its counter flag set (if it isn't already).
  def check_counters(map,mapID,mapData)
    toDelete = []
    changed = false
    for key in map.events.keys
      event = map.events[key]
      next if !plain_event_or_mart?(event)
      # Found an event that is empty or looks like a simple Mart or a Poké
      # Center nurse. Check adjacent events to see if they are "counter events".
      neighbors = []
      neighbors.push(mapData.getEventFromXY(mapID,event.x,event.y-1))
      neighbors.push(mapData.getEventFromXY(mapID,event.x,event.y+1))
      neighbors.push(mapData.getEventFromXY(mapID,event.x-1,event.y))
      neighbors.push(mapData.getEventFromXY(mapID,event.x+1,event.y))
      neighbors.compact!
      for otherEvent in neighbors
        next if plain_event?(otherEvent)   # Blank/cosmetic-only event
        next if !likely_counter?(event,otherEvent,mapID,mapData)
        # Found an adjacent event that looks like it's supposed to be a counter.
        # Set the counter flag of the tile beneath the counter event, copy the
        # counter event's pages to the NPC event, and delete the counter event.
        mapData.setCounterTile(mapID,otherEvent.x,otherEvent.y)
        savedPage = event.pages[0]
        event.pages = otherEvent.pages
        apply_pages(savedPage,event.pages)   # Apply NPC's visuals to new event pages
        toDelete.push(otherEvent.id)
        changed = true
      end
    end
    toDelete.each { |key| map.events.delete(key) }
    return changed
  end

  #=============================================================================
  # Main compiler method for events
  #=============================================================================
  def compile_trainer_events(_mustcompile)
    mapData = MapData.new
    t = Time.now.to_i
    Graphics.update
    trainerChecker = TrainerChecker.new
    for id in mapData.mapinfos.keys.sort
      changed = false
      map = mapData.getMap(id)
      next if !map || !mapData.mapinfos[id]
      pbSetWindowText(_INTL("Processing map {1} ({2})",id,mapData.mapinfos[id].name))
      for key in map.events.keys
        if Time.now.to_i-t>=5
          Graphics.update
          t = Time.now.to_i
        end
        newevent = convert_to_trainer_event(map.events[key],trainerChecker)
        if newevent
          map.events[key] = newevent
          changed = true
        end
        newevent = convert_to_item_event(map.events[key])
        if newevent
          map.events[key] = newevent
          changed = true
        end
        changed = true if fix_event_name(map.events[key])
        newevent = fix_event_use(map.events[key],id,mapData)
        if newevent
          map.events[key] = newevent
          changed = true
        end
      end
      if Time.now.to_i-t>=5
        Graphics.update
        t = Time.now.to_i
      end
      changed = true if check_counters(map,id,mapData)
      if changed
        mapData.saveMap(id)
        mapData.saveTilesets
      end
    end
    changed = false
    Graphics.update
    commonEvents = load_data("Data/CommonEvents.rxdata")
    pbSetWindowText(_INTL("Processing common events"))
    for key in 0...commonEvents.length
      newevent = fix_event_use(commonEvents[key],0,mapData)
      if newevent
        commonEvents[key] = newevent
        changed = true
      end
    end
    save_data(commonEvents,"Data/CommonEvents.rxdata") if changed
  end
end


#===============================================================================
# Script Page: ==================
#===============================================================================


#===============================================================================
# Script Page: [[ Main ]]
#===============================================================================


#===============================================================================
# Script Page: Main
#===============================================================================
class Scene_DebugIntro
  def main
    Graphics.transition(0)
    sscene = PokemonLoad_Scene.new
    sscreen = PokemonLoadScreen.new(sscene)
    sscreen.pbStartLoadScreen
    Graphics.freeze
  end
end

def pbCallTitle
  return Scene_DebugIntro.new if $DEBUG
  return Scene_Intro.new
end

def mainFunction
  if $DEBUG
    pbCriticalCode { mainFunctionDebug }
  else
    mainFunctionDebug
  end
  return 1
end

def mainFunctionDebug
  begin
    PluginManager.runPlugins
    Compiler.main
    Game.initialize
    Game.set_up_system
    Graphics.update
    Graphics.freeze
    $scene = pbCallTitle
    $scene.main until $scene.nil?
    Graphics.transition(20)
  rescue Hangup
    pbPrintException($!) if !$DEBUG
    pbEmergencySave
    raise
  end
end

loop do
  retval = mainFunction
  if retval == 0   # failed
    loop do
      Graphics.update
    end
  elsif retval == 1   # ended successfully
    break
  end
end


